---
title: 2022 Interview
date: 2022-03-25 11:43:42
permalink: /pages/fe34cd/
categories:
tags:
  - interview
---
## 前言
加油呗
<!-- more -->
## TT
* HTTP缓存
  * 强缓存
  * 协商缓存
* 网页渲染流程
* ES Module 和 CommonJS
* Promise.all的实现
```js
function promiseAll(promises) {
  return new Promise((resolve, reject) => {
    const result = [];
    for (let i = 0; i < promises.length; i++) {
      const promise = promises[i];
      Promise.resolve(promise).then(
        res => {
          result.push(res);
          if (i === promises.length - 1) {
            resolve(result);
          }
        },
        error => {
          reject(error);
        }
      );
    }
  });
}
```
* 二叉树公共父节点
```js
function lowestCommonAncestor(root, p, q) {
  if (!root) return null;
  if (root === p || root === q) return root;

  const left = lowestCommonAncestor(root.left, p, q);
  const right = lowestCommonAncestor(root.right, p, q);
  // 根节点为公共父节点
  if (left !== null && right !== null) {
    return root;
  }
  if (left === null && right === null) {
    return null;
  }
  // 左右子树节点为公共父节点
  return left === null ? right : left;
}
```
* 深拷贝
```js
// 数组 基本类型 对象 Map Set 正则 Symbol
const isObject = obj => Object.prototype.toString.call(obj) === "[object Object]";
const isMap = obj => Object.prototype.toString.call(obj) === "[object Map]";
const isSet = obj => Object.prototype.toString.call(obj) === "[object Set]";
const isRegExp = obj => Object.prototype.toString.call(obj) === "[object RegExp]";
const isSymbol = obj => Object.prototype.toString.call(obj) === "[object Symbol]";
const isArray = arr => Array.isArray(arr);
function cloneRegExp(regexp) {
  const result = new RegExp(regexp.source, /\w*$/.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
function cloneSymbol(symbol) {
  return Object(Symbol.prototype.valueOf.call(symbol));
}
function cloneDeep(source) {
  if (typeof source !== "object" || source === null) {
    throw new TypeError("传入参数不是对象");
  }
  const target = {};
  const keys = Object.keys(source);
  for (const key of keys) {
    const value = source[key];
    if (isObject(value)) {
      // 对象
      target[key] = cloneDeep(value);
    } else if (isArray(value)) {
      // 数组
      target[key] = value.slice();
    } else if (isMap(value)) {
      // Map
      const result = new Map();
      value.forEach((subValue, key) => {
        result.set(key, cloneDeep(subValue));
      });
      target[key] = result;
    } else if (isSet(value)) {
      // Set
      const result = new Set();
      value.forEach(subValue => {
        result.add(cloneDeep(subValue));
      });
      target[key] = result;
    } else if (isRegExp) {
      // RegExp
      target[key] = cloneRegExp(value);
    } else if (isSymbol) {
      // Symbol
      target[key] = cloneSymbol(value);
    } else {
      target[key] = value;
    }
  }
  return target;
}
```
* 按层级倒序输出对象属性
```js
const obj = {
  a: {
    b: {
      c: { f: "aa" },
    },
    d: {
      e: { g: "bb" },
      h: { i: "cc" },
    },
    j: {
      k: "dd",
    },
  },
};
// 输出 [f,g,i,c,e,h,k,b,d,j,a]

const isObject = obj => Object.prototype.toString.call(obj) === "[object Object]";
// 层次遍历
function serializeProperties(obj) {
  const props = Object.keys(obj);
  if (!props.length) return [];
  const res = [];
  const queue = [];
  queue.push(obj);
  while (queue.length) {
    const level = [];
    const len = queue.length;
    for (let i = 0; i < len; i++) {
      const cur = queue.shift();
      const curProps = Object.keys(cur);
      for (const prop of curProps) {
        level.push(prop);
        if (isObject(cur[prop])) {
          queue.push(cur[prop]);
        }
      }
    }
    res.unshift(...level);
  }
  return res;
}
```

* 项目经验
* 性能把控方式
* mvc mvvm等架构理解
* 项目管控手段
* 20匹马，最多5匹一组比赛，多少次可找到前三名
```
需要4 + 1 + 1 = 6 次
```
* 通知队列的实现

* 100个球两个人每次最多取五个最少取一个，谁能拿到最后一个就赢，求第一个取的人的必胜方法。
先拿的人拿4个，不论第二个人拿几个，第一个人把他凑成6个，这样永远是第一个人取到最后一个。
## TT用户增长
* 二叉树层序遍历, 每层的节点放到一个数组里
```js
function levelOrder(root){
  if(!root) return []
  const res = []
  const queue = []
  queue.push(root)
  while(queue.length) {
    const level = []
    const len = queue.length
    for(let i = 0; i < len; i ++) {
      const node = queue.shift()
      level.push(node.val)
      if(node.left) queue.push(node.left)
      if(node.right) queue.push(node.right)
    }
    res.push(level)
  }
  return res
}
```
* 实现一个函数, fetchWithRetry 会自动重试3次，任意一次成功直接返回
```js
function fetchWithRetry(url, init, times = 3, delay = 1000) {
  return new Promise((resolve, reject) => {
    function retry(attempt) {
      setTimeout(() => {
        wrappedFetch(++attempt);
      }, delay);
    }
    function wrappedFetch(attempt) {
      fetch(url, init)
        .then(response => {
          resolve(response);
        })
        .catch(error => {
          if (attempt < times) {
            retry(attempt);
          } else {
            reject(error);
          }
        });
    }
    wrappedFetch(0);
  });
}
// example
fetchWithRetry("https://www.google.com.hk", { method: "GET" })
  .then(res => res.text())
  .then(text => console.log(text))
  .catch(error => console.log(error));
```
* 对于一个给定的链表，返回环的入口节点，如果没有环，返回null
```js
function detectCycle(head) {
  let fast = head;
  let slow = head;
  while (fast !== null && fast.next !== null) {
    fast = fast.next.next;
    slow = slow.next;
    if (fast === slow) break;
  }
  slow = head;
  while (slow !== fast) {
    fast = fast.next;
    slow = slow.next;
  }
  return slow;
}
```
* 截图怎么实现
  * 主要思路还是靠页面dom转化成canvas或者svg图片来解决。html2canvas dom-to-image
  * canvas
    * 
    * 递归取出目标模版的所有DOM节点，填充到一个renderList，并附加是否为顶层元素/包含内容的容器等信息。
    * 通过z-index、position、float等css属性和元素的层级信息将renderList排序，计算出一个canvas的renderQueue。
    * 遍历renderQueue，将css样式转为setFillStyle可识别的参数，依据nodeType调用相对应canvas方法，如文本则调用fillText，图片drawImage，设置背景色的div调用fillRect等。
    * 将画好的canvas填充进页面。
    * toDataURL/toBlob 导出图片。这两个API都受到同源策略的限制而无法跨域。
  * svg
    * **SVG无法加载外部资源**
    * foreignObject 标签，这个标签可以加载其它命名空间的xml(xhtml)文档
    * 利用 Blob 生产 blob 对象
    * 利用 window.URL.createObjectURL 生成 url
* qps达到峰值了，怎么去优化
  * 流量优化：防盗链处理
  * 前端优化：减少HTTP请求，合并css或js，添加异步请求，启用浏览器缓存和文件压缩，CDN加速，建立独立图片服务器
  * 服务端优化：页面静态化，并发处理，队列处理
  * 存储优化：数据库缓存，分库分表，分区操作，读写分离，负载均衡
  * Web服务器优化：负载均衡，nginx反向代理
* 谷歌图片, 如果要实现一个类似的系统或者页面, 你会怎么做?
* 最小的k个数
```js
// 快速排序
// 堆排序
// 二叉搜索树
// 桶计数
function getLeastNumbers(arr, k) {
  if (k === 0 || arr.length === 0) {
    return [];
  }
  return quickSearch(arr, 0, arr.length - 1, k);
}
function quickSearch(arr, lo, hi, k) {
  const mi = partition(arr, lo, hi);
  if (mi === k - 1) {
    return arr.slice(0, k);
  }
  return mi > k - 1 ? quickSearch(arr, lo, mi - 1, k) : quickSearch(arr, mi + 1, hi, k);
}
function partition(arr, lo, hi) {
  let pivot = arr[lo];
  while (lo < hi) {
    while (lo < hi && pivot <= arr[hi]) hi--;
    arr[lo] = arr[hi];
    while (lo < hi && arr[lo] <= pivot) lo++;
    arr[hi] = arr[lo];
  }
  arr[lo] = pivot;
  return lo;
}
```
* 节流防抖
```js
// 防抖
function debounce(fn, wait) {
  let timer = null;
  return function(...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, wait);
  };
}
// 节流, 时间戳实现
function throttle(fn, wait) {
  let lastTime = 0;
  return function(...args) {
    const timestamp = Date.now();
    if (timestamp - lastTime >= wait) {
      lastTime = timestamp;
      fn.apply(this, args);
    }
  };
}
// 节流，定时器实现
function throttle(fn, wait) {
  let timer = null;
  return function(...args) {
    if (timer) return;
    timer = setTimeout(() => {
      fn.apply(this, args);
      clearTimeout(timer);
      timer = null;
    }, wait);
  };
}
```
* sleep函数
```js
function sleep(sleepTime) {
  const start = new Date().now();
  for (; new Date() - start <= sleepTime; ) {}
}

const sleep = (time) => new Promise(resolve => setTimeout(resolve, time))
```

* 要求多种方式实现： Input: 'abcdaaabbccccdddefgaaa'，Output: 4
  * 1. 输出叠词的数量
  * 2. 输出去重叠词的数量
```js
// 最长无重复子串 滑动窗口
// 最小覆盖子串 滑动窗口
// aaa bb cccc ddd 算作叠词
function getSubStr(str) {
  if (!str) return 0;
  let slow = 0;
  let fast = 1;
  // let res = 0;
  let res = new Set();
  const len = str.length;
  while (fast < len) {
    const cur = str[slow];
    const next = str[fast];
    if (cur === next) {
      fast += 1;
    } else {
      if (fast - slow > 1) {
        const substr = str.slice(slow, fast);
        console.log(substr);
        // res += 1;
        res.add(substr);
      }
      slow = fast;
      fast += 1;
    }
  }
  if (fast - slow > 1) {
    const substr = str.slice(slow, fast);
    console.log(substr);
    // res += 1;
    res.add(substr);
  }
  console.log(res);
  return res.size;
}
```
* 如何判断对象 or 数组
```js
// 判断对象
const isObject = obj => Object.prototype.toString.call(obj) === "[object Object]";
const isObject = obj => obj.constructor === Object;
const isObject = obj => Object.getPrototypeOf(obj) === Object.prototype;
// 判断数组
const isArray = arr => Array.isArray(arr);
const isArray = arr => arr instanceof Array;
const isArray = arr => Object.prototype.toString.call(arr) === "[object Array]";
const isArray = arr => arr.constructor === Array;
const isArray = arr => Array.prototype.isPrototypeOf(arr);
const isArray = arr => Object.getPrototypeOf(arr) === Array.prototype;
```
## 字节商业化
* 问了vue react区别，我把vue2vue3react实现原理说了下 diff原理说了下；
* 讲讲项目实现；
* this指针问题；
* 手写一个函数式实现；
* https；
* 浏览器node事件循环；
* 我问了下团队稳定性吧啦吧啦说一堆

* 129. 求根节点到叶节点数字之和
```js
const dfs = (root, cur, res) => {
  if (!root) return;
  cur += root.val;
  if (!root.left && !root.right) {
    res.push(cur);
    return;
  }
  dfs(root.left, cur, res);
  dfs(root.right, cur, res);
};

const sumNumbers = root => {
  const res = [];
  dfs(root, "", res);
  return res.reduce((pre, cur) => +pre + +cur, 0);
};
```

* 就聊业务么，一直聊业务的具体数据 比如问我营销发券量、核销率

## 基础架构
* 异步加载JS文件 defer 和 async的区别
  * async: 加载完成后立即执行，不保证按照出现顺序执行
  * defer：等HTML解析完再执行，执行顺序按照出现顺序
* BFC 概念，如何触发，如何应用
* 用flex布局实现一个骰子的5个点 每个点都是实心的
* 实现 手写一个new
```js
function newOp(...args) {
  let obj = {};
  let Con = args.shift();
  obj.__proto__ = Con.prototype;
  let result = Con.apply(obj, args);
  return result instanceof Object ? result : obj;
}
```
* 说出下列打印顺序
```js
setTimeout(function () {
  console.log("set1");
  new Promise(function (resolve) {
    resolve();
  }).then(function () {
    new Promise(function (resolve) {
      resolve();
    }).then(function () {
      console.log("then4");
    });
    console.log("then2");
  });
});

new Promise(function (resolve) {
  console.log("pr1");
  resolve();
}).then(function () {
  console.log("then1");
});

setTimeout(function () {
  console.log("set2");
});

console.log(2);

new Promise(function (resolve) {
  resolve();
}).then(function () {
  console.log("then3");
});
// 打印顺序：pr1 2 then1 then3 set1 then2 then4 set2
```
* js的垃圾回收机制
  * 新生代和老生代 - 代际假说
  * 新生代采用Scavenge
  * 新生代中有对象晋升策略
  * 老生代采用标记清除和标记整理
* 二叉树的最小深度
```js
function minDepth(root) {
  if (root === null) return 0;
  const queue = [];
  queue.push(root);
  let depth = 1;
  while (queue.length) {
    const len = queue.length;
    for (let i = 0; i < len; i++) {
      const node = queue.shift();
      if (node.left === null && node.right === null) {
        return depth;
      }
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    depth += 1;
  }
  return depth;
}
```
* 判断回文串
```js
function validPalindrome(s) {
  const wordReg = /[a-zA-Z0-9]/;
  let start = 0;
  let end = s.length - 1;
  while (start < end) {
    while (!wordReg.test(s[start]) && start <= end) start++;
    while (!wordReg.test(s[end]) && start <= end) end--;
    if (s[start].toLowerCase() !== s[end].toLowerCase()) {
      return false;
    }
    start++;
    end--;
  }
  return true;
}
const s = "nowcoder Is Best tsebsi: redoc won";
console.log(validPalindrome(s));
```
## 字节一面

* 下面代码的输出结果
```js
// a.js
let count = 1;
function setCount () {
  count += 1
}

setTimeout(() => {
  console.log('a', count)
});

module.exports = {
  count,
  setCount
}

//b.js
const obj = require('a.js');
obj.setCount();
console.log('b', obj.count);
setTimeout(() => {
  console.log('b.next', obj.count)
});
// b 1
// a 2
// b.next 1
```
* 事件循环
```js
setTimeout(function() {
  console.log(1)
  new Promise(function(resolve) {
    resolve();
    console.log(2)
  }).then(() => {
    setTimeout(() => {
      console.log(3)
    })
    console.log(4)
  })
})

new Promise(function(resolve) {
  console.log(5)
  for(var i = 0; i < 1e4;i ++) {
    i === 9999 && resolve();
  }
  console.log(6)
}).then(() => {
  console.log(7)
})

console.log(8)
// 5 6 8 7 1 2 4 3
```
* 用两个栈实现一个队列，只能使用栈的 push，pop 方法，实现队列的 push，shift 方法
```js
class Queue {
  constructor() {
    this.inStack = [];
    this.outStack = [];
  }

  push(item) {
    this.inStack.push(item);
  }

  shift() {
    if (!this.outStack.length) {
      const len = this.inStack.length;
      for (let i = 0; i < len; i++) {
        const item = this.inStack.pop();
        this.outStack.push(item);
      }
    }
    return this.outStack.pop();
  }
}
```
* 判断二叉树是否对称
```js
function isSymmetric(root) {
  return isMirror(root, root);
}
function isMirror(t1, t2) {
  if (t1 === null && t2 === null) return true;
  if (t1 === null || t2 === null) return false;
  return t1.val === t2.val 
    && isMirror(t1.left, t2.right) 
    && isMirror(t1.right, t2.left);
}
```
* 二叉树左右视图
```js
// 广度优先遍历
// 左视图
function leftSideView(root) {
  if (!root) return [];
  let res = [];
  const queue = [];
  const depth = [];
  queue.push(root);
  depth.push(0);
  while (queue.length > 0) {
    const node = queue.shift();
    const dep = depth.shift();
    if (res.length === dep) {
      res.push(node.val);
    }
    // 先放入左子树
    if (node.left) {
      queue.push(node.left);
      depth.push(dep + 1);
    }
    if (node.right) {
      queue.push(node.right);
      depth.push(dep + 1);
    }
  }
  return res;
}

// 右视图
function rightSideView(root) {
  if (!root) return [];
  let res = [];
  const queue = [];
  const depth = [];
  queue.push(root);
  depth.push(0);
  while (queue.length > 0) {
    const node = queue.shift();
    const dep = depth.shift();
    if (res.length === dep) {
      res.push(node.val);
    }
    // 先放入右子树
    if (node.right) {
      queue.push(node.right);
      depth.push(dep + 1);
    }
    if (node.left) {
      queue.push(node.left);
      depth.push(dep + 1);
    }
  }
  return res;
}
```
* 使用 reduce 方法实现 map 方法的 polyfill
```js
function map(arr, fn) {
  const res = [];
  let index = 0;
  arr.reduce((_, cur) => {
    const item = fn(cur, index, arr);
    res.push(item);
    index += 1;
    return null;
  }, null);
  return res;
}

const arr = [1, 2, 3, 4, 5];
console.log(
  map(arr, (item, index, arr) => {
    console.log(item, index, arr);
    return item + 1;
  })
);
```
* 实现一个三栏居中布局，左右两边固定宽度 200px
* TypeScript 相关，泛型、infer
  * 当我们希望条件符合特定的类型结构，但某个类型希望交由 TypeScript 推断时，可以加入 infer 关键字来帮忙。
  * infer关键字必须用在「条件类型子句」中，也就是extends后面、?前面的位置中。
  ```ts
    type Item<T> = T extends (infer U)[] ? U : never;
  ```
  * infer不能写在「类型参数的限制子句」中。
  ```ts
    // 这是错误的
    type Item<T extends (infer U)[]> = U;
  ```
* js 实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有两个。
```js
const microTask = (delay, id) =>
  new Promise(resolve => {
    setTimeout(() => {
      console.log(id);
      resolve();
    }, delay);
  });

class Scheduler {
  constructor(limit = 2) {
    this.limit = limit;
    this.queue = [];
    this.process = [];
  }

  addTask(task) {
    this.queue.push(task);
    this.run();
  }

  run() {
    while (this.process.length < this.limit && this.queue.length > 0) {
      const task = this.queue.shift();
      const p = task().then(() => {
        const idx = this.process.indexOf(p);
        this.process.splice(idx, 1);
        this.run();
      });
      this.process.push(p);
    }
  }
}

const scheduler = new Scheduler(2);
scheduler.addTask(() => microTask(1000, 1));
scheduler.addTask(() => microTask(500, 2));
scheduler.addTask(() => microTask(300, 3));
scheduler.addTask(() => microTask(400, 4));
// 输出 2 3 1 4
```

## 猿辅导
* promise 打印顺序
```js
let p = new Promise((resolve, reject) => {
  resolve();
  console.log(1);
  reject();
});

p.catch(() => console.log(3)) // catch和then根据promise的状态来执行
  .then(() => console.log(2))
  .finally(() => console.log(4)); // finally会根据自己的位置来执行

// 1 2 4
```
* 定义`uploadFile(file: File): Promise<number>`方法, 实现`batchUpload(files: File[], limit: number): Promise<number[]>`函数，实现文件批量上传。
```js
function batchUpload(files, limit){
  const ret = []
  const executing = new Set()
  let idx = 0
  const next = () => {
    if(files.length <= idx) return Promise.resolve()

    const p = uploadFile(files[idx++])
    ret.push(p)
    executing.add(p)
    const clean = (p) => {
      executing.delete(p)
    }
    p.then(clean, clean)

    let r = Promise.resolve()
    if(executing.size >= limit) {
      r = Promise.race(executing)
    }
    return r.then(() => next())
  }
  return next().then(() => Promise.all(ret))
}
```