---
title: 2022 Interview
date: 2022-02-28 11:58:10
permalink: /pages/33969f/
categories:
tags:
  - interview
---
## 大纲
![大纲](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/大纲.3ttblao9ahw0.webp)
## 基础
### HTML
* HTML5 语义化标签
  * 语义化标签： `header`，`nav`，`main`，`article`，`section`，`aside`，`footer`
  * 语义化意味着顾名思义，HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构，而不是滥用div。
  * 语义化的优点有:
    * 代码结构清晰，易于阅读，利于开发和维护
    * 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。
    * 有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重
* script标签中的 `defer`和`async`属性
  * 相同点：
    * 都是`异步加载资源`
  * 区别：
    * `async`属性是异步加载，`加载完成后立即执行`，标记为async的脚本`不保证按照出现顺序`执行
    * 标记为`defer`属性的脚本会`等到HTML解析完成后再执行`，执行顺序就是`按照出现顺序`
### CSS
* CSS 盒模型
  * box-sizing: border-box, content-box
  * 分为标准盒模型和IE盒模型，在标准盒子模型中，width 指 content 部分的宽度，在IE盒子模型中，width 表示 content+padding+border 这三个部分的宽度
  * box-sizing:content-box 表示标准盒子模型，box-sizing:border-box 表示的是IE盒子模型
* flex布局
  * 常用属性：
    * `flex-direction`: 主轴方向，默认值为`row`，`column`为垂直方向排列
    * `justify-content`：主轴方向排列方式，可选属性为：`flex-start`，`flex-end`，`center`，`space-between`，`space-around`
    * `align-items`：副轴方向排列方式，可选属性与`justify-content`相同
    * `flex-wrap`：换行规则，可选属性为：`nowrap`，`wrap`，`wrap-reverse`
    * `flex-grow`：定义项目的放大比例，默认为1
    * `flex-shrink`：定义项目的缩放比例，定义为0则代表不缩放
    * `flex-basic`：定义再分配多余空间，项目占用的空间
    * `flex`：是`flex-grow`，`flex-shrink`，`flex-basic`的简写，默认为`0 1 auto`
    * `order`：定义项目的排列顺序，顺序越小，排列越靠前，默认为0
* 三栏布局
  * 圣杯布局

  ::: demo [vanilla]
  ```html
  <style>
  .holy-grail-header {
      background-color: blue;
  }
  .holy-grail-main {
      background-color: orange;
      padding: 0 100px; /* 左右两边的padding来放置left和right区域 */
  }
  .holy-grail-main-left,.holy-grail-main-center,.holy-grail-main-right {
      float: left;
  }
  .holy-grail-main-center {
      background-color: purple;
      width: 100%; /* 这会把left和right挤到下一行 */
  }
  .holy-grail-main-left {
      background-color: red;
      width: 100px;
      margin-left: -100%; /* 把left移动到和center同一行并且左边对齐 */
      position: relative;
      left: -100px; /* 再向左移动到main的padding区域,就不会挡住center了 */
  }
  .holy-grail-main-right {
      background-color: grey;
      width: 100px;
      margin-left: -100px; /* 把left移动到和center同一行并且右边对齐 */
      position: relative;
      left: 100px; /* 向右移动到右边的padding区域*/
  }
  .holy-grail-footer {
      background-color: pink;
  }
  /* 清除浮动 */
  .clear-fix::after {
      content: "";
      display: block;
      clear: both;
  }
  </style>
  <html>
    <header class="holy-grail-header">头部</header>
    <div class="holy-grail-main clear-fix">
        <div class="holy-grail-main-center">中间</div>
        <div class="holy-grail-main-left">左侧</div>
        <div class="holy-grail-main-right">右侧</div>
    </div>
    <footer class="holy-grail-footer">底部</footer>
  </html>
  ```
  :::

  * 双飞翼布局

  ::: demo [vanilla]
  ```html
  <style>
  .wings-header {
      background-color: blue;
  }
  .wings-first,.wings-second,.wings-third {
      float: left;
  }
  /* 用这个div把主内容包起来之后,主内容就可使用margin空出两边的区域了 */
  .wings-first {
      width: 100%;
      background-color: purple;
  }
  .wings-first-content {
      margin: 0 100px;
  }
  .wings-second {
      width: 100px;
      background-color: red;
      margin-left: -100%; /* 作用和圣杯一样 */
  }
  .wings-third {
      width: 100px;
      background-color: grey;
      margin-left: -100px; /* 作用和圣杯一样 */
  }
  .wings-footer {
      background-color: pink;
      clear: both; /* 清除footer上面元素的浮动 */
  }
  </style>
  <html>
    <header class="wings-header">头部</header>
    <div class="wings-first">
      <div class="wings-first-content">中间</div>
    </div>
    <div class="wings-second">左侧</div>
    <div class="wings-third">右侧</div>
    <footer class="wings-footer">底部</footer> 
  </html>
  ```
  :::

  * flex布局
  
  ::: demo [vanilla]
  ```html
  <style>
  .flex-header {
    background-color: blue;
  }
  .flex-box {
      display: flex;
  }
  .flex-center {
    background-color: purple;
    flex-grow: 1;
  }
  .flex-left {
    background-color: red;
    order: -1;
    flex: 0 0 100px;
  }
  .flex-right {
    background-color: grey;
    flex: 0 0 100px;
  }
  .flex-footer {
    background-color: pink;
  }
  </style>
  <html>
    <header class="flex-header">头部</header>
    <div class="flex-box">
      <div class="flex-center">中间</div>
      <div class="flex-left">左侧</div>
      <div class="flex-right">右侧</div>
    </div>
    <footer class="flex-footer">底部</footer>
  </html>
  ```
  :::
* `BFC`(块级格式化上下文)
  * `BFC`这是一个独立的`渲染区域`，规定了内部如何布局，并且这个区域的子元素不会影响到外面的元素
  * BFC内部box`垂直放置`
  * 计算BFC的高度的时候，`浮动元素`也参与计算
  * 哪些元素会生成 BFC：
    * `float` 不为 `none` 的元素
    * `position` 为 `fixed` 和 `absolute` 的元素
    * `display` 为 `inline-block`、`table-cell`、`table-caption`，`flex`，`inline-flex` 的元素
    * `overflow` 不为 `visible` 的元素
* `position` 属性
  * `fixed`：固定定位，相对于浏览器窗口进行定位
  * `absolute`：绝对定位，绝对定位的元素的位置相对于最近的已定位父元素
  * `relative`：相对定位
  * `sticky`：粘性定位，元素先按照普通文档流定位，然后相对于该元素在流中的 `flow root`（BFC）和 `containing block`（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。
* CSS的选择器有哪些？优先级？
  * CSS选择器有：
    * 基本选择器：`通用选择器`(*)，`元素选择器`，`类选择器`，`ID选择器`，`属性选择器`
    * 分组选择器：`选择器列表`(A, B)
    * 组合器：`后代组合器`(A B)，`直接子代组合器`(A>B)，`一般兄组合器`(A-B)，`紧邻兄弟组合器`(A+B)
    * 伪选择器：`伪类`，`伪元素`
  * 选择器优先级：
    * 第一优先级：!important
    * 内联样式，1000
    * ID选择器，0100
    * 类、伪类、属性选择器，0010
    * 标签、伪元素选择器，0001
    * 通配符、子类选择器、兄弟选择器，0000
* 清除浮动
  * 浮动元素后使用带`clear: both;`属性的空元素
  * 浮动元素容器使用CSS的`overflow: hidden/auto;`属性，IE中还需要增加`zoom:1`属性
  * 给浮动的元素的容器添加浮动
  * 给浮动元素的容器添加一个`clear-fix`的class，然后给这个class添加一个`:after`伪元素实现元素末尾添加一个看不见的块元素清理浮动
* `link`和`@import`区别
  * `link`属于`HTML`标签，而`@import`是`CSS`提供的
  * 页面被加载的时，`link`会同时被加载，而`@import`被引用的`CSS`会等到引用它的`CSS`文件被加载完再加载
  * `import`只在`IE5`以上才能识别，而`link`是`HTML`标签，无兼容问题
  * `link`方式的样式的权重 高于`@import`的权重
* 哪些样式可以被继承
  * 文本相关属性：`font-family`、`font-size`、`font-weight`、`line-height`
  * 列表相关的属性：`list-style-image`、`list-style-position`、`list-style-type`、`list-style`
  * `color`
### JS
* 类型与判断
  * 数据类型：`Number`、`String`、`Boolean`、`undefined`、`object`、`Null`、`Symbol`、`bigint`
  * 基本数据类型：`String`、`Number`、`boolean`、`null`、`undefined`、`Symbol`
  * 引用类型：`object`。里面包含的 `function`、`Array`、`Date`
  * 类型判断
    * `typeof`
      * `typeof`可以对基本类型`number`、`string`、`boolean`、`undefined`做出准确的判断
      * 而对于引用类型，除了`function`之外返回的都是`object`
    * `instanceof`
      * 当我们需要知道某个对象的具体类型时,可以用运算符`instanceof`，`instanceof`操作符判断左操作数对象的原型链上是否有右边这个构造函数的`prototype`属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值。
    * `constructor`
      * `constructor`属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。
      ```js
      var f = new F();
      f.constructor === F;// true
      ```
    * `Object.prototype.toString.call`
      * `toString`是`Object`原型对象上的一个方法，该方法默认返回其调用者的具体类型
      ```js
      Object.prototype.toString.call('') ;   // [object String]
      Object.prototype.toString.call(1) ;    // [object Number]
      Object.prototype.toString.call(true) ; // [object Boolean]
      Object.prototype.toString.call(undefined) ; // [object Undefined]
      Object.prototype.toString.call(null) ; // [object Null]
      Object.prototype.toString.call(new Function()) ; // [object Function]
      Object.prototype.toString.call(new Date()) ; // [object Date]
      Object.prototype.toString.call([]) ; // [object Array]
      Object.prototype.toString.call(new RegExp()) ; // [object RegExp]
      Object.prototype.toString.call(new Error()) ; // [object Error]
      ```
    * 特定方法
      * `Array.isArray` 用来判断是否是数组
* 原型链
* 继承
  * `原型链继承`
    * 通过在父类原型链上声明方法，并将子类的`prototype`指向父类的实例
    ```js
    function Parent () {
      this.name = 'kevin';
    }
    Parent.prototype.getName = function () {
      console.log(this.name);
    }
    function Child () {}
    Child.prototype = new Parent();

    var child1 = new Child();
    console.log(child1.getName()) // kevin
    ```
    * 缺点
      * 引用类型的属性被所有实例共享
      * 在创建`Child`的时候，不能向`Parent`传参
  * `借用构造函数`
    * 在`子类构造函数`中执行`父类的构造函数`
    ```js
    function Parent () {
      this.names = ['kevin', 'daisy'];
    }

    function Child () {
      Parent.call(this);
    }

    var child1 = new Child();
    child1.names.push('yayu');
    console.log(child1.names); // ["kevin", "daisy", "yayu"]

    var child2 = new Child();
    console.log(child2.names); // ["kevin", "daisy"]
    ```
    * 优点：
      * 避免了引用类型的属性被所有实例共享
      * 可以在 Child 中向 Parent 传参
    * 缺点：
      * 方法都在构造函数中定义，每次创建实例都会自动创建一遍方法
  * `组合继承`
    * `借用构造函数` + 指定子类`prototype`
    ```js
    function Parent (name) {
      this.name = name;
      this.colors = ['red', 'blue', 'green'];
    }

    Parent.prototype.getName = function () {
      console.log(this.name);
    }

    function Child (name, age) {
      Parent.call(this, name);
      this.age = age;
    }

    Child.prototype = new Parent();
    Child.prototype.constructor = Child;

    var child1 = new Child('kevin', '18');
    child1.colors.push('black');
    console.log(child1.name); // kevin
    console.log(child1.age); // 18
    console.log(child1.colors); // ["red", "blue", "green", "black"]

    var child2 = new Child('daisy', '20');
    console.log(child2.name); // daisy
    console.log(child2.age); // 20
    console.log(child2.colors); // ["red", "blue", "green"]
    ```
    * `组合继承`最大的缺点是会调用`两次父构造函数`
  * `原型式继承`
    * 已传入的对象实例为父类
    ```js
    function createObj(o){
      function F(){}
      F.prototype = o
      return new F()
    }
    ```
    * 缺点：
      * 包含引用类型的属性值始终都会`共享`相应的值，这点跟原型链继承一样
  * 寄生式继承
    * 创建一个仅用于`封装继承`过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象
    * 借用`Object.create`实现继承关系
    ```js
    function createObj (o) {
      var clone = Object.create(o);
      clone.sayName = function () {
          console.log('hi');
      }
      return clone;
    }
    ```
    * 缺点：
      * 跟借用构造函数模式一样，每次创建对象都会创建一遍方法
  * 寄生组合式继承
    * 在组合继承的基础上，间接的让`Child.prototype`访问到`Parent.prototype`
    ```js
    function Parent (name) {
      this.name = name;
      this.colors = ['red', 'blue', 'green'];
    }

    Parent.prototype.getName = function () {
      console.log(this.name)
    }

    function Child (name, age) {
      Parent.call(this, name);
      this.age = age;
    }

    // 关键的三步，在组合继承中则是直接将Child,prototype指向新创建的Parent实例
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();

    var child1 = new Child('kevin', '18');
    console.log(child1);
    ```
  * Class继承
    * 主要是依赖`extends`关键字来实现继承，且继承的效果类似于`寄生组合继承`
    * 使用了`extends`实现继承不一定要`constructor`和`super`，因为没有的话会默认产生并调用它们
    * `extends`后面接着的目标不一定是`class`，只要是个有`prototype`属性的`函数`就可以了
  * Super相关
    * 在实现继承时，如果子类中有`constructor`函数，必须得在`constructor`中调用一下`super`函数，因为它就是用来产生实例`this`的。
    * super有两种调用方式：当成`函数调用`和当成`对象调用`。
    * super当成`函数调用`时，代表父类的构造函数，且返回的是子类的实例，也就是此时`super`内部的`this`指向子类。在子类的`constructor`中`super()`就相当于是`Parent.constructor.call(this)`。
    * super当成`对象调用`时，普通函数中`super`对象指向父类的原型对象，静态函数中指向父类。且通过`super`调用父类的方法时，`super`会绑定子类的`this`，就相当于是`Parent.prototype.fn.call(this)`。
* `this`与`apply/call/bind`
  * 通常下`this`指向有以下几种情况：
    * 作为函数调用，非严格模式下，`this`指向`window`，严格模式下，`this`指向`undefined`；
    * 作为某对象的方法调用，`this`通常指向调用的对象。
    * 使用`apply`、`call`、`bind` 可以绑定`this`的指向。
    * 在构造函数中，`this`指向新创建的对象
    * 箭头函数没有单独的`this`值，`this`在箭头函数创建时确定，它与声明所在的上下文相同。
  * `apply/call/bind` 区别
    * `apply`调用后会执行函数，并且`apply`可以接受数组作为参数，并且将数组的元素解构传入被调用的函数中。
    * `call`调用后会执行函数，`call`接受的参数都会传入被调用的函数中。
    * `bind`调用后则是返回绑定`this`的函数，并且在调用时传入参数，那么返回的函数会自动保留传入的参数，再调用函数时可以接着传后续的参数。`bind`多次依然指向第一次`bind`的`this`。
* 闭包
  * 使用闭包主要是为了设计私有的方法和变量。在js中，函数即闭包，只有函数才会产生`作用域`的概念
  * 原理
    * 利用了`函数作用域链`的特性，一个函数内部定义的函数会将包含外部函数的`活动对象`添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的`作用域链`仍然在引用这个`活动对象`，所以其活动对象不会被销毁，直到内部函数被销毁后才被销毁
  * 优点
    * 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用
    * 避免变量`污染全局`
    * 把变量存到独立的`作用域`，作为私有成员存在
  * 缺点
    * 对`内存消耗`有影响，因为内部函数保存了对外部变量的引用，导致无法被`垃圾回收`，增大内存的使用量，所以使用不当会造成`内存泄漏`。
    * 对`处理速度`有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度
  * 应用
    * 模块封装
    * 柯里化函数
    * 使用闭包实现私有化方法和变量
    * 缓存一些结果
* 事件循环
![event-loop](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/16fb7ae3b678f1ea_tplv-t2oaga2asx-watermark.1x665gbn9n40.webp)
  * 流程
    * JS分为`同步任务`和`异步任务`
    * `同步任务`都在主线程上执行，会形成一个执行栈
    * `事件触发线程`管理着一个`任务队列`，只要`异步任务`有了运行结果，就在任务队列之中放一个事件回调
    * 一旦`执行栈`中的所有`同步任务`执行完毕，系统就会读取`任务队列`，将可运行的`异步任务`添加到`执行栈`中，开始执行
  * 宏任务
    * 在`ECMAScript`中，`macrotask`也被称为`task`
    * 由于`JS引擎线程`和`GUI渲染线程`是互斥的关系，浏览器为了能够使`宏任务`和`DOM任务`有序的进行，会在一个`宏任务`执行结果后，在下一个`宏任务`执行前，`GUI渲染线程`开始工作，对页面进行渲染
    ```
    宏任务 -> GUI渲染 -> 宏任务 -> ...
    ```
    * 常见的宏任务
      * `主代码块(script)`
      * `setTimeout/setInterval/setImmediate(Node)`
      * `requestAnimationFrame`
      * `MessageChannel`
  * 微任务
    * ES6新引入了`Promise`标准，同时浏览器实现上多了一个`microtask`微任务概念，在`ECMAScript`中，`microtask`也被称为`jobs`
    * 当一个`宏任务`执行完，会在渲染前，将执行期间所产生的所有`微任务`都执行完
    ```
    宏任务 -> 微任务 -> GUI渲染 -> 宏任务 -> ...
    ```
    * 常见的`微任务`：
      * `process.nextTick[Node]`
      * `Promise.[then/catch/finally]`
      * `queueMicrotask`
      * `Object.observe`
      * `MutationObserver`
  * Node.js的事件循环
  ```
  Node会先执行所有类型为 timers 的 MacroTask，然后执行所有的 MicroTask(NextTick例外)
  进入 poll 阶段，执行几乎所有 MacroTask，然后执行所有的 MicroTask
  再执行所有类型为 check 的 MacroTask，然后执行所有的 MicroTask
  再执行所有类型为 close callbacks 的 MacroTask，然后执行所有的 MicroTask
  至此，完成一个 Tick，回到 timers 阶段
  ……
  如此反复，无穷无尽……
  ```
* Promise
  * `Promise`解决了什么问题？
    * “回调地狱”所说的嵌套其实是指异步的嵌套。它带来了两个问题：`可读性`的问题和`信任`问题。
    * 异步嵌套带来的`信任`问题，它的问题的根源在于`控制反转`。
  * `Promise`有什么静态方法？
    * `resolve`
    * `reject`
    * `race`
    * `any`
    * `all`
    * `allSettled`
  * 手写`Promise A+`
    * 首先需要定义`status`
    * 在就维护两个队列：`onFulfilledCallbacks`和`onRejectedCallbacks`
    * 实现`then`方法，首先转化传入的参数，在就是创建`Promise`实例并返回
      * 在创建`Promise`实例的时候，传入的函数中需要判断当前`Promise`的状态，看是将`fulfilledMicrotask`和`rejectedMicrotask`放入对应的队列还是直接执行
      * 在`fulfilledMicrotask`和`rejectedMicrotask`中需要使用`queueMicrotask`函数产生微任务，并且调用`resolvePromise`函数解决嵌套`Promise`的问题
    * 还需要实现`resolve`和`reject`方法，传入`executor`中执行，这两个方法都是改变`Promise`的`status`，并执行对应的队列
    * 最后实现两个静态方法：`static resolve`和`static reject`，
    ```js
    const PENDING = 'pending'
    const FULFILLED = 'fulfilled'
    const REJECTED = 'rejected'

    class MyPromise {
      status = PENDING
      value = null
      reason = null
      onFulfilledCallbacks = []
      onRejectedCallbacks = []
      constructor(executor) {
        try{
          executor(this.resolve,this.reject)
        }catch(error){
          this.reject(error)
        }
      }
      resolve = (value)=> {
        if(this.status === PENDING) {
          this.status = FULFILLED
          this.value = value
          // 执行缓存的回调函数
          while(this.onFulfilledCallbacks.length) {
            this.onFulfilledCallbacks.shift()(value)
          }
        }
      }
      reject = (reason)=>{
        if(this.status === PENDING) {
          this.status = REJECTED
          this.reason = reason
          // 执行缓存的回调函数
          while(this.onRejectedCallbacks.length) {
            this.onRejectedCallbacks.shift()(reason)
          }
        }
      }
      then(onFulfilled, onRejected){
        const realOnFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value
        const realOnRejected = typeof onRejected === 'function' ? onRejected : reason => {throw reason}
        const next = new MyPromise((resolve, reject)=>{
          const fulfilledMicrotask = () => {
            queueMicrotask(()=>{
              // then 执行的时错误捕获
              try {
                const value = realOnFulfilled(this.value)
                resolvePromise(next, value, resolve, reject)
              } catch (error) {
                reject(error)
              }
            })
          }
          const rejectedMicrotask = () => {
            queueMicrotask(() => {
              try {
                // 调用失败回调，并且把原因返回
                const reason = realOnRejected(this.reason)
                // 传入 resolvePromise 集中处理
                resolvePromise(next, reason, resolve, reject)
              } catch (error) {
                reject(error)
              }
            })
          }
          if(this.status === FULFILLED) {
            fulfilledMicrotask()
          }else if(this.status === REJECTED) {
            rejectedMicrotask()
          }else if (this.status === PENDING) {
            // PENDING状态时缓存
            this.onFulfilledCallbacks.push(fulfilledMicrotask)
            this.onRejectedCallbacks.push(rejectedMicrotask)
          }
        })
        return next
      }
      // resolve 静态方法
      static resolve(parameter) {
        // 如果传入 MyPromise 就直接返回
        if (parameter instanceof MyPromise) {
          return parameter;
        }
        // 转成常规方式
        return new MyPromise(resolve =>  {
          resolve(parameter);
        });
      }
      // reject 静态方法
      static reject (reason) {
        return new MyPromise((resolve, reject) => {
          reject(reason);
        });
      }
    }
    function resolvePromise(promise, x, resolve, reject) {
      // 解决循环调用的问题
      if (promise === x) {
        return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))
      }
      if (typeof x === 'object' || typeof x === 'function') {
        // x 为 null 直接返回，走后面的逻辑会报错
        if (x === null) {
          return resolve(x);
        }

        let then;
        try {
          // 把 x.then 赋值给 then 
          then = x.then;
        } catch (error) {
          return reject(error);
        }

        // 如果 then 是函数
        if (typeof then === 'function') {
          let called = false;
          try {
            then.call(
              x, // this 指向 x
              // 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y)
              y => {
                // 如果 resolvePromise 和 rejectPromise 均被调用，
                // 或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用
                // 实现这条需要前面加一个变量 called
                if (called) return;
                called = true;
                resolvePromise(promise, y, resolve, reject);
              },
              // 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise
              r => {
                if (called) return;
                called = true;
                reject(r);
              });
          } catch (error) {
            // 如果 resolvePromise 或 rejectPromise 已经被调用，直接返回
            if (called) return;
            reject(error);
          }
        } else {
          // 如果 then 不是函数，以 x 为参数执行 promise
          resolve(x);
        }
      } else {
        // 如果 x 不为对象或者函数，以 x 为参数执行 promise
        resolve(x);
      }
    }
    ```
* new 运算符
  * [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)
### TS
* 泛型
  * 泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。
  * 设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：
    * 类的实例成员
    * 类的方法
    * 函数参数
    * 函数返回值
  * 这里衍生出泛型的应用：
    * 泛型类
    * 泛型方法
    * 泛型函数
* interface
  * 同名的interface会自动合并，同名的interface和class会自动聚合。
  * TypeScript 中 interface 可以给 Function / Array / Class（Indexable）做声明吗？
  ```ts
  /* 可以 */
  // 函数声明
  interface Say {
    (name: string): viod;
  }
  let say: Say = (name: string):viod => {}
  // Array 声明
  interface NumberArray { 
    [index: number]: number; 
  } 
  let fibonacci: NumberArray = [1, 1, 2, 3, 5];
  // Class 声明
  interface PersonalIntl {
    name: string
    sayHi (name: string): string
  }
  ```
  * type与interface的区别
    * 相同点：
      * 都可以描述 '对象' 或者 '函数' 
      * 都允许拓展(extends)
    不同点：
      * type 可以声明基本类型，联合类型，元组
      * type 可以使用 typeof 获取实例的类型进行赋值
      * 多个命名相同的 interface 声明可以自动合并
  使用 interface 描述‘数据结构’，使用 type 描述‘类型关系’
* Unicon Types(联合类型)
* Utility Types(工具类型)
  * `Partial<Type>`: 将传入的类型的属性全部设为可选
  * `Required<Type>`：将传入的类型的属性全部设为必传
  * `Readonly<Type>`：将传入的类型的属性全部设为只读
  * `Record<Keys, Type>`：构建一个对象类型，其键为Keys中声明的类型，其值为Type中声明的类型
  * `Pick<Type, Keys>`：从传入的Type中选择Keys对应的属性并组成新的类型
  * `Omit<Type, Keys>`：从传入的Type中剔除Keys对应的属性并组成新的类型
  * `Exclude<UnionType, ExcludedMembers>`：从联合类型UnionType中剔除ExcludedMembers组成新的类型
  * `Extract<Type, Union>`：提取Type和Union中的公共类型
  * `NonNullable<Type>`：从Type中剔除null和undefined的类型
  * `Parameters<Type>`：从函数类型Type中获取参数类型，并组成一个元组类型
  * `ConstructorParameters<Type>`：从构造函数类型Type中获取参数类型，并组成一个元组类型
  * `ReturnType<Type>`：获取函数类型Type的返回值类型
  * `InstanceType<Type>`：从构造函数类型Type中获取实例类型
  * `ThisParameterType<Type>`：获取函数类型Type的this参数的类型
  * `OmitThisParameter<Type>`：从函数类型Type中移除this参数，并生成新的类型
  * `ThisType<Type>`：此工具类型不返回转换后的类型。相反，它用作上下文这种类型的标记。
  * `Uppercase<StringType>`：全部大写传入的字符串类型
  * `Lowercase<StringType>`：全部小写传入的字符串类型
  * `Capitalize<StringType>`：转换首字母为大写
  * `Uncapitalize<StringType>`：转换首字母为小写
* Type Operator(类型操作符)
  * keyof：`索引类型查询操作符`，获取索引类型的属性名，构成联合类型。
  * typeof：获取一个变量或对象的类型。
* [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)(条件类型)
  * 使用extends进行判断
  * 可以在泛型中判断T的类型
  * 当与any判断，并且判断类型传入并集时，就变成一个分布式条件类型
* [Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)(映射类型)
  * 基于一个类型去创建另一个类型
  * 可以使用-/+ 增加属性的修饰符，例如?、readonly
  * 使用as对属性名重命名，结合字符串模板类型，可以支持更自由的命名规则
  ```ts
  type Getters<Type> = {
    [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]
  };
  interface Person {
    name: string;
    age: number;
    location: string;
  }
  type LazyPerson = Getters<Person>;
  // type LazyPerson = {
  //   getName: () => string;
  //   getAge: () => number;
  //   getLocation: () => string;
  // }
  ```
* Template Literal Types
  * `模板文本类型`建立在`字符串文本类型`的基础上，并能够通过联合扩展为许多字符串。
  ```ts
  type World = "world";
  type Greeting = `hello ${World}`; // type Greeting = "hello world"

  type EmailLocaleIDs = "welcome_email" | "email_heading";
  type FooterLocaleIDs = "footer_title" | "footer_sendoff";
  type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`; // type AllLocaleIDs = "welcome_email_id" | "email_heading_id" | "footer_title_id" | "footer_sendoff_id"
  ```
* 协变、逆变、双向协变以及不变性
  * `JavaScript`中的复杂数据类型`Object`是一种`结构化类型`。哪怕使用了`ES6`的`class`语法糖，创建的类型本质上还是`Object`，因此`TypeScript`使用的也是一种`结构化`的`类型检查系统`。
  * 因此在TypeScript中，判断两个类型是否兼容，只需要判断他们的“`结构`”是否一致，也就是说`结构属性名`和`类型`是否一致。而不需要关心他们的“`名字`”是否相同。
  * 而`协变`和`逆变`就是`子类型`上的两个比较容易混淆的概念。
  * `协变` (Covariant)：指允许`子类型`转换为`父类型`
  * `逆变` (Contravariant)：指允许`父类型`转换为`子类型`，多发生在`函数类型`中
  * `双向协变` (Bivariant)：指允许`子类型`转换为`父类型`，也允许`父类型`转换为`子类型`，老版本(2.6之前)中，`TypeScript`的函数参数是`双向协变`的，但这样并不安全
  * `不变` (Invariant)：指不同类型之前是无法相互转换的。
    * 举例：`List<Dog>` 能否为 `List<Animal>` 的子类型，其中 `Dog ≼ Animal`
    * 答案是如果列表是不可变列表，那么答案是肯定的，因为类型很安全。但是假如列表是可变的，那么答案绝对是否定的！
    * 总结一下，我们可以允许`不可变列表`在它的参数类型上是`协变`的，但是对于`可变列表`，其参数类型则必须是`不变`的，既不是协变也不是逆变。

## 网络协议
### TCP
* TCP/IP模型
![TCP/IP](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/v2-a0eeeef2d69e44e1434c01f341660a0f_r.38c312qzvdo0.webp)
* TCP协议
  * TCP的全称是`Transmission Control Protocol`，传输控制协议。它能够帮助你确定计算机连接到`Internet`以及它们之间的数据传输。
  * 通过`三次握手`来建立TCP连接，`三次握手`就是用来启动和确认TCP连接的过程。一旦连接建立后，就可以发送数据了，当数据传输完成后，会通过关闭虚拟电路来断开连接。
* TCP协议特点
  * TCP能够确`保连接的建立`和`数据包的发送`
  * TCP支持`错误重传机制`
  * TCP支持`拥塞控制`，能够在网络拥堵的情况下`延迟发送`
  * TCP能够提供`错误校验和`，甄别有害的数据包
* TCP三次握手
  * `SYN`：`同步序列编号`。是`TCP/IP`建立连接时使用的握手信号。在客户机和服务器之间建立`TCP`连接时，首先会发送的一个信号。客户端在接受到`SYN`消息时，就会在自己的段内生成一个随机值`X`。
  * `SYN-ACK`：服务器收到SYN后，打开客户端连接，发送一个`SYN-ACK`作为答复。确认号设置为比接收到的序列号多一个，即`X+1`，服务器为数据包选择的序列号是另一个随机数`Y`。
  * `ACK`：`确认字符`，表示发来的数据已确认接收无误。最后，客户端将`ACK`发送给服务器。序列号被设置为所接收的确认值即`Y+1`。
  ![三次握手](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/v2-96858222f549bb65b122e4ea9481983f_r.2lclc3qduog0.webp)
* TCP四次挥手
  * 首先，客户端应用程序决定要终止连接(这里服务端也可以选择断开连接)。这会使客户端将`FIN`发送到服务器，并进入`FIN_WAIT_1`状态。当客户端处于`FIN_WAIT_1`状态时，它会等待来自服务器的`ACK`响应。
  * 然后第二步，当服务器收到`FIN`消息时，服务器会立刻向客户端发送`ACK`确认消息。
  * 当客户端收到服务器发送的`ACK`响应后，客户端就进入`FIN_WAIT_2`状态，然后等待来自服务器的`FIN`消息
  * 服务器发送`ACK`确认消息后，一段时间（可以进行关闭后）会发送`FIN`消息给客户端，告知客户端可以进行关闭。
  * 当客户端收到从服务端发送的`FIN`消息时，客户端就会由`FIN_WAIT_2`状态变为`TIME_WAIT`状态。处于`TIME_WAIT`状态的客户端允许重新发送`ACK`到服务器为了防止信息丢失。客户端在`TIME_WAIT`状态下花费的时间取决于它的实现，在等待一段时间后，连接关闭，客户端上所有的资源都被释放。
  ![四次挥手](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/v2-16f1d27692320d9f60ba43aa4108e8ca_r.7jezr6u3a140.webp)
### HTTP协议
* `HTTP`是一种`超文本传输协议`(Hypertext Transfer Protocol)，基于`TCP`协议，是`无状态协议`
* 常见方法
  * `GET`：GET方法一般用于请求，比如你在浏览器地址栏输入的链接其实就是发送了一个GET请求
  * `POST`
  * `PUT`
  * `DELETE`
  * `OPTIONS`
* 常见状态码
  * 200：`OK`，请求成功。一般用于GET与POST请求
  * 301：`Moved Permanently`，永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
  * 302：`Found`，临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
  * 304：`Not Modified`，未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
  * 307：`Temporary` Redirect，临时重定向。与302类似。使用GET请求重定向
  * 308：`Permanent Redirect`，永久重定向。说明请求的资源已经被永久的移动到了由`Location`首部指定的`URL`上。浏览器会进行重定向，同时搜索引擎也会更新其链接
  * 400：`Bad Request`，客户端请求的语法错误，服务器无法理解
  * 401：`Unauthorized`，请求要求用户的身份认证
  * 404：`Not Found`，服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
  * 406：`Not Acceptable`，服务器无法根据客户端请求的内容特性完成请求
  * 500：`Internal Server Error`，服务器内部错误，无法完成请求
  * 502：`Bad Gateway`，作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
  * 504：`Gateway Time-out`，充当网关或代理的服务器，未及时从远端服务器获取请求
* HTTP/1.1
  * 默认使用`长连接`，`长连接`就是只需一次建立就可以传输多次数据，传输完成后，只需要一次切断连接即可。`长连接`的连接时长可以通过请求头中的`Connection: keep-alive`来设置
  * 中新增加了`E-tag`，`If-Unmodified-Since`, `If-Match`, `If-None-Match` 等`缓存控制标头`来控制缓存失效。
  * 支持`断点续传`，通过使用请求头中的`Range`来实现。
* HTTP/2
  * `头部压缩`：`HTTP/2`使用`HPACK`算法进行压缩。
  * `二进制分帧`：`HTTP/2`使用了更加靠近`TCP/IP`的二进制格式，而抛弃了ASCII码，提升了解析效率
  * `多路复用`：即每一个请求都是是用作连接共享。一个请求对应一个id，这样一个连接上可以有多个请求。
  * `强化安全`：由于安全已经成为重中之重，所以`HTTP/2`一般都跑在`HTTPS`上。
* HTTP/3
  * QUIC 协议：主要为了解决`HTTP/2`中存在的`队头阻塞`问题。由于`HTTP/2`在单个TCP连接上使用了`多路复用`，受到`TCP拥塞控制`的影响，少量的丢包就可能导致整个`TCP`连接上的所有流被阻塞。
* HTTPS
  * `HTTPS`的握手过程，其实就是`SSL/TLS`的握手过程。
  * `TLS`握手是启动和使用`TLS加密`的通信会话的过程。在`TLS握手`期间，`Internet`中的通信双方会彼此`交换信息`，`验证密码套件`，`交换会话密钥`。
  * 每当用户通过`HTTPS`导航到具体的网站并发送请求时，就会进行`TLS握手`。除此之外，每当其他任何通信使用`HTTPS`（包括API调用和在`HTTPS`上查询`DNS`）时，也会发生TLS握手。
  * `TLS`通讯流程：
    * 在进行通信前，首先会进行`HTTP`的`三次握手`，握手完成后，再进行TLS的握手过程
    * `ClientHello`：客户端通过向服务器发送`hello`消息来发起握手过程。这个消息中会夹带着客户端支持的`TLS版本号`(TLS1.0 、TLS1.2、TLS1.3)、客户端支持的`密码套件`、以及一串`客户端随机数`。
    * `ServerHello`：在客户端发送`hello`消息后，服务器会发送一条消息，这条消息包含了服务器的`SSL证书`、服务器选择的`密码套件`和服务器生成的`随机数`。
    * `认证(Authentication)`：客户端的证书颁发机构会`认证SSL证书`，然后发送`Certificate`报文，报文中包含`公开密钥`证书。最后服务器发送`ServerHelloDone`作为hello请求的响应。第一部分握手阶段结束。
    * `加密阶段`：在第一个阶段握手完成后，客户端会发送`ClientKeyExchange`作为响应，这个响应中包含了一种称为`The premaster secret`的密钥字符串，这个字符串就是使用上面`公开密钥证书`进行加密的字符串。随后客户端会发送`ChangeCipherSpec`，告诉服务端使用`私钥解密`这个`The premaster secret`的字符串，然后客户端发送`Finished`告诉服务端自己发送完成了。
    * 实现了安全的`非对称加密`：然后，服务器再发送`ChangeCipherSpec`和`Finished`告诉客户端解密完成，至此实现了`RSA的非对称加密`。
    ![TLS通讯流程](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/v2-18f480a3c81a3313c8c312772884eece_r.34ageujsauc0.webp)
  ![HTTPS](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/v2-2295aa8205ce9d03782cf88e8548ec5e_r.56dncwmk16o0.webp)
* HTTP缓存策略
  * 强制缓存
    * 通过确定一定时间范围内不用请求资源，直接访问缓存即可
    * 通过`Expires`和`Cache-Control`两个头部确定
      * `Expires`的值是一个时间，表示在这个时间之前再次访问该资源不用重新发送请求，直接访问缓存即可
      * `Cache-Control`返回`max-age=xxxx`，单位是秒，表示在这段时间内不需要重新发送请求，直接访问缓存即可
      * `Cache-Control`的其他常用属性还有：
        * `no-cache`：使用缓存前，强制要求把请求提交给服务器进行验证(协商缓存验证)。
        * `no-store`：不存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。
      * `Cache-Control`的优先级高于`Expire`
  * 协商缓存
    * 协商缓存要发请求去问服务器有没有更新
    * `ETag` & `If-None-Match`(优先级高)
      * `ETag`是`URL`的`Entity Tag`，就是一个`URL资源`的`标识符`，类似于文件的md5
      * 服务端的`Response Header`会携带`ETag`头部，客户端收到后存储
      * 当客户端请求相同资源时，会携带`If-None-Match`头部，值为之前`ETag`下发的值
      * 服务端接收后，查询`ETag`没有改变，则会返回`304(Not Modified)`，告诉客户端直接使用缓存，否则会返回`200`和`新资源`
    * `Last-Modified` & `If-Modified-Since`(优先级低)
      * `Last-Modified`放的是资源的最后修改时间
      * 服务端的`Response Header`会携带`Last-Modified`头部，客户端收到后存储
      * 当客户端请求相同资源时，会携带`If-Modified-Since`头部，值为之前`Last-Modified`下发的值
      * 服务端拿到这个头后，会跟当前版本的修改时间进行比较:
        * 当前版本的修改时间比这个晚，也就是这个时间后又改过了，返回200和新的内容
        * 当前版本的修改时间和这个一样，也就是没有更新，返回304，不返回内容，只返回头，客户端直接使用缓存
  * `强制缓存`的优先级高于`协商缓存`
  * 如果什么缓存策略都没有设置，那么浏览器会采用一个启发式的算法，通常会读取`Response Header`中的`Date`头，减去`Last-Modified`值的`10%`作为缓存时间。
### DNS协议
* 与`HTTP`、`FTP`和`SMT`P一样，`DNS`协议也是`应用层`的协议，`DNS`使用`客户-服务器模式`运行在通信的端系统之间，在通信的端系统之间通过下面的端到端运输协议来传送`DNS`报文。
* `DNS`通常不是一门独立的协议，它通常为其他应用层协议所使用，这些协议包括`HTTP`、`SMTP`和`FTP`，将用户提供的主机名解析为`IP地址`。
* DNS层次结构
  * `根域名服务器`：`根域名服务器`提供`TLD服务器`的`IP地址`
  * `顶级域名服务器(TLD)`：顶级域`DNS`服务器，对于每个顶级域名比如`com`、`org`、`net`、`edu`和`gov`和所有的国家级域名`uk`、`fr`、`ca`和`jp`都有`TLD服务器`或服务器集群。`TLD服务器`提供了`权威DNS服务器`的`IP地址`。
  * `权威DNS服务器`：在因特网上具有公共可访问的主机，如Web服务器和邮件服务器，这些主机的组织机构必须提供可供访问的DNS记录，这些记录将这些主机的名字映射为`IP地址`。
* DNS缓存
  * `DNS缓存`(DNS caching)有时也叫做`DNS解析器缓存`，它是由操作系统维护的临时数据库，它包含有最近的网站和其他`Internet域`的访问记录。
  * `浏览器缓存`：发出对DNS记录的请求时，浏览器缓存是针对所请求的记录而检查的第一个位置。
  * `操作系统内核缓存`：在浏览器缓存查询后，会进行操作系统级DNS解析器的查询，操作系统级DNS解析器是DNS查询离开你的计算机前的第二站，也是本地查询的最后一个步骤。
* DNS查询过程
  * 用户在浏览器中输入网址`www.example.com`并点击回车后，查询会进入网络，并且由`DNS解析器`进行接收。
  * `DNS解析器`会首先去`浏览器DNS缓存`查找DNS记录。
  * 若无命中浏览器的DNS缓存，则会去`操作系统内核DNS缓存`，查找DNS记录。
  * `DNS解析`器会向根域名发起查询请求，要求返回顶级域名的`IP地址`。
  * 根DNS服务器会注意到请求地址的前缀并向`DNS解析器`返回com的`顶级域名服务器(TLD)`的`IP地址`列表。
  * 然后，`DNS解析器`会向`顶级域名服务器(TLD)`发送查询报文
  * `顶级域名服务器(TLD)`接收请求后，会根据域名的地址把`权威DNS服务器`的`IP地址`返回给DNS解析器。
  * 最后，`DNS解析器`将查询直接发送到`权威DNS服务器`
  * `权威DNS服务器`将`IP地址`返回给`DNS解析器`
  * `DNS解析器`将会使用`IP地址`响应Web浏览器
### CDN
* CDN (全称 Content Delivery Network)，即内容分发网络。
* 构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的`边缘服务器`，通过中心平台的`负载均衡`、`内容分发`、`调度`等功能模块，使用户`就近`获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。`CDN`的关键技术主要有`内容存储`和`分发技术`。
* 在没有应用CDN时，我们使用域名访问某一个站点时的路径为
> 用户提交域名 → 浏览器对域名进行解释 → `DNS`解析得到目的主机的IP地址 → 根据IP地址访问发出请求 → 得到请求数据并回复
* 应用`CDN`后，`DNS`返回的不再是`IP`地址，而是一个`CNAME`(Canonical Name)别名记录，指向`CDN`的全局负载均衡。`CNAME`实际上在域名解析的过程中承担了`中间人`（或者说代理）的角色，这是CDN实现的关键。
* **负载均衡系统**
  * 由于没有返回IP地址，于是本地DNS会向负载均衡系统再发送请求 ，则进入到`CDN`的全局负载均衡系统进行智能调度：
    * 看用户的 IP 地址，查表得知`地理位置`，找相对最近的边缘节点
    * 看用户所在的`运营商`网络，找相同网络的边缘节点
    * 检查边缘节点的`负载情况`，找负载较轻的节点
    * 其他，比如节点的`健康状况`、`服务能力`、`带宽`、`响应时间`等
  * 结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问CDN的缓存代理
  ![](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/588d7890-b86b-11eb-85f6-6fac77c0c9b3.5v92wcq1tqs0.webp)
* **缓存代理**
  * 两个衡量`CDN`服务质量的指标：
    * `命中率`：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比
    * `回源率`：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比
  * 缓存系统也可以划分出层次，分成`一级缓存节点`和`二级缓存节点`。一级缓存配置高一些，直连源站，二级缓存配置低一些，直连用户
  * 回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，可以有效地减少真正的回源。

## 浏览器
### 常见概念
* 重绘和回流(重排)
  * 回流(重排)
    * `回流`又名`重排`，指`几何属性`需改变的渲染。
    * `渲染树`的节点发生改变，影响了该节点的`几何属性`，导致该节点位置发生变化，此时就会触发浏览器`回流`并重新生成`渲染树`。
    * `回流`意味着节点的`几何属性`改变，需重新计算并生成`渲染树`，导致`渲染树`的全部或部分发生变化。
  * 重绘
    * `重绘`指更改`外观属性`而不影响`几何属性`的渲染。
    * `渲染树`的节点发生改变，但不影响该节点的`几何属性`。由此可见，`回流`对浏览器性能的消耗是高于`重绘`的，而且`回流`一定会伴随`重绘`，`重绘`却不一定伴随`回流`。
  * 如何减少回流和重绘
    * 使用`visibility:hidden`替换`display:none`
    * 使用`transform`代替`top`
    * 避免使用`Table`布局
    * 避免规则`层级过多`
    * 避免节点属性值放在循环里当成循环变量
    * 动态改变类而不改变样式
* 同源策略
  * `同源策略`是一个重要的`安全策略`，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。
  * 如果两个`URL`的`protocol`、`port`和`host`都相同的话，则这两个`URL`是同源。
  * `同源策略`限制的内容有：
    * `Cookie`、`LocalStorage`、`IndexedDB`等存储性内容
    * `DOM节点`
    * `AJAX`请求发送后，结果被浏览器拦截了
  * 但是有三个标签是允许跨域加载资源：
    * `<img src=XXX>`
    * `<link href=XXX>`
    * `<script src=XXX>`
  * 如何解决跨域
    * `JSONP`
    * `CORS`, 通过设置`Access-Control-Allow-Origin`请求头
      *  根据请求方法和携带参数的不同又分为`简单请求`和`非简单请求`，`非简单请求`需要发出`OPTIONS预请求`
    * `document.domain`，只适用于`二级域名`相同的情况下
    * `window.name`，即在一个窗口的生命周期内，窗口载入的所有的页面都是共享一个`window.name`
    * `postMessage`
    ```html
    // a.html
    <iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()">
    <!-- 等它加载完触发一个事件 -->
    </iframe> 
    <!-- 内嵌在http://localhost:3000/a.html -->
    <script>
      function load() {
        let frame = document.getElementById('frame')
        frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据
        window.onmessage = function(e) { //接受返回数据
          console.log(e.data) //我不爱你
        }
      }
    </script>
    <!-- http://localhost:4000/b.html -->
    <script>
      window.onmessage = function(e) {
        console.log(e.data) //我爱你
        e.source.postMessage('我不爱你', e.origin)
    }
    </script>
    ```
### 渲染流程
* 由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多`子阶段`，输入的`HTML`经过这些`子阶段`，最后输出`像素`。我们把这样的一个处理流程叫做`渲染流水线`。
* 渲染流水线
  * 构建`DOM树`：解析`HTML`，转换为浏览器能够理解的`DOM结构`
  * 样式计算：计算出`DOM节点`中每个元素的具体样式
    * 把`CSS`转换为浏览器能够理解的结构CSSOM
    * 转换样式表中的属性值，使其标准化
    * 计算出`DOM树`中每个节点的具体样式
  * 布局阶段：计算出`DOM树`中`可见元素`的几何位置
    * 创建布局树
      * 遍历`DOM树`中的所有`可见节点`，并把这些节点加到布局中
      * 不可见的节点会被布局树忽略掉
    * 布局计算：计算布局树节点的`坐标位置`
  * 分层：因为页面中有很多复杂的效果，如一些复杂的`3D变换`、`页面滚动`，或者使用`z-index`做`z轴排序`等。渲染引擎还需要为特定的节点生成专用的`图层`，并生成一棵对应的`图层树`
    * 拥有`层叠上下文属性`的元素会被提升为单独的`图层`
    * 需要`剪裁`的地方也会被创建为`图层`
  * 图层绘制
    * 绘制列表：渲染引擎实现`图层`的绘制会分步操作，会把一个`图层`的绘制拆分成很多小的`绘制指令`，然后再把这些指令按照顺序组成一个`待绘制列表`
  * `栅格化`操作：绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的`合成线程`来完成的
    * `栅格化`是指任何将`向量图形`转换成`位图`的过程
    * `合成线程`会将`图层`分成`图块`渲染
    * 然后`合成线程`会按照`视口`附近的`图块`来优先生成`位图`，实际生成`位图`的操作是由`栅格化`来执行的
  * 合成与显示
    * 一旦所有图块都被`栅格化`，`合成线程`就会生成一个绘制图块的命令`DrawQuad`，然后将该命令提交给浏览器进程
    * `合成线程`将其页面内容绘制到`内存`中，最后再将`内存`显示在屏幕上
  ![渲染流水线](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/gpu-raster.7bzkc74k24s0.webp)
### V8
* 编译流水线
  * 运行时环境：堆空间和栈空间、全局执行上下文、全局作用域、内置的内建函数、宿主环境提供的扩展函数和对象，还有消息循环系统。
    * 堆空间和栈空间
      * 栈空间主要是用来管理`JavaScript函数调用`的，在函数调用过程中，涉及到`上下文相关的内容`都会存放在栈上。
      * 每个栈帧对应着一个未运行完的函数，栈帧中保存了该函数的返回地址和局部变量。
      * 堆空间是一种树形的存储结构，用来存储对象类型的离散的数据。
      * `JavaScript`中除了原生类型的数据，其他的都是对象类型，诸如`函数`、`数组`，在浏览器中还有`window对象`、`document对象`等，这些都是存在堆空间的。
    * 全局执行上下文
      * `执行上下文`中主要包含三部分，`变量环境`、`词法环境`和 `this` 关键字。
      * `全局执行上下文`在 V8 的生存周期内是不会被销毁的，它会一直保存在堆中。
    * 全局作用域
      * `作用域`是指程序源代码中`定义变量`的区域。作用域规定了`如何查找变量`，也就是确定当前执行代码对变量的访问权限。
      * JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。
      * 同一个全局执行上下文中，都能存在多个作用域。
  * `惰性解析`与闭包
    * 所谓`惰性解析`是指解析器在解析的过程中，如果遇到`函数声明`，那么会`跳过`函数内部的代码，并不会为其生成`AST`和`字节码`，而仅仅生成顶层代码的`AST`和`字节码`。
    * 但是当遇到`闭包问题`所导致的引用`外部执行上下文中的变量`的情况时，就会导致如何保存外部执行上下文的问题，而`预解析器`就是解决这问题的。
      * `预解析器`可以判断当前函数是不是存在一些语法上的错误
      * `预解析器`另外的一个重要的功能就是检查函数内部是否引用了`外部变量`，如果引用了外部的变量，`预解析器`会将栈中的变量`复制到堆中`，在下次执行到该函数的时候，直接使用`堆中的引用`，这样就解决了闭包所带来的问题。
  * V8执行JS过程
    * `字节码`：`解释器（Ignition）`根据`AST`来生成`字节码`（也称中间码）。
      * `字节码`降低了内存占用，主要还是直接编译成二进制机器代码会占用过多内存。
      * `字节码`提升代码启动速度，生成机器代码比生成`字节码`需要花费更久的时间。
      * `字节码`可以降低代码的复杂度。
    * `优化编译器`：当存在热代码的时候，V8 会借着`TurboFan`将为`热代码`的`字节码`转为`机器码`并缓存下来。
      * 当热代码经过修改，则`TurboFan`会将`热代码`退回到`AST`这一步，这个时候解释器会重新解释执行被修改的代码。
    * 流程图片
      ![](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/upload_2df821c7eb5ae566121a391292f48a42.5obkm9fjrf40.webp)
    * [v8 执行 js 的过程](https://www.zoo.team/article/the-process-of-executing-js-in-v8)
* 垃圾回收
  * 目前`V8`采用了两个垃圾回收器，主垃圾回收器 - `Major GC`和副垃圾回收器 - `Minor GC`(Scavenger)。`V8`之所以使用了两个垃圾回收器，主要是受到了`代际假说`（The Generational Hypothesis）的影响。
  * 在`V8`中，会把堆分为`新生代`和`老生代`两个区域，`新生代`中存放的是生存时间短的对象，`老生代`中存放生存时间久的对象。
  * 副垃圾回收器 - `Minor GC`(Scavenger)，主要负责`新生代`的垃圾回收；主垃圾回收器 - `Major GC`，主要负责`老生代`的垃圾回收。
  * 副垃圾回收器 - `Minor GC`
    * 新生代中的垃圾数据用`Scavenge`算法来处理。所谓`Scavenge`算法，是把新生代空间对半划分为两个区域，一半是`对象区域` (from-space)，一半是`空闲区域` (to-space)。
      * 在垃圾回收过程中，首先要对对象区域中的垃圾做`标记`；标记完成之后，就进入`垃圾清理阶段`。
      * 副垃圾回收器会把这些存活的对象`复制`到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了`内存整理`操作，复制后空闲区域就没有内存碎片了。
      * 完成复制后，对象区域与空闲区域进行角色翻转。
    * 为了执行效率，一般新生区的空间会被设置得比较小。
    * 副垃圾回收器还会采用`对象晋升策略`，也就是移动那些经过两次垃圾回收依然还存活的对象到`老生代`中。
  * 主垃圾回收器 - `Major GC`
    * 主垃圾回收器是采用`标记 - 清除`（Mark-Sweep）的算法进行垃圾回收的。
      * `标记阶段`就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。
      * 接下来就是垃圾的`清除过程`。主垃圾回收器会直接将标记为`垃圾的数据清理掉`。
    * 对一块内存多次执行`标记 - 清除`算法后，会产生大量不连续的`内存碎片`，这时又引入了`标记 - 整理`（Mark-Compact）算法用于内存整理。
      * 先标记可回收对象，让所有存活的对象都向一端移动。
      * 然后直接清理掉这一端之外的内存。
* 其他优化
  * 快属性与慢属性
    * `V8`实现对象存储时，并没有完全采用`字典`的存储方式，这是因为`字典`是`非线性`的数据结构，查询效率会`低于线性`的数据结构。
    * 在`ECMAScript`规范中定义了`数字属性`应该按照索引值`大小升序排列`，`字符串属性`根据创建时的`顺序升序排列`。
    * 把对象中的`数字属性`称为`排序属性`，在`V8`中被称为`elements`，`字符串属性`就被称为`常规属性`，在`V8`中被称为`properties`。
    * 在`V8`内部，为了有效地提升存储和访问这两种属性的性能，分别使用了两个`线性数据结构`来分别保存`排序属性`和`常规属性`。
    * 将不同的属性分别保存到`elements属性`和`properties属性`中，无疑简化了程序的复杂度，但是在查找元素时，却多了一步查找操作。
    * `V8`采取了一个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性`直接存储`到对象本身，我们把这称为`对象内属性` (in-object properties)。不过对象内属性的数量是`固定`的，默认是`10`个。
    * 我们将保存在`线性数据结构`中的属性称之为`“快属性”`。如果一个对象的`属性过多`时，`V8`就会采取另外一种存储策略，那就是`“慢属性”`策略，但`慢属性`的对象内部会有独立的`非线性数据结构` (词典) 作为`属性存储容器`。
  * 隐藏类
    * `V8`在运行`JavaScript`的过程中，会假设`JavaScript`中的对象是`静态`的，具体地讲，`V8`对每个对象做如下两点假设：
      * 对象创建好了之后就`不会添加`新的属性。
      * 对象创建好了之后也`不会删除`属性。
    * 符合这两个假设之后，`V8`会为每个对象创建一个`隐藏类`，对象的`隐藏类`中记录了该对象一些基础的`布局信息`，包括以下两点：
      * 对象中所包含的`所有的属性`。
      * 每个属性相对于对象的`偏移量`。
      * 在`V8`中，把`隐藏类`又称为`map`，每个对象都有一个`map`属性，其值指向内存中的`隐藏类`。
    * 有了`map`之后，当你再次访问`对象属性`时，`V8`会查询对象的`map`中属性相对对象起始地址的`偏移量`，然后将对象起始地址加上`偏移量`，就得到了所查找的属性的值在内存中的位置。
## 框架
### Vue
### React

## 工程化
### 编译工具
*Babel [参考](https://juejin.cn/post/7025237833543581732)
  * babel-loader
    * `babel-loader`的本质就是一个函数，我们匹配到对应的`jsx?/tsx?`的文件交给`babel-loader`
  * @babel/core
    * `@babel/core`是`Babel`最核心的一个`编译库`，他可以将我们的代码进行**词法分析--语法分析--语义分析**过程从而生成`AST抽象语法树`，从而对于“这棵树”的操作之后再通过`编译`称为新代码。
    * `@babel/core`通过`transform`方法将我们的代码进行编译。
  * @babel/preset-env
    * `@babel/preset-env`的主要作用就是告诉`Babel`我需要以为什么样的规则进行`代码转换`。
  * polyfill
    * `@babel/polyfill`
      * 配合`@babel/preset-env`
        * `useBuiltIns: "false"`，`Babel`根据我们配置的浏览器兼容性列表(`browserList`)，仅仅会转化ES语法，并不会转化任何API和方法。
        * `useBuiltIns: "entry"`，`Babel`根据我们配置的浏览器兼容性列表(`browserList`)然后**全量**引入不兼容的`polyfills`。
        * `useBuiltIns: "usage"`，`Babel`会根据配置的浏览器兼容性列表(`browserList`)，以及代码中`使用到的API`进行引入`polyfills`**按需加载**。
        * 在我们使用`useBuiltIns:entry/usage`时，需要额外指定`core-js`这个参数。
      * `@babel/polyfill`这种方式可能会存在污染全局作用域。
    * `babel/runtime`更像是一种`按需加载`的解决方案，会将引入方式由智能完全交由我们自己，我们需要什么自己引入什么。
      * `babel-runtime`无法做到智能化分析，需要我们`手动引入`。
      * `babel-runtime`编译过程中会重复`生成冗余代码`。
      * 配合`@babel/plugin-transform-runtime`
        *通过分析我们的项目中所使用到`需要转译的js代码`，从而实现模块化从`babel-runtime`中引入所需的`polyfills`实现。
    * [关于@babel/preset-env与@babel/runtime最佳实践参考](https://www.jmarkoski.com/understanding-babel-preset-env-and-transform-runtime)
  * 插件实现
    * 常用类库
      * `@babel/core`：上边我们说过`@babel/core`是`Babel`的核心库，核心的`API`都在这里。比如上边我们讲到的`transform`，`parse`方法。
      * `@babel/parser`：`Babel`解析器。
      * `@babel/types`：这个模块包含手动构建`AST`和检查`AST`节点类型的方法(比如通过对应的`API`生成对应的节点)。
      * `@babel/traverse`：这个模块用于对`AST`的遍历，它维护了整棵树的状态(需要注意的是`traverse`对于`AST`是一种深度遍历)。
      * `@babel/generator`：这个模块用于代码的生成，通过`AST`生成新的代码返回。
    * 工作流程
      * `Parse`（解析）阶段：这个阶段将我们的`js代码`(字符串)进行词法分析生成一系列`tokens`，之后再进行`语法分析`将`tokens`组合称为一颗`AST抽象语法树`。(比如`@babel/parser`它的作用就是这一步)
      * `Transform`（转化）阶段：这个阶段`Babel`通过对于这棵树的遍历，从而对于`旧AST`进行增删改查，将新的`js语法节点`转化称为浏览器兼容的语法节点。(`@babel/traverse`就是在这一步进行遍历这棵树)
      * `Generator`（生成）阶段：这个阶段`Babel`会将`新AST`转化同样进行深度遍历从而生成新的代码。(`@babel/generator`)
* esbuild
* swc
### 打包工具
* Webpack
  * 构建流程
    * `初始化流程`：从配置文件和Shell语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数
    * `编译构建流程`：从`Entry`发出，针对每个`Module`串行调用对应的`Loader`去`翻译`文件内容，再找到该`Module`依赖的`Module`，`递归`地进行编译处理
    * `输出流程`：对`编译`后的`Module`组合成`Chunk`，把`Chunk`转换成文件，输出到文件系统
  * loader
    * 默认情况下，在遇到`import`或者`require`加载模块的时候，`Webpack`只支持对`js`和`json`文件打包。
    * `loader`本质上就是一个`函数`，接受我们的源代码作为入参同时返回处理后的结果。
    * 配置loader有三种方式：
      * 配置方式（推荐）：在`webpack.config.js`文件中指定`loader`
      * 内联方式：在每个`import`语句中显式指定`loader`
        > import Styles from 'style-loader!css-loader?modules!./styles.css'
      * CLI 方式：在`shell`命令中指定它们
    * 特性
      * `loader`支持`链式调用`，链中的每个`loader`会处理之前已处理过的资源，最终变为js代码。顺序为`相反顺序`执行。
      * `loader`可以是`同步`的，也可以是`异步`的
      * `loader`运行在`Node.js`中，并且能够执行任何操作
      * `loader`能够产生额外的任意文件
    * 常见loader
      * `style-loader`: 将`css`添加到DOM的内联样式标签`style`里。
      * `css-loader` :允许将`css`文件通过`require`的方式引入，并返回`css`代码。
      * css预处理loader：`stylus-loader`/`less-loader`/`sass-loader`，均为css预处理器解析的`loader`版本。
      * `postcss-loader`: 用`postcss`来处理`CSS`。
      * `file-loader`: 分发文件到`output`目录并返回相对路径。
      * `url-loader`: 和`file-loader`类似，但是当文件小于设定的limit时可以返回`base64`。
      * `babel-loader`：用`Babel`来转换`JS`。
      * `svg-sprite-loader`：将会把依赖的svg塞到一个个symbol中，合成一个大的svg。symbol的id如果不特别指定，就是你的文件名。
      * `svgo-loader`：为`SVGO`的`loader`版本。`SVGO`是`svg`优化器，包含很多插件。
      * `vue-loader`：编译`vue单文件组件`到`render`渲染函数。
  * plugin
    * `plugin`赋予其各种灵活的功能，例如`打包优化`、`资源管理`、`环境变量注入`等，它们会运行在`Webpack`的不同阶段（`钩子`/`生命周期`），贯穿了`Webpack`整个`编译周期`。
    * `plugin`其本质是一个具有`apply`方法`JavaScript`对象。`apply`方法会被`Webpack Compiler`调用，并且在整个编译生命周期都可以访问`Compiler`对象。
    * `plugin`通过`发布订阅`的模式，通过`compiler`上监听事件。然后再打包编译过程中触发监听的事件从而添加一定的逻辑影响打包结果。
    * 常用的编译生命周期钩子有：
      * `entry-option`：初始化`option`。
      * `run`：启动一次新的编译。
      * `compile`： 该事件是为了告诉插件一次新的编译将要启动，同时会给插件带上 `compiler` 对象。
      * `compilation`：当 `Webpack` 以开发模式运行时，每当检测到文件变化，一次新的 `Compilation` 将被创建。一个 `Compilation` 对象包含了当前的 `模块资源` 、 `编译生成资源` 、 `变化的文件` 等。 `Compilation` 对象也提供了很多事件回调供插件做扩展。 
      * `make`：一个新的 `Compilation` 创建完毕，即将从 `Entry` 开始读取文件，根据文件类型和配置的 `Loader` 对文件进行编译，编译完后再找出该文件依赖的文件，递归的编译和解析。
      * `after-compile`： 一次 `Compilation` 执行完成。
      * `seal`：所有模块及其依赖的模块都通过 `Loader` 转换完成后，根据依赖关系开始生成 `Chunk` 。
      * `emit`：确定好要输出哪些文件后，执行文件输出，可以在这里获取和修改输出内容。
      * `after-emit`：在将内存中`assets`内容写到磁盘文件夹之后。
      * `done`： 成功完成一次完成的编译和输出流程。
      * `failed`： 如果在编译和输出流程中遇到异常导致`Webpack`退出时，就会直接跳转到本步骤，插件可以在本事件中获取到具体的错误原因。
    * 常见plugin
      * `html-webpack-plugin`：在打包结束后，⾃动生成⼀个`HTML`⽂文件，并把打包生成的`js模块`引⼊到该`HTML`中，同时可以压缩`HTML`。
      * `clean-webpack-plugin`: 删除（清理）构建目录。
      * `mini-css-extract-plugin`：提取`CSS`到一个单独的文件中。
      * `css-minimizer-webpack-plugin`：利用`cssnano`优化并压缩`CSS`代码。
      * `terser-webpack-plugin`：利用`terser`压缩`js`代码。
      * `DefinePlugin`：允许在编译时创建配置的全局对象，是一个`Webpack`内置的插件。
* Rollup
  * `Rollup`是基于`ESM`的`JavaScript`打包工具。
  * `Rollup`的亮点在于同一个地方，一次性加载。能针对源码进行`Tree Shaking`(去除那些已被定义但没被使用的代码)，以及`Scope Hoisting`以减小输出文件大小提升运行性能。
  * 构建流程
    * 获取入口文件的内容，包装成`module`，生成抽象语法树
    * 对入口文件抽象语法树进行依赖解析
    * 生成最终代码
    * 写入目标文件
### bundleless
* Vite [参考文章](https://zhuanlan.zhihu.com/p/467325485)
  * 特点
    * `快速`的冷启动: `No Bundle` + `esbuild` 预构建
    * 即时的模块`热更新`: 基于`ESM`的`HMR`，同时利用`浏览器缓存策略`提升速度
    * 真正的`按需加载`: 利用浏览器`ESM`支持，实现真正的按需加载
  * 核心原理
    * 当声明一个`script`标签`type`类型为`module`时，当浏览器解析资源时，会往当前域名发起一个`GET`请求`js文件`。
    * 请求到了`js文件`，会检测到内部含有`import`引入的包，又会`import`引用发起`HTTP请求`获取模块的内容文件，如`Example1.vue`、`example2.ts`。
    * `Vite`启动一个`koa服务器`拦截这些请求，并在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再以`ESM格式`返回返回给浏览器。
    * `Vite`扩展了`Rollup`的`插件API`，这意味着`Vite`用户可以利用`Rollup插件`的强大生态系统，同时根据需要也能够扩展`开发服务器`和`SSR功能`。
    * 拦截时需要考虑几点：
      * 裸模块导入的处理
        * 原生`ES`导入不支持下面这样的裸模块导入，通过`依赖预构建`和`重新导入`方法
          > import { someMethod } from 'my-dep'
        * `依赖预构建`
          * `Vite`的开发服务器将所有代码视为`原生ES模块`。因此，`Vite`必须先将作为`CommonJS`或`UMD`发布的依赖项转换为`ESM`。
          * `Vite`将有许多内部模块的`ESM`依赖关系转换为单个模块，以提高后续页面加载性能。
        * `Vite`会将预构建的依赖缓存到`node_modules/.vite`。
        * 重写导入为合法的`URL`，例如`/node_modules/.vite/my-dep.js?v=f3sf2ebd`以便浏览器能够正确导入它们。
        * 解析后的`依赖请求`会以`HTTP`头`max-age=31536000,immutable`**强缓存**，以提高在开发时的页面`重载性能`。
      * Vue单文件的处理
        * `@vitejs/plugin-vue`：支持`Vue 3`单文件组件
        * `underfin/vite-plugin-vue2`：支持`Vue 2`单文件组件
      * JSX文件的处理
        * `JSX`的转译默认是通过`esbuild`
        * `@vitejs/plugin-vue-jsx`支持`Vue 3 JSX`
        * 自定义的`jsxFactory`和`jsxFragment`可以使用`esbuild选项`进行配置。
        ```js
          // vite.config.js
          import { defineConfig } from 'vite'

          export default defineConfig({
            esbuild: {
              jsxFactory: 'h',
              jsxFragment: 'Fragment'
            }
          })
        ```
      * `TypeScript`文件的处理
        * `Vite`仅执行`.ts`文件的`转译`工作，并**不**执行任何`类型检查`。`Vite`使用`esbuild`将`TypeScript`转译到`JavaScript`。
    * HMR原理
      * `Vite`整个热更新过程可以分成四步
        * 创建一个`WebSocket`服务端和`Client`文件，启动服务
        * 通过`chokidar`监听文件变更
        * 当代码变更后，服务端进行判断并推送到客户端
        * 客户端根据推送的`信息`执行不同操作的更新
* snowpack

## 性能优化
### 网络优化
* 使用CDN分发静态资源
* 使用HTTP 2.0
* 使用浏览器缓存
* 减少HTTP请求
### 体积优化
* JS代码压缩
* CSS代码压缩
* HTML文件代码压缩
* 文件大小压缩
* 图片压缩与优化
  * 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式
  * 小图使用 base64 格式
  * 将多个图标文件整合到一张图片中（雪碧图）
* 代码分离
* 字体图标代替图片
### 加载优化
* CSS写头部，JS写底部
* `script`标签增加`defer`属性
* 资源预加载：`<link ref="preload">`
* 资源预链接：`<link ref="preconnect">`
* DNS预解析：`<link ref="dns-prefetch">`
* 内联chunk
* 图片懒加载
* gzip：打包的时候就打成`gzip`包，不需要服务器再去做压缩
### 代码优化
* 用transform等新属性来实现动画
* 降低CSS选择器的复杂性
* 避免过多的回流与重绘
* 合理利用节流和防抖
* 使用事件委托
* 首屏加载优化：主要在`SPA`应用的`白屏优化`
  * `路由懒加载`
  * 异步组件：`defineAsyncComponent`
  * 使用`resolutions`统一依赖版本

## Node.js
### 基本概念及原理
### 常用模块
### Web 框架
* Koa
* egg.js
