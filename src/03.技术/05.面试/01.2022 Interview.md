---
title: 2022 Interview
date: 2022-02-28 11:58:10
permalink: /pages/33969f/
categories:
tags:
  - interview
---
## 大纲
![大纲](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/大纲.3ttblao9ahw0.webp)
## 基础
### HTML
* HTML5 语义化标签
  * 语义化标签： header，nav，main，article，section，aside，footer
  * 语义化意味着顾名思义，HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构，而不是滥用div。
  * 语义化的优点有:
    * 代码结构清晰，易于阅读，利于开发和维护
    * 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。
    * 有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重
* script标签中的 defer和async属性
  * 相同点：
    * 都是异步加载资源
  * 区别：
    * async属性是异步加载，加载完成后立即执行，标记为async的脚本不保证按照出现顺序执行
    * 标记为defer属性的脚本会等到HTML解析完成后再执行，执行顺序就是按照出现顺序
### CSS
* CSS 盒模型
  * box-sizing: border-box, content-box
  * 分为标准盒模型和IE盒模型，在标准盒子模型中，width 指 content 部分的宽度，在IE盒子模型中，width 表示 content+padding+border 这三个部分的宽度
  * box-sizing:content-box 表示标准盒子模型，box-sizing:border-box 表示的是IE盒子模型
* flex布局
  * 常用属性：
    * flex-direction: 主轴方向，默认值为row，column为垂直方向排列
    * justify-content：主轴方向排列方式，可选属性为：flex-start，flex-end，center，space-between，space-around
    * align-items：副轴方向排列方式，可选属性与justify-content相同
    * flex-wrap：换行规则，可选属性为：nowrap，wrap，wrap-reverse
    * flex-grow：定义项目的放大比例，默认为1
    * flex-shrink：定义项目的缩放比例，定义为0则代表不缩放
    * flex-basic：定义再分配多余空间，项目占用的空间
    * flex：是flex-grow，flex-shrink，flex-basic的简写，默认为0 1 auto
    * order：定义项目的排列顺序，顺序越小，排列越靠前，默认为0
* 三栏布局
  * 圣杯布局

  ::: demo [vanilla]
  ```html
  <style>
  .holy-grail-header {
      background-color: blue;
  }
  .holy-grail-main {
      background-color: orange;
      padding: 0 100px; /* 左右两边的padding来放置left和right区域 */
  }
  .holy-grail-main-left,.holy-grail-main-center,.holy-grail-main-right {
      float: left;
  }
  .holy-grail-main-center {
      background-color: purple;
      width: 100%; /* 这会把left和right挤到下一行 */
  }
  .holy-grail-main-left {
      background-color: red;
      width: 100px;
      margin-left: -100%; /* 把left移动到和center同一行并且左边对齐 */
      position: relative;
      left: -100px; /* 再向左移动到main的padding区域,就不会挡住center了 */
  }
  .holy-grail-main-right {
      background-color: grey;
      width: 100px;
      margin-left: -100px; /* 把left移动到和center同一行并且右边对齐 */
      position: relative;
      left: 100px; /* 向右移动到右边的padding区域*/
  }
  .holy-grail-footer {
      background-color: pink;
  }
  /* 清除浮动 */
  .clear-fix::after {
      content: "";
      display: block;
      clear: both;
  }
  </style>
  <html>
    <header class="holy-grail-header">头部</header>
    <div class="holy-grail-main clear-fix">
        <div class="holy-grail-main-center">中间</div>
        <div class="holy-grail-main-left">左侧</div>
        <div class="holy-grail-main-right">右侧</div>
    </div>
    <footer class="holy-grail-footer">底部</footer>
  </html>
  ```
  :::

  * 双飞翼布局

  ::: demo [vanilla]
  ```html
  <style>
  .wings-header {
      background-color: blue;
  }
  .wings-first,.wings-second,.wings-third {
      float: left;
  }
  /* 用这个div把主内容包起来之后,主内容就可使用margin空出两边的区域了 */
  .wings-first {
      width: 100%;
      background-color: purple;
  }
  .wings-first-content {
      margin: 0 100px;
  }
  .wings-second {
      width: 100px;
      background-color: red;
      margin-left: -100%; /* 作用和圣杯一样 */
  }
  .wings-third {
      width: 100px;
      background-color: grey;
      margin-left: -100px; /* 作用和圣杯一样 */
  }
  .wings-footer {
      background-color: pink;
      clear: both; /* 清除footer上面元素的浮动 */
  }
  </style>
  <html>
    <header class="wings-header">头部</header>
    <div class="wings-first">
      <div class="wings-first-content">中间</div>
    </div>
    <div class="wings-second">左侧</div>
    <div class="wings-third">右侧</div>
    <footer class="wings-footer">底部</footer> 
  </html>
  ```
  :::

  * flex布局
  
  ::: demo [vanilla]
  ```html
  <style>
  .flex-header {
    background-color: blue;
  }
  .flex-box {
      display: flex;
  }
  .flex-center {
    background-color: purple;
    flex-grow: 1;
  }
  .flex-left {
    background-color: red;
    order: -1;
    flex: 0 0 100px;
  }
  .flex-right {
    background-color: grey;
    flex: 0 0 100px;
  }
  .flex-footer {
    background-color: pink;
  }
  </style>
  <html>
    <header class="flex-header">头部</header>
    <div class="flex-box">
      <div class="flex-center">中间</div>
      <div class="flex-left">左侧</div>
      <div class="flex-right">右侧</div>
    </div>
    <footer class="flex-footer">底部</footer>
  </html>
  ```
  :::
* BFC(块级格式化上下文)
  * BFC这是一个独立的渲染区域，规定了内部如何布局，并且这个区域的子元素不会影响到外面的元素
  * BFC内部box垂直放置
  * 计算BFC的高度的时候，浮动元素也参与计算
  * 哪些元素会生成 BFC：
    * float 不为 none 的元素
    * position 为 fixed 和 absolute 的元素
    * display 为 inline-block、table-cell、table-caption，flex，inline-flex 的元素
    * overflow 不为 visible 的元素
* position 属性
  * fixed：固定定位，相对于浏览器窗口进行定位
  * absolute：绝对定位，绝对定位的元素的位置相对于最近的已定位父元素
  * relative：相对定位
  * sticky：粘性定位，元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。
* CSS的选择器有哪些？优先级？
  * CSS选择器有：
    * 基本选择器：通用选择器(*)，元素选择器，类选择器，ID选择器，属性选择器
    * 分组选择器：选择器列表(A, B)
    * 组合器：后代组合器(A B)，直接子代组合器(A>B)，一般兄组合器(A-B)，紧邻兄弟组合器(A+B)
    * 伪选择器：伪类，伪元素
  * 选择器优先级：
    * 第一优先级：!important
    * 内联样式，1000
    * ID选择器，0100
    * 类、伪类、属性选择器，0010
    * 标签、伪元素选择器，0001
    * 通配符、子类选择器、兄弟选择器，0000
* 清除浮动
  * 浮动元素后使用带clear: both;属性的空元素
  * 浮动元素容器使用CSS的overflow: hidden/auto;属性，IE中还需要增加zoom:1属性
  * 给浮动的元素的容器添加浮动
  * 给浮动元素的容器添加一个clear-fix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动
* link和@import区别
  * link属于HTML标签，而@import是CSS提供的
  * 页面被加载的时，link会同时被加载，而@import被引用的CSS会等到引用它的CSS文件被加载完再加载
  * import只在IE5以上才能识别，而link是HTML标签，无兼容问题
  * link方式的样式的权重 高于@import的权重
### JS
* 类型与判断
  * 数据类型：Number、String、Boolean、undefined、object、Null、Symbol、bigint
  * 基本数据类型：String、Number、boolean、null、undefined、Symbol
  * 引用类型：object。里面包含的 function、Array、Date
  * 类型判断
    * typeof
      * typeof可以对基本类型number、string  、boolean、undefined做出准确的判断
      * 而对于引用类型，除了function之外返回的都是object
    * instanceof
      * 当我们需要知道某个对象的具体类型时,可以用运算符 instanceof，instanceof操作符判断左操作数对象的原型链上是否有右边这个构造函数的prototype属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值。
    * constructor
      * constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。
      ```js
      var f = new F();
      f.constructor === F;// true
      ```
    * Object.prototype.toString.call
      * toString是Object原型对象上的一个方法，该方法默认返回其调用者的具体类型
      ```js
      Object.prototype.toString.call('') ;   // [object String]
      Object.prototype.toString.call(1) ;    // [object Number]
      Object.prototype.toString.call(true) ; // [object Boolean]
      Object.prototype.toString.call(undefined) ; // [object Undefined]
      Object.prototype.toString.call(null) ; // [object Null]
      Object.prototype.toString.call(new Function()) ; // [object Function]
      Object.prototype.toString.call(new Date()) ; // [object Date]
      Object.prototype.toString.call([]) ; // [object Array]
      Object.prototype.toString.call(new RegExp()) ; // [object RegExp]
      Object.prototype.toString.call(new Error()) ; // [object Error]
      ```
    * 特定方法
      * Array.isArray 用来判断是否是数组
* 原型链
* 继承
  * 原型链继承
    * 通过在父类原型链上声明方法，并将子类的prototype指向父类的实例
    ```js
    function Parent () {
      this.name = 'kevin';
    }
    Parent.prototype.getName = function () {
      console.log(this.name);
    }
    function Child () {}
    Child.prototype = new Parent();

    var child1 = new Child();
    console.log(child1.getName()) // kevin
    ```
    * 缺点
      * 引用类型的属性被所有实例共享
      * 在创建Child的时候，不能向Parent传参
  * 借用构造函数
    * 在子类构造函数中执行父类的构造函数
    ```js
    function Parent () {
      this.names = ['kevin', 'daisy'];
    }

    function Child () {
      Parent.call(this);
    }

    var child1 = new Child();
    child1.names.push('yayu');
    console.log(child1.names); // ["kevin", "daisy", "yayu"]

    var child2 = new Child();
    console.log(child2.names); // ["kevin", "daisy"]
    ```
    * 优点：
      * 避免了引用类型的属性被所有实例共享
      * 可以在 Child 中向 Parent 传参
    * 缺点：
      * 方法都在构造函数中定义，每次创建实例都会自动创建一遍方法
  * 组合继承
    * 借用构造函数 + 指定子类prototype
    ```js
    function Parent (name) {
      this.name = name;
      this.colors = ['red', 'blue', 'green'];
    }

    Parent.prototype.getName = function () {
      console.log(this.name);
    }

    function Child (name, age) {
      Parent.call(this, name);
      this.age = age;
    }

    Child.prototype = new Parent();
    Child.prototype.constructor = Child;

    var child1 = new Child('kevin', '18');
    child1.colors.push('black');
    console.log(child1.name); // kevin
    console.log(child1.age); // 18
    console.log(child1.colors); // ["red", "blue", "green", "black"]

    var child2 = new Child('daisy', '20');
    console.log(child2.name); // daisy
    console.log(child2.age); // 20
    console.log(child2.colors); // ["red", "blue", "green"]
    ```
    * 组合继承最大的缺点是会调用两次父构造函数
  * 原型式继承
    * 已传入的对象实例为父类
    ```js
    function createObj(o){
      function F(){}
      F.prototype = o
      return new F()
    }
    ```
    * 缺点：
      * 包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样
  * 寄生式继承
    * 创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象
    * 借用`Object.create`实现继承关系
    ```js
    function createObj (o) {
      var clone = Object.create(o);
      clone.sayName = function () {
          console.log('hi');
      }
      return clone;
    }
    ```
    * 缺点：
      * 跟借用构造函数模式一样，每次创建对象都会创建一遍方法
  * 寄生组合式继承
    * 在组合继承的基础上，间接的让`Child.prototype`访问到`Parent.prototype`
    ```js
    function Parent (name) {
      this.name = name;
      this.colors = ['red', 'blue', 'green'];
    }

    Parent.prototype.getName = function () {
      console.log(this.name)
    }

    function Child (name, age) {
      Parent.call(this, name);
      this.age = age;
    }

    // 关键的三步，在组合继承中则是直接将Child,prototype指向新创建的Parent实例
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();

    var child1 = new Child('kevin', '18');
    console.log(child1);
    ```
  * Class继承
    * 主要是依赖`extends`关键字来实现继承，且继承的效果类似于`寄生组合继承`
    * 使用了`extends`实现继承不一定要`constructor`和`super`，因为没有的话会默认产生并调用它们
    * `extends`后面接着的目标不一定是`class`，只要是个有`prototype`属性的`函数`就可以了
  * Super相关
    * 在实现继承时，如果子类中有`constructor`函数，必须得在`constructor`中调用一下`super`函数，因为它就是用来产生实例`this`的。
    * super有两种调用方式：当成`函数调用`和当成`对象调用`。
    * super当成`函数调用`时，代表父类的构造函数，且返回的是子类的实例，也就是此时`super`内部的`this`指向子类。在子类的`constructor`中`super()`就相当于是`Parent.constructor.call(this)`。
    * super当成`对象调用`时，普通函数中`super`对象指向父类的原型对象，静态函数中指向父类。且通过`super`调用父类的方法时，`super`会绑定子类的`this`，就相当于是`Parent.prototype.fn.call(this)`。
* this与apply/call/bind
  * 通常下this指向有以下几种情况：
    * 作为函数调用，非严格模式下，this指向window，严格模式下，this指向undefined；
    * 作为某对象的方法调用，this通常指向调用的对象。
    * 使用apply、call、bind 可以绑定this的指向。
    * 在构造函数中，this指向新创建的对象
    * 箭头函数没有单独的this值，this在箭头函数创建时确定，它与声明所在的上下文相同。
  * apply/call/bind 区别
    * apply调用后会执行函数，并且apply可以接受数组作为参数，并且将数组的元素解构传入被调用的函数中。
    * call调用后会执行函数，call接受的参数都会传入被调用的函数中。
    * bind调用后则是返回绑定this的函数，并且在调用时传入参数，那么返回的函数会自动保留传入的参数，再调用函数时可以接着传后续的参数。bind多次依然指向第一次bind的this。
* 闭包
  * 使用闭包主要是为了设计私有的方法和变量。在js中，函数即闭包，只有函数才会产生作用域的概念
  * 原理
    * 利用了函数作用域链的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，直到内部函数被销毁后才被销毁
  * 优点
    * 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用
    * 避免变量污染全局
    * 把变量存到独立的作用域，作为私有成员存在
  * 缺点
    * 对内存消耗有影响，因为内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存的使用量，所以使用不当会造成内存泄漏。
    * 对处理速度有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度
  * 应用
    * 模块封装
    * 柯里化函数
    * 使用闭包实现私有化方法和变量
    * 缓存一些结果
* 事件循环
![event-loop](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/16fb7ae3b678f1ea_tplv-t2oaga2asx-watermark.1x665gbn9n40.webp)
  * 流程
    * JS分为同步任务和异步任务
    * 同步任务都在主线程上执行，会形成一个执行栈
    * 事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放一个事件回调
    * 一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，将可运行的异步任务添加到执行栈中，开始执行
  * 宏任务
    * 在`ECMAScript`中，`macrotask`也被称为`task`
    * 由于`JS引擎线程`和`GUI渲染线程`是互斥的关系，浏览器为了能够使`宏任务`和`DOM任务`有序的进行，会在一个`宏任务`执行结果后，在下一个`宏任务`执行前，`GUI渲染线程`开始工作，对页面进行渲染
    ```
    宏任务 -> GUI渲染 -> 宏任务 -> ...
    ```
    * 常见的宏任务
      * 主代码块(script)
      * setTimeout/setInterval/setImmediate(Node)
      * requestAnimationFrame ()-浏览器
      * MessageChannel
  * 微任务
    * ES6新引入了`Promise`标准，同时浏览器实现上多了一个`microtask`微任务概念，在`ECMAScript`中，`microtask`也被称为`jobs`
    * 当一个`宏任务`执行完，会在渲染前，将执行期间所产生的所有`微任务`都执行完
    ```
    宏任务 -> 微任务 -> GUI渲染 -> 宏任务 -> ...
    ```
    * 常见的微任务：
      * process.nextTick[Node]
      * Promise.[then/catch/finally]
      * queueMicrotask
      * Object.observe
      * MutationObserver
  * Node.js的事件循环
  ```
  Node会先执行所有类型为 timers 的 MacroTask，然后执行所有的 MicroTask(NextTick例外)
  进入 poll 阶段，执行几乎所有 MacroTask，然后执行所有的 MicroTask
  再执行所有类型为 check 的 MacroTask，然后执行所有的 MicroTask
  再执行所有类型为 close callbacks 的 MacroTask，然后执行所有的 MicroTask
  至此，完成一个 Tick，回到 timers 阶段
  ……
  如此反复，无穷无尽……
  ```
* Promise
  * Promise解决了什么问题？
    * “回调地狱”所说的嵌套其实是指异步的嵌套。它带来了两个问题：可读性的问题和信任问题。
    * 异步嵌套带来的信任问题，它的问题的根源在于控制反转。
  * Promise有什么静态方法？
    * resolve
    * reject
    * race
    * any
    * all
    * allSettled
  * 手写Promise A+
    * 首先需要定义status
    * 在就维护两个队列：onFulfilledCallbacks和onRejectedCallbacks
    * 实现then方法，首先转化传入的参数，在就是创建Promise实例并返回
      * 在创建Promise实例的时候，传入的函数中需要判断当前Promise的状态，看是将fulfilledMicrotask和rejectedMicrotask放入对应的队列还是直接执行
      * 在fulfilledMicrotask和rejectedMicrotask中需要使用queueMicrotask函数产生微任务，并且调用resolvePromise函数解决嵌套Promise的问题
    * 还需要实现resolve和reject方法，传入executor中执行，这两个方法都是改变Promise的status，并执行对应的队列
    * 最后实现两个静态方法：resolve和reject，
    ```js
    const PENDING = 'pending'
    const FULFILLED = 'fulfilled'
    const REJECTED = 'rejected'

    class MyPromise {
      status = PENDING
      value = null
      reason = null
      onFulfilledCallbacks = []
      onRejectedCallbacks = []
      constructor(executor) {
        try{
          executor(this.resolve,this.reject)
        }catch(error){
          this.reject(error)
        }
      }
      resolve = (value)=> {
        if(this.status === PENDING) {
          this.status = FULFILLED
          this.value = value
          // 执行缓存的回调函数
          while(this.onFulfilledCallbacks.length) {
            this.onFulfilledCallbacks.shift()(value)
          }
        }
      }
      reject = (reason)=>{
        if(this.status === PENDING) {
          this.status = REJECTED
          this.reason = reason
          // 执行缓存的回调函数
          while(this.onRejectedCallbacks.length) {
            this.onRejectedCallbacks.shift()(reason)
          }
        }
      }
      then(onFulfilled, onRejected){
        const realOnFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value
        const realOnRejected = typeof onRejected === 'function' ? onRejected : reason => {throw reason}
        const next = new MyPromise((resolve, reject)=>{
          const fulfilledMicrotask = () => {
            queueMicrotask(()=>{
              // then 执行的时错误捕获
              try {
                const value = realOnFulfilled(this.value)
                resolvePromise(next, value, resolve, reject)
              } catch (error) {
                reject(error)
              }
            })
          }
          const rejectedMicrotask = () => {
            queueMicrotask(() => {
              try {
                // 调用失败回调，并且把原因返回
                const reason = realOnRejected(this.reason)
                // 传入 resolvePromise 集中处理
                resolvePromise(next, reason, resolve, reject)
              } catch (error) {
                reject(error)
              }
            })
          }
          if(this.status === FULFILLED) {
            fulfilledMicrotask()
          }else if(this.status === REJECTED) {
            rejectedMicrotask()
          }else if (this.status === PENDING) {
            // PENDING状态时缓存
            this.onFulfilledCallbacks.push(fulfilledMicrotask)
            this.onRejectedCallbacks.push(rejectedMicrotask)
          }
        })
        return next
      }
      // resolve 静态方法
      static resolve(parameter) {
        // 如果传入 MyPromise 就直接返回
        if (parameter instanceof MyPromise) {
          return parameter;
        }
        // 转成常规方式
        return new MyPromise(resolve =>  {
          resolve(parameter);
        });
      }
      // reject 静态方法
      static reject (reason) {
        return new MyPromise((resolve, reject) => {
          reject(reason);
        });
      }
    }
    function resolvePromise(promise, x, resolve, reject) {
      // 解决循环调用的问题
      if (promise === x) {
        return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))
      }
      if (typeof x === 'object' || typeof x === 'function') {
        // x 为 null 直接返回，走后面的逻辑会报错
        if (x === null) {
          return resolve(x);
        }

        let then;
        try {
          // 把 x.then 赋值给 then 
          then = x.then;
        } catch (error) {
          return reject(error);
        }

        // 如果 then 是函数
        if (typeof then === 'function') {
          let called = false;
          try {
            then.call(
              x, // this 指向 x
              // 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y)
              y => {
                // 如果 resolvePromise 和 rejectPromise 均被调用，
                // 或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用
                // 实现这条需要前面加一个变量 called
                if (called) return;
                called = true;
                resolvePromise(promise, y, resolve, reject);
              },
              // 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise
              r => {
                if (called) return;
                called = true;
                reject(r);
              });
          } catch (error) {
            // 如果 resolvePromise 或 rejectPromise 已经被调用，直接返回
            if (called) return;
            reject(error);
          }
        } else {
          // 如果 then 不是函数，以 x 为参数执行 promise
          resolve(x);
        }
      } else {
        // 如果 x 不为对象或者函数，以 x 为参数执行 promise
        resolve(x);
      }
    }
    ```
### TS
* 泛型
* Utility Types
* Template Literal Types

## 网络协议
### HTTP协议
* http 1.1
* http 2
* http 3
* https
### DNS协议

## 浏览器
### 常见概念
* 重绘和回流(重排)
  * 回流(重排)
    * 回流又名重排，指几何属性需改变的渲染。
    * 渲染树的节点发生改变，影响了该节点的几何属性，导致该节点位置发生变化，此时就会触发浏览器回流并重新生成渲染树。
    * 回流意味着节点的几何属性改变，需重新计算并生成渲染树，导致渲染树的全部或部分发生变化。
  * 重绘
    * 重绘指更改外观属性而不影响几何属性的渲染。
    * 渲染树的节点发生改变，但不影响该节点的几何属性。由此可见，回流对浏览器性能的消耗是高于重绘的，而且回流一定会伴随重绘，重绘却不一定伴随回流。
  * 如何减少回流和重绘
    * 使用visibility:hidden替换display:none
    * 使用transform代替top
    * 避免使用Table布局
    * 避免规则层级过多
    * 避免节点属性值放在循环里当成循环变量
    * 动态改变类而不改变样式
* 同源策略
  * 同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。
  * 如果两个 URL 的 protocol、port 和 host 都相同的话，则这两个 URL 是同源。
  * 同源策略限制的内容有：
    * Cookie、LocalStorage、IndexedDB 等存储性内容
    * DOM 节点
    * AJAX 请求发送后，结果被浏览器拦截了
  * 但是有三个标签是允许跨域加载资源：
    * `<img src=XXX>`
    * `<link href=XXX>`
    * `<script src=XXX>`
  * 如何解决跨域
    * JSONP
    * CORS, 通过设置Access-Control-Allow-Origin请求头
      *  根据请求方法和携带参数的不同又分为简单请求和非简单请求，非简单请求需要发出OPTIONS的预请求
    * document.domain，只适用于耳机域名相同的情况下
    * window.name，即在一个窗口的生命周期内,窗口载入的所有 的页面都是共享一个window.name的
    * postMessage
    ```html
    // a.html
    <iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()">
    <!-- 等它加载完触发一个事件 -->
    </iframe> 
    <!-- 内嵌在http://localhost:3000/a.html -->
    <script>
      function load() {
        let frame = document.getElementById('frame')
        frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据
        window.onmessage = function(e) { //接受返回数据
          console.log(e.data) //我不爱你
        }
      }
    </script>
    <!-- http://localhost:4000/b.html -->
    <script>
      window.onmessage = function(e) {
        console.log(e.data) //我爱你
        e.source.postMessage('我不爱你', e.origin)
    }
    </script>
    ```
### 渲染流程
### V8

## 框架
### Vue
### React

## 工程化
### 编译工具
### 打包工具
### bundleless

## 性能优化
### 网络优化
### 体积优化
### 加载优化
### 代码优化

## Node.js
### 基本概念及原理
### 常用模块
### Web 框架
* Koa
* egg.js
