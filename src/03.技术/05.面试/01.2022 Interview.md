---
title: 2022 Interview
date: 2022-02-28 11:58:10
permalink: /pages/33969f/
categories:
tags:
  - interview
---
## 大纲
![大纲](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/大纲.3ttblao9ahw0.webp)
## 基础
### HTML
* HTML5 语义化标签
  * 语义化标签： `header`，`nav`，`main`，`article`，`section`，`aside`，`footer`
  * 语义化意味着顾名思义，HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构，而不是滥用div。
  * 语义化的优点有:
    * 代码结构清晰，易于阅读，利于开发和维护
    * 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。
    * 有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重
* script标签中的 `defer`和`async`属性
  * 相同点：
    * 都是`异步加载资源`
  * 区别：
    * `async`属性是异步加载，`加载完成后立即执行`，标记为async的脚本`不保证按照出现顺序`执行
    * 标记为`defer`属性的脚本会`等到HTML解析完成后再执行`，执行顺序就是`按照出现顺序`
### CSS
* CSS 盒模型
  * box-sizing: border-box, content-box
  * 分为标准盒模型和IE盒模型，在标准盒子模型中，width 指 content 部分的宽度，在IE盒子模型中，width 表示 content+padding+border 这三个部分的宽度
  * box-sizing:content-box 表示标准盒子模型，box-sizing:border-box 表示的是IE盒子模型
* flex布局
  * 常用属性：
    * `flex-direction`: 主轴方向，默认值为`row`，`column`为垂直方向排列
    * `justify-content`：主轴方向排列方式，可选属性为：`flex-start`，`flex-end`，`center`，`space-between`，`space-around`
    * `align-items`：副轴方向排列方式，可选属性与`justify-content`相同
    * `flex-wrap`：换行规则，可选属性为：`nowrap`，`wrap`，`wrap-reverse`
    * `flex-grow`：定义项目的放大比例，默认为1
    * `flex-shrink`：定义项目的缩放比例，定义为0则代表不缩放
    * `flex-basic`：定义再分配多余空间，项目占用的空间
    * `flex`：是`flex-grow`，`flex-shrink`，`flex-basic`的简写，默认为`0 1 auto`
    * `order`：定义项目的排列顺序，顺序越小，排列越靠前，默认为0
* 三栏布局
  * 圣杯布局

  ::: demo [vanilla]
  ```html
  <style>
  .holy-grail-header {
      background-color: blue;
  }
  .holy-grail-main {
      background-color: orange;
      padding: 0 100px; /* 左右两边的padding来放置left和right区域 */
  }
  .holy-grail-main-left,.holy-grail-main-center,.holy-grail-main-right {
      float: left;
  }
  .holy-grail-main-center {
      background-color: purple;
      width: 100%; /* 这会把left和right挤到下一行 */
  }
  .holy-grail-main-left {
      background-color: red;
      width: 100px;
      margin-left: -100%; /* 把left移动到和center同一行并且左边对齐 */
      position: relative;
      left: -100px; /* 再向左移动到main的padding区域,就不会挡住center了 */
  }
  .holy-grail-main-right {
      background-color: grey;
      width: 100px;
      margin-left: -100px; /* 把left移动到和center同一行并且右边对齐 */
      position: relative;
      left: 100px; /* 向右移动到右边的padding区域*/
  }
  .holy-grail-footer {
      background-color: pink;
  }
  /* 清除浮动 */
  .clear-fix::after {
      content: "";
      display: block;
      clear: both;
  }
  </style>
  <html>
    <header class="holy-grail-header">头部</header>
    <div class="holy-grail-main clear-fix">
        <div class="holy-grail-main-center">中间</div>
        <div class="holy-grail-main-left">左侧</div>
        <div class="holy-grail-main-right">右侧</div>
    </div>
    <footer class="holy-grail-footer">底部</footer>
  </html>
  ```
  :::

  * 双飞翼布局

  ::: demo [vanilla]
  ```html
  <style>
  .wings-header {
      background-color: blue;
  }
  .wings-first,.wings-second,.wings-third {
      float: left;
  }
  /* 用这个div把主内容包起来之后,主内容就可使用margin空出两边的区域了 */
  .wings-first {
      width: 100%;
      background-color: purple;
  }
  .wings-first-content {
      margin: 0 100px;
  }
  .wings-second {
      width: 100px;
      background-color: red;
      margin-left: -100%; /* 作用和圣杯一样 */
  }
  .wings-third {
      width: 100px;
      background-color: grey;
      margin-left: -100px; /* 作用和圣杯一样 */
  }
  .wings-footer {
      background-color: pink;
      clear: both; /* 清除footer上面元素的浮动 */
  }
  </style>
  <html>
    <header class="wings-header">头部</header>
    <div class="wings-first">
      <div class="wings-first-content">中间</div>
    </div>
    <div class="wings-second">左侧</div>
    <div class="wings-third">右侧</div>
    <footer class="wings-footer">底部</footer> 
  </html>
  ```
  :::

  * flex布局
  
  ::: demo [vanilla]
  ```html
  <style>
  .flex-header {
    background-color: blue;
  }
  .flex-box {
      display: flex;
  }
  .flex-center {
    background-color: purple;
    flex-grow: 1;
  }
  .flex-left {
    background-color: red;
    order: -1;
    flex: 0 0 100px;
  }
  .flex-right {
    background-color: grey;
    flex: 0 0 100px;
  }
  .flex-footer {
    background-color: pink;
  }
  </style>
  <html>
    <header class="flex-header">头部</header>
    <div class="flex-box">
      <div class="flex-center">中间</div>
      <div class="flex-left">左侧</div>
      <div class="flex-right">右侧</div>
    </div>
    <footer class="flex-footer">底部</footer>
  </html>
  ```
  :::
* `BFC`(块级格式化上下文)
  * `BFC`这是一个独立的`渲染区域`，规定了内部如何布局，并且这个区域的子元素不会影响到外面的元素
  * BFC内部box`垂直放置`
  * 计算BFC的高度的时候，`浮动元素`也参与计算
  * 哪些元素会生成 BFC：
    * `float` 不为 `none` 的元素
    * `position` 为 `fixed` 和 `absolute` 的元素
    * `display` 为 `inline-block`、`table-cell`、`table-caption`，`flex`，`inline-flex` 的元素
    * `overflow` 不为 `visible` 的元素
* `position` 属性
  * `fixed`：固定定位，相对于浏览器窗口进行定位
  * `absolute`：绝对定位，绝对定位的元素的位置相对于最近的已定位父元素
  * `relative`：相对定位
  * `sticky`：粘性定位，元素先按照普通文档流定位，然后相对于该元素在流中的 `flow root`（BFC）和 `containing block`（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。
* CSS的选择器有哪些？优先级？
  * CSS选择器有：
    * 基本选择器：`通用选择器`(*)，`元素选择器`，`类选择器`，`ID选择器`，`属性选择器`
    * 分组选择器：`选择器列表`(A, B)
    * 组合器：`后代组合器`(A B)，`直接子代组合器`(A>B)，`一般兄组合器`(A-B)，`紧邻兄弟组合器`(A+B)
    * 伪选择器：`伪类`，`伪元素`
  * 选择器优先级：
    * 第一优先级：!important
    * 内联样式，1000
    * ID选择器，0100
    * 类、伪类、属性选择器，0010
    * 标签、伪元素选择器，0001
    * 通配符、子类选择器、兄弟选择器，0000
* 清除浮动
  * 浮动元素后使用带`clear: both;`属性的空元素
  * 浮动元素容器使用CSS的`overflow: hidden/auto;`属性，IE中还需要增加`zoom:1`属性
  * 给浮动的元素的容器添加浮动
  * 给浮动元素的容器添加一个`clear-fix`的class，然后给这个class添加一个`:after`伪元素实现元素末尾添加一个看不见的块元素清理浮动
* `link`和`@import`区别
  * `link`属于`HTML`标签，而`@import`是`CSS`提供的
  * 页面被加载的时，`link`会同时被加载，而`@import`被引用的`CSS`会等到引用它的`CSS`文件被加载完再加载
  * `import`只在`IE5`以上才能识别，而`link`是`HTML`标签，无兼容问题
  * `link`方式的样式的权重 高于`@import`的权重
* 哪些样式可以被继承
  * 文本相关属性：`font-family`、`font-size`、`font-weight`、`line-height`
  * 列表相关的属性：`list-style-image`、`list-style-position`、`list-style-type`、`list-style`
  * `color`
### JS
* 类型与判断
  * 数据类型：`Number`、`String`、`Boolean`、`undefined`、`object`、`Null`、`Symbol`、`bigint`
  * 基本数据类型：`String`、`Number`、`boolean`、`null`、`undefined`、`Symbol`
  * 引用类型：`object`。里面包含的 `function`、`Array`、`Date`
  * 类型判断
    * `typeof`
      * `typeof`可以对基本类型`number`、`string`、`boolean`、`undefined`做出准确的判断
      * 而对于引用类型，除了`function`之外返回的都是`object`
    * `instanceof`
      * 当我们需要知道某个对象的具体类型时,可以用运算符`instanceof`，`instanceof`操作符判断左操作数对象的原型链上是否有右边这个构造函数的`prototype`属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值。
    * `constructor`
      * `constructor`属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。
      ```js
      var f = new F();
      f.constructor === F;// true
      ```
    * `Object.prototype.toString.call`
      * `toString`是`Object`原型对象上的一个方法，该方法默认返回其调用者的具体类型
      ```js
      Object.prototype.toString.call('') ;   // [object String]
      Object.prototype.toString.call(1) ;    // [object Number]
      Object.prototype.toString.call(true) ; // [object Boolean]
      Object.prototype.toString.call(undefined) ; // [object Undefined]
      Object.prototype.toString.call(null) ; // [object Null]
      Object.prototype.toString.call(new Function()) ; // [object Function]
      Object.prototype.toString.call(new Date()) ; // [object Date]
      Object.prototype.toString.call([]) ; // [object Array]
      Object.prototype.toString.call(new RegExp()) ; // [object RegExp]
      Object.prototype.toString.call(new Error()) ; // [object Error]
      ```
    * 特定方法
      * `Array.isArray` 用来判断是否是数组
* 原型链
* 继承
  * `原型链继承`
    * 通过在父类原型链上声明方法，并将子类的`prototype`指向父类的实例
    ```js
    function Parent () {
      this.name = 'kevin';
    }
    Parent.prototype.getName = function () {
      console.log(this.name);
    }
    function Child () {}
    Child.prototype = new Parent();

    var child1 = new Child();
    console.log(child1.getName()) // kevin
    ```
    * 缺点
      * 引用类型的属性被所有实例共享
      * 在创建`Child`的时候，不能向`Parent`传参
  * `借用构造函数`
    * 在`子类构造函数`中执行`父类的构造函数`
    ```js
    function Parent () {
      this.names = ['kevin', 'daisy'];
    }

    function Child () {
      Parent.call(this);
    }

    var child1 = new Child();
    child1.names.push('yayu');
    console.log(child1.names); // ["kevin", "daisy", "yayu"]

    var child2 = new Child();
    console.log(child2.names); // ["kevin", "daisy"]
    ```
    * 优点：
      * 避免了引用类型的属性被所有实例共享
      * 可以在 Child 中向 Parent 传参
    * 缺点：
      * 方法都在构造函数中定义，每次创建实例都会自动创建一遍方法
  * `组合继承`
    * `借用构造函数` + 指定子类`prototype`
    ```js
    function Parent (name) {
      this.name = name;
      this.colors = ['red', 'blue', 'green'];
    }

    Parent.prototype.getName = function () {
      console.log(this.name);
    }

    function Child (name, age) {
      Parent.call(this, name);
      this.age = age;
    }

    Child.prototype = new Parent();
    Child.prototype.constructor = Child;

    var child1 = new Child('kevin', '18');
    child1.colors.push('black');
    console.log(child1.name); // kevin
    console.log(child1.age); // 18
    console.log(child1.colors); // ["red", "blue", "green", "black"]

    var child2 = new Child('daisy', '20');
    console.log(child2.name); // daisy
    console.log(child2.age); // 20
    console.log(child2.colors); // ["red", "blue", "green"]
    ```
    * `组合继承`最大的缺点是会调用`两次父构造函数`
  * `原型式继承`
    * 已传入的对象实例为父类
    ```js
    function createObj(o){
      function F(){}
      F.prototype = o
      return new F()
    }
    ```
    * 缺点：
      * 包含引用类型的属性值始终都会`共享`相应的值，这点跟原型链继承一样
  * 寄生式继承
    * 创建一个仅用于`封装继承`过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象
    * 借用`Object.create`实现继承关系
    ```js
    function createObj (o) {
      var clone = Object.create(o);
      clone.sayName = function () {
          console.log('hi');
      }
      return clone;
    }
    ```
    * 缺点：
      * 跟借用构造函数模式一样，每次创建对象都会创建一遍方法
  * 寄生组合式继承
    * 在组合继承的基础上，间接的让`Child.prototype`访问到`Parent.prototype`
    ```js
    function Parent (name) {
      this.name = name;
      this.colors = ['red', 'blue', 'green'];
    }

    Parent.prototype.getName = function () {
      console.log(this.name)
    }

    function Child (name, age) {
      Parent.call(this, name);
      this.age = age;
    }

    // 关键的三步，在组合继承中则是直接将Child,prototype指向新创建的Parent实例
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();

    var child1 = new Child('kevin', '18');
    console.log(child1);
    ```
  * Class继承
    * 主要是依赖`extends`关键字来实现继承，且继承的效果类似于`寄生组合继承`
    * 使用了`extends`实现继承不一定要`constructor`和`super`，因为没有的话会默认产生并调用它们
    * `extends`后面接着的目标不一定是`class`，只要是个有`prototype`属性的`函数`就可以了
  * Super相关
    * 在实现继承时，如果子类中有`constructor`函数，必须得在`constructor`中调用一下`super`函数，因为它就是用来产生实例`this`的。
    * super有两种调用方式：当成`函数调用`和当成`对象调用`。
    * super当成`函数调用`时，代表父类的构造函数，且返回的是子类的实例，也就是此时`super`内部的`this`指向子类。在子类的`constructor`中`super()`就相当于是`Parent.constructor.call(this)`。
    * super当成`对象调用`时，普通函数中`super`对象指向父类的原型对象，静态函数中指向父类。且通过`super`调用父类的方法时，`super`会绑定子类的`this`，就相当于是`Parent.prototype.fn.call(this)`。
* `this`与`apply/call/bind`
  * 通常下`this`指向有以下几种情况：
    * 作为函数调用，非严格模式下，`this`指向`window`，严格模式下，`this`指向`undefined`；
    * 作为某对象的方法调用，`this`通常指向调用的对象。
    * 使用`apply`、`call`、`bind` 可以绑定`this`的指向。
    * 在构造函数中，`this`指向新创建的对象
    * 箭头函数没有单独的`this`值，`this`在箭头函数创建时确定，它与声明所在的上下文相同。
  * `apply/call/bind` 区别
    * `apply`调用后会执行函数，并且`apply`可以接受数组作为参数，并且将数组的元素解构传入被调用的函数中。
    * `call`调用后会执行函数，`call`接受的参数都会传入被调用的函数中。
    * `bind`调用后则是返回绑定`this`的函数，并且在调用时传入参数，那么返回的函数会自动保留传入的参数，再调用函数时可以接着传后续的参数。`bind`多次依然指向第一次`bind`的`this`。
* 闭包
  * 使用闭包主要是为了设计私有的方法和变量。在js中，函数即闭包，只有函数才会产生`作用域`的概念
  * 原理
    * 利用了`函数作用域链`的特性，一个函数内部定义的函数会将包含外部函数的`活动对象`添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的`作用域链`仍然在引用这个`活动对象`，所以其活动对象不会被销毁，直到内部函数被销毁后才被销毁
  * 优点
    * 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用
    * 避免变量`污染全局`
    * 把变量存到独立的`作用域`，作为私有成员存在
  * 缺点
    * 对`内存消耗`有影响，因为内部函数保存了对外部变量的引用，导致无法被`垃圾回收`，增大内存的使用量，所以使用不当会造成`内存泄漏`。
    * 对`处理速度`有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度
  * 应用
    * 模块封装
    * 柯里化函数
    * 使用闭包实现私有化方法和变量
    * 缓存一些结果
* 事件循环
![event-loop](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/16fb7ae3b678f1ea_tplv-t2oaga2asx-watermark.1x665gbn9n40.webp)
  * 流程
    * JS分为`同步任务`和`异步任务`
    * `同步任务`都在主线程上执行，会形成一个执行栈
    * `事件触发线程`管理着一个`任务队列`，只要`异步任务`有了运行结果，就在任务队列之中放一个事件回调
    * 一旦`执行栈`中的所有`同步任务`执行完毕，系统就会读取`任务队列`，将可运行的`异步任务`添加到`执行栈`中，开始执行
  * 宏任务
    * 在`ECMAScript`中，`macrotask`也被称为`task`
    * 由于`JS引擎线程`和`GUI渲染线程`是互斥的关系，浏览器为了能够使`宏任务`和`DOM任务`有序的进行，会在一个`宏任务`执行结果后，在下一个`宏任务`执行前，`GUI渲染线程`开始工作，对页面进行渲染
    ```
    宏任务 -> GUI渲染 -> 宏任务 -> ...
    ```
    * 常见的宏任务
      * `主代码块(script)`
      * `setTimeout/setInterval/setImmediate(Node)`
      * `requestAnimationFrame`
      * `MessageChannel`
  * 微任务
    * ES6新引入了`Promise`标准，同时浏览器实现上多了一个`microtask`微任务概念，在`ECMAScript`中，`microtask`也被称为`jobs`
    * 当一个`宏任务`执行完，会在渲染前，将执行期间所产生的所有`微任务`都执行完
    ```
    宏任务 -> 微任务 -> GUI渲染 -> 宏任务 -> ...
    ```
    * 常见的`微任务`：
      * `process.nextTick[Node]`
      * `Promise.[then/catch/finally]`
      * `queueMicrotask`
      * `Object.observe`
      * `MutationObserver`
  * Node.js的事件循环
  ```
  Node会先执行所有类型为 timers 的 MacroTask，然后执行所有的 MicroTask(NextTick例外)
  进入 poll 阶段，执行几乎所有 MacroTask，然后执行所有的 MicroTask
  再执行所有类型为 check 的 MacroTask，然后执行所有的 MicroTask
  再执行所有类型为 close callbacks 的 MacroTask，然后执行所有的 MicroTask
  至此，完成一个 Tick，回到 timers 阶段
  ……
  如此反复，无穷无尽……
  ```
* Promise
  * `Promise`解决了什么问题？
    * “回调地狱”所说的嵌套其实是指异步的嵌套。它带来了两个问题：`可读性`的问题和`信任`问题。
    * 异步嵌套带来的`信任`问题，它的问题的根源在于`控制反转`。
  * `Promise`有什么静态方法？
    * `resolve`
    * `reject`
    * `race`
    * `any`
    * `all`
    * `allSettled`
  * 手写`Promise A+`
    * 首先需要定义`status`
    * 在就维护两个队列：`onFulfilledCallbacks`和`onRejectedCallbacks`
    * 实现`then`方法，首先转化传入的参数，在就是创建`Promise`实例并返回
      * 在创建`Promise`实例的时候，传入的函数中需要判断当前`Promise`的状态，看是将`fulfilledMicrotask`和`rejectedMicrotask`放入对应的队列还是直接执行
      * 在`fulfilledMicrotask`和`rejectedMicrotask`中需要使用`queueMicrotask`函数产生微任务，并且调用`resolvePromise`函数解决嵌套`Promise`的问题
    * 还需要实现`resolve`和`reject`方法，传入`executor`中执行，这两个方法都是改变`Promise`的`status`，并执行对应的队列
    * 最后实现两个静态方法：`static resolve`和`static reject`，
    ```js
    const PENDING = 'pending'
    const FULFILLED = 'fulfilled'
    const REJECTED = 'rejected'

    class MyPromise {
      status = PENDING
      value = null
      reason = null
      onFulfilledCallbacks = []
      onRejectedCallbacks = []
      constructor(executor) {
        try{
          executor(this.resolve,this.reject)
        }catch(error){
          this.reject(error)
        }
      }
      resolve = (value)=> {
        if(this.status === PENDING) {
          this.status = FULFILLED
          this.value = value
          // 执行缓存的回调函数
          while(this.onFulfilledCallbacks.length) {
            this.onFulfilledCallbacks.shift()(value)
          }
        }
      }
      reject = (reason)=>{
        if(this.status === PENDING) {
          this.status = REJECTED
          this.reason = reason
          // 执行缓存的回调函数
          while(this.onRejectedCallbacks.length) {
            this.onRejectedCallbacks.shift()(reason)
          }
        }
      }
      then(onFulfilled, onRejected){
        const realOnFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value
        const realOnRejected = typeof onRejected === 'function' ? onRejected : reason => {throw reason}
        const next = new MyPromise((resolve, reject)=>{
          const fulfilledMicrotask = () => {
            queueMicrotask(()=>{
              // then 执行的时错误捕获
              try {
                const value = realOnFulfilled(this.value)
                resolvePromise(next, value, resolve, reject)
              } catch (error) {
                reject(error)
              }
            })
          }
          const rejectedMicrotask = () => {
            queueMicrotask(() => {
              try {
                // 调用失败回调，并且把原因返回
                const reason = realOnRejected(this.reason)
                // 传入 resolvePromise 集中处理
                resolvePromise(next, reason, resolve, reject)
              } catch (error) {
                reject(error)
              }
            })
          }
          if(this.status === FULFILLED) {
            fulfilledMicrotask()
          }else if(this.status === REJECTED) {
            rejectedMicrotask()
          }else if (this.status === PENDING) {
            // PENDING状态时缓存
            this.onFulfilledCallbacks.push(fulfilledMicrotask)
            this.onRejectedCallbacks.push(rejectedMicrotask)
          }
        })
        return next
      }
      // resolve 静态方法
      static resolve(parameter) {
        // 如果传入 MyPromise 就直接返回
        if (parameter instanceof MyPromise) {
          return parameter;
        }
        // 转成常规方式
        return new MyPromise(resolve =>  {
          resolve(parameter);
        });
      }
      // reject 静态方法
      static reject (reason) {
        return new MyPromise((resolve, reject) => {
          reject(reason);
        });
      }
    }
    function resolvePromise(promise, x, resolve, reject) {
      // 解决循环调用的问题
      if (promise === x) {
        return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))
      }
      if (typeof x === 'object' || typeof x === 'function') {
        // x 为 null 直接返回，走后面的逻辑会报错
        if (x === null) {
          return resolve(x);
        }

        let then;
        try {
          // 把 x.then 赋值给 then 
          then = x.then;
        } catch (error) {
          return reject(error);
        }

        // 如果 then 是函数
        if (typeof then === 'function') {
          let called = false;
          try {
            then.call(
              x, // this 指向 x
              // 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y)
              y => {
                // 如果 resolvePromise 和 rejectPromise 均被调用，
                // 或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用
                // 实现这条需要前面加一个变量 called
                if (called) return;
                called = true;
                resolvePromise(promise, y, resolve, reject);
              },
              // 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise
              r => {
                if (called) return;
                called = true;
                reject(r);
              });
          } catch (error) {
            // 如果 resolvePromise 或 rejectPromise 已经被调用，直接返回
            if (called) return;
            reject(error);
          }
        } else {
          // 如果 then 不是函数，以 x 为参数执行 promise
          resolve(x);
        }
      } else {
        // 如果 x 不为对象或者函数，以 x 为参数执行 promise
        resolve(x);
      }
    }
    ```
### TS
* 泛型
  * 泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。
  * 设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：
    * 类的实例成员
    * 类的方法
    * 函数参数
    * 函数返回值
  * 这里衍生出泛型的应用：
    * 泛型类
    * 泛型方法
    * 泛型函数
* interface
  * 同名的interface会自动合并，同名的interface和class会自动聚合。
  * TypeScript 中 interface 可以给 Function / Array / Class（Indexable）做声明吗？
  ```ts
  /* 可以 */
  // 函数声明
  interface Say {
    (name: string): viod;
  }
  let say: Say = (name: string):viod => {}
  // Array 声明
  interface NumberArray { 
    [index: number]: number; 
  } 
  let fibonacci: NumberArray = [1, 1, 2, 3, 5];
  // Class 声明
  interface PersonalIntl {
    name: string
    sayHi (name: string): string
  }
  ```
  * type与interface的区别
    * 相同点：
      * 都可以描述 '对象' 或者 '函数' 
      * 都允许拓展(extends)
    不同点：
      * type 可以声明基本类型，联合类型，元组
      * type 可以使用 typeof 获取实例的类型进行赋值
      * 多个命名相同的 interface 声明可以自动合并
  使用 interface 描述‘数据结构’，使用 type 描述‘类型关系’
* Unicon Types(联合类型)
* Utility Types(工具类型)
  * `Partial<Type>`: 将传入的类型的属性全部设为可选
  * `Required<Type>`：将传入的类型的属性全部设为必传
  * `Readonly<Type>`：将传入的类型的属性全部设为只读
  * `Record<Keys, Type>`：构建一个对象类型，其键为Keys中声明的类型，其值为Type中声明的类型
  * `Pick<Type, Keys>`：从传入的Type中选择Keys对应的属性并组成新的类型
  * `Omit<Type, Keys>`：从传入的Type中剔除Keys对应的属性并组成新的类型
  * `Exclude<UnionType, ExcludedMembers>`：从联合类型UnionType中剔除ExcludedMembers组成新的类型
  * `Extract<Type, Union>`：提取Type和Union中的公共类型
  * `NonNullable<Type>`：从Type中剔除null和undefined的类型
  * `Parameters<Type>`：从函数类型Type中获取参数类型，并组成一个元组类型
  * `ConstructorParameters<Type>`：从构造函数类型Type中获取参数类型，并组成一个元组类型
  * `ReturnType<Type>`：获取函数类型Type的返回值类型
  * `InstanceType<Type>`：从构造函数类型Type中获取实例类型
  * `ThisParameterType<Type>`：获取函数类型Type的this参数的类型
  * `OmitThisParameter<Type>`：从函数类型Type中移除this参数，并生成新的类型
  * `ThisType<Type>`：此工具类型不返回转换后的类型。相反，它用作上下文这种类型的标记。
  * `Uppercase<StringType>`：全部大写传入的字符串类型
  * `Lowercase<StringType>`：全部小写传入的字符串类型
  * `Capitalize<StringType>`：转换首字母为大写
  * `Uncapitalize<StringType>`：转换首字母为小写
* Type Operator(类型操作符)
  * keyof：`索引类型查询操作符`，获取索引类型的属性名，构成联合类型。
  * typeof：获取一个变量或对象的类型。
* [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)(条件类型)
  * 使用extends进行判断
  * 可以在泛型中判断T的类型
  * 当与any判断，并且判断类型传入并集时，就变成一个分布式条件类型
* [Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)(映射类型)
  * 基于一个类型去创建另一个类型
  * 可以使用-/+ 增加属性的修饰符，例如?、readonly
  * 使用as对属性名重命名，结合字符串模板类型，可以支持更自由的命名规则
  ```ts
  type Getters<Type> = {
    [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]
  };
  interface Person {
    name: string;
    age: number;
    location: string;
  }
  type LazyPerson = Getters<Person>;
  // type LazyPerson = {
  //   getName: () => string;
  //   getAge: () => number;
  //   getLocation: () => string;
  // }
  ```
* Template Literal Types
  * `模板文本类型`建立在`字符串文本类型`的基础上，并能够通过联合扩展为许多字符串。
  ```ts
  type World = "world";
  type Greeting = `hello ${World}`; // type Greeting = "hello world"

  type EmailLocaleIDs = "welcome_email" | "email_heading";
  type FooterLocaleIDs = "footer_title" | "footer_sendoff";
  type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`; // type AllLocaleIDs = "welcome_email_id" | "email_heading_id" | "footer_title_id" | "footer_sendoff_id"
  ```
* 协变、逆变、双向协变以及不变性
  * `JavaScript`中的复杂数据类型`Object`是一种`结构化类型`。哪怕使用了`ES6`的`class`语法糖，创建的类型本质上还是`Object`，因此`TypeScript`使用的也是一种`结构化`的`类型检查系统`。
  * 因此在TypeScript中，判断两个类型是否兼容，只需要判断他们的“`结构`”是否一致，也就是说`结构属性名`和`类型`是否一致。而不需要关心他们的“`名字`”是否相同。
  * 而`协变`和`逆变`就是`子类型`上的两个比较容易混淆的概念。
  * `协变` (Covariant)：指允许`子类型`转换为`父类型`
  * `逆变` (Contravariant)：指允许`父类型`转换为`子类型`，多发生在`函数类型`中
  * `双向协变` (Bivariant)：指允许`子类型`转换为`父类型`，也允许`父类型`转换为`子类型`，老版本(2.6之前)中，`TypeScript`的函数参数是`双向协变`的，但这样并不安全
  * `不变` (Invariant)：指不同类型之前是无法相互转换的。
    * 举例：`List<Dog>` 能否为 `List<Animal>` 的子类型，其中 `Dog ≼ Animal`
    * 答案是如果列表是不可变列表，那么答案是肯定的，因为类型很安全。但是假如列表是可变的，那么答案绝对是否定的！
    * 总结一下，我们可以允许`不可变列表`在它的参数类型上是`协变`的，但是对于`可变列表`，其参数类型则必须是`不变`的，既不是协变也不是逆变。

## 网络协议
### TCP
* TCP/IP模型
![TCP/IP](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/v2-a0eeeef2d69e44e1434c01f341660a0f_r.38c312qzvdo0.webp)
* TCP协议
  * TCP的全称是`Transmission Control Protocol`，传输控制协议。它能够帮助你确定计算机连接到`Internet`以及它们之间的数据传输。
  * 通过`三次握手`来建立TCP连接，`三次握手`就是用来启动和确认TCP连接的过程。一旦连接建立后，就可以发送数据了，当数据传输完成后，会通过关闭虚拟电路来断开连接。
* TCP协议特点
  * TCP能够确`保连接的建立`和`数据包的发送`
  * TCP支持`错误重传机制`
  * TCP支持`拥塞控制`，能够在网络拥堵的情况下`延迟发送`
  * TCP能够提供`错误校验和`，甄别有害的数据包
* TCP三次握手
  * `SYN`：`同步序列编号`。是`TCP/IP`建立连接时使用的握手信号。在客户机和服务器之间建立`TCP`连接时，首先会发送的一个信号。客户端在接受到`SYN`消息时，就会在自己的段内生成一个随机值`X`。
  * `SYN-ACK`：服务器收到SYN后，打开客户端连接，发送一个`SYN-ACK`作为答复。确认号设置为比接收到的序列号多一个，即`X+1`，服务器为数据包选择的序列号是另一个随机数`Y`。
  * `ACK`：`确认字符`，表示发来的数据已确认接收无误。最后，客户端将`ACK`发送给服务器。序列号被设置为所接收的确认值即`Y+1`。
  ![三次握手](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/v2-96858222f549bb65b122e4ea9481983f_r.2lclc3qduog0.webp)
* TCP四次挥手
  * 首先，客户端应用程序决定要终止连接(这里服务端也可以选择断开连接)。这会使客户端将`FIN`发送到服务器，并进入`FIN_WAIT_1`状态。当客户端处于`FIN_WAIT_1`状态时，它会等待来自服务器的`ACK`响应。
  * 然后第二步，当服务器收到`FIN`消息时，服务器会立刻向客户端发送`ACK`确认消息。
  * 当客户端收到服务器发送的`ACK`响应后，客户端就进入`FIN_WAIT_2`状态，然后等待来自服务器的`FIN`消息
  * 服务器发送`ACK`确认消息后，一段时间（可以进行关闭后）会发送`FIN`消息给客户端，告知客户端可以进行关闭。
  * 当客户端收到从服务端发送的`FIN`消息时，客户端就会由`FIN_WAIT_2`状态变为`TIME_WAIT`状态。处于`TIME_WAIT`状态的客户端允许重新发送`ACK`到服务器为了防止信息丢失。客户端在`TIME_WAIT`状态下花费的时间取决于它的实现，在等待一段时间后，连接关闭，客户端上所有的资源都被释放。
  ![四次挥手](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/v2-16f1d27692320d9f60ba43aa4108e8ca_r.7jezr6u3a140.webp)
### HTTP协议
* `HTTP`是一种`超文本传输协议`(Hypertext Transfer Protocol)，基于`TCP`协议，是`无状态协议`
* 常见方法
  * `GET`：GET方法一般用于请求，比如你在浏览器地址栏输入的链接其实就是发送了一个GET请求
  * `POST`
  * `PUT`
  * `DELETE`
  * `OPTIONS`
* 常见状态码
  * 200：`OK`，请求成功。一般用于GET与POST请求
  * 301：`Moved Permanently`，永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
  * 302：`Found`，临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
  * 304：`Not Modified`，未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
  * 307：`Temporary` Redirect，临时重定向。与302类似。使用GET请求重定向
  * 308：`Permanent Redirect`，永久重定向。说明请求的资源已经被永久的移动到了由`Location`首部指定的`URL`上。浏览器会进行重定向，同时搜索引擎也会更新其链接
  * 400：`Bad Request`，客户端请求的语法错误，服务器无法理解
  * 401：`Unauthorized`，请求要求用户的身份认证
  * 404：`Not Found`，服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
  * 406：`Not Acceptable`，服务器无法根据客户端请求的内容特性完成请求
  * 500：`Internal Server Error`，服务器内部错误，无法完成请求
  * 502：`Bad Gateway`，作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
  * 504：`Gateway Time-out`，充当网关或代理的服务器，未及时从远端服务器获取请求
* HTTP/1.1
  * 默认使用`长连接`，`长连接`就是只需一次建立就可以传输多次数据，传输完成后，只需要一次切断连接即可。`长连接`的连接时长可以通过请求头中的`Connection: keep-alive`来设置
  * 中新增加了`E-tag`，`If-Unmodified-Since`, `If-Match`, `If-None-Match` 等`缓存控制标头`来控制缓存失效。
  * 支持`断点续传`，通过使用请求头中的`Range`来实现。
* HTTP/2
  * `头部压缩`：`HTTP/2`使用`HPACK`算法进行压缩。
  * `二进制分帧`：`HTTP/2`使用了更加靠近`TCP/IP`的二进制格式，而抛弃了ASCII码，提升了解析效率
  * `多路复用`：即每一个请求都是是用作连接共享。一个请求对应一个id，这样一个连接上可以有多个请求。
  * `强化安全`：由于安全已经成为重中之重，所以`HTTP/2`一般都跑在`HTTPS`上。
* HTTP/3
  * QUIC 协议：主要为了解决`HTTP/2`中存在的`队头阻塞`问题。由于`HTTP/2`在单个TCP连接上使用了`多路复用`，受到`TCP拥塞控制`的影响，少量的丢包就可能导致整个`TCP`连接上的所有流被阻塞。
* HTTPS
  * `HTTPS`的握手过程，其实就是`SSL/TLS`的握手过程。
  * `TLS`握手是启动和使用`TLS加密`的通信会话的过程。在`TLS握手`期间，`Internet`中的通信双方会彼此`交换信息`，`验证密码套件`，`交换会话密钥`。
  * 每当用户通过`HTTPS`导航到具体的网站并发送请求时，就会进行`TLS握手`。除此之外，每当其他任何通信使用`HTTPS`（包括API调用和在`HTTPS`上查询`DNS`）时，也会发生TLS握手。
  * `TLS`通讯流程：
    * 在进行通信前，首先会进行`HTTP`的`三次握手`，握手完成后，再进行TLS的握手过程
    * `ClientHello`：客户端通过向服务器发送`hello`消息来发起握手过程。这个消息中会夹带着客户端支持的`TLS版本号`(TLS1.0 、TLS1.2、TLS1.3)、客户端支持的`密码套件`、以及一串`客户端随机数`。
    * `ServerHello`：在客户端发送`hello`消息后，服务器会发送一条消息，这条消息包含了服务器的`SSL证书`、服务器选择的`密码套件`和服务器生成的`随机数`。
    * `认证(Authentication)`：客户端的证书颁发机构会`认证SSL证书`，然后发送`Certificate`报文，报文中包含`公开密钥`证书。最后服务器发送`ServerHelloDone`作为hello请求的响应。第一部分握手阶段结束。
    * `加密阶段`：在第一个阶段握手完成后，客户端会发送`ClientKeyExchange`作为响应，这个响应中包含了一种称为`The premaster secret`的密钥字符串，这个字符串就是使用上面`公开密钥证书`进行加密的字符串。随后客户端会发送`ChangeCipherSpec`，告诉服务端使用`私钥解密`这个`The premaster secret`的字符串，然后客户端发送`Finished`告诉服务端自己发送完成了。
    * 实现了安全的`非对称加密`：然后，服务器再发送`ChangeCipherSpec`和`Finished`告诉客户端解密完成，至此实现了`RSA的非对称加密`。
    ![TLS通讯流程](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/v2-18f480a3c81a3313c8c312772884eece_r.34ageujsauc0.webp)
  ![HTTPS](https://cdn.jsdelivr.net/gh/artoriaschan/image-hosting@master/blog/v2-2295aa8205ce9d03782cf88e8548ec5e_r.56dncwmk16o0.webp)
* HTTP缓存策略
  * 
  * 
### DNS协议

## 浏览器
### 常见概念
* 重绘和回流(重排)
  * 回流(重排)
    * `回流`又名`重排`，指`几何属性`需改变的渲染。
    * `渲染树`的节点发生改变，影响了该节点的`几何属性`，导致该节点位置发生变化，此时就会触发浏览器`回流`并重新生成`渲染树`。
    * `回流`意味着节点的`几何属性`改变，需重新计算并生成`渲染树`，导致`渲染树`的全部或部分发生变化。
  * 重绘
    * `重绘`指更改`外观属性`而不影响`几何属性`的渲染。
    * `渲染树`的节点发生改变，但不影响该节点的`几何属性`。由此可见，`回流`对浏览器性能的消耗是高于`重绘`的，而且`回流`一定会伴随`重绘`，`重绘`却不一定伴随`回流`。
  * 如何减少回流和重绘
    * 使用`visibility:hidden`替换`display:none`
    * 使用`transform`代替`top`
    * 避免使用`Table`布局
    * 避免规则`层级过多`
    * 避免节点属性值放在循环里当成循环变量
    * 动态改变类而不改变样式
* 同源策略
  * `同源策略`是一个重要的`安全策略`，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。
  * 如果两个`URL`的`protocol`、`port`和`host`都相同的话，则这两个`URL`是同源。
  * `同源策略`限制的内容有：
    * `Cookie`、`LocalStorage`、`IndexedDB`等存储性内容
    * `DOM节点`
    * `AJAX`请求发送后，结果被浏览器拦截了
  * 但是有三个标签是允许跨域加载资源：
    * `<img src=XXX>`
    * `<link href=XXX>`
    * `<script src=XXX>`
  * 如何解决跨域
    * `JSONP`
    * `CORS`, 通过设置`Access-Control-Allow-Origin`请求头
      *  根据请求方法和携带参数的不同又分为`简单请求`和`非简单请求`，`非简单请求`需要发出`OPTIONS预请求`
    * `document.domain`，只适用于`二级域名`相同的情况下
    * `window.name`，即在一个窗口的生命周期内，窗口载入的所有的页面都是共享一个`window.name`
    * `postMessage`
    ```html
    // a.html
    <iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()">
    <!-- 等它加载完触发一个事件 -->
    </iframe> 
    <!-- 内嵌在http://localhost:3000/a.html -->
    <script>
      function load() {
        let frame = document.getElementById('frame')
        frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据
        window.onmessage = function(e) { //接受返回数据
          console.log(e.data) //我不爱你
        }
      }
    </script>
    <!-- http://localhost:4000/b.html -->
    <script>
      window.onmessage = function(e) {
        console.log(e.data) //我爱你
        e.source.postMessage('我不爱你', e.origin)
    }
    </script>
    ```
### 渲染流程
### V8

## 框架
### Vue
### React

## 工程化
### 编译工具
### 打包工具
### bundleless

## 性能优化
### 网络优化
### 体积优化
### 加载优化
### 代码优化

## Node.js
### 基本概念及原理
### 常用模块
### Web 框架
* Koa
* egg.js
