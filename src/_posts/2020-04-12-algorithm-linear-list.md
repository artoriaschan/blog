---
title: 算法与数据结构
subtitle: 线性表结构及算法
date: 2020-04-12
tags:
  - algorithm
  - data structure
author: ArtoriasChan
location: Beijing  
---
## 数组
`数组`（Array）是一种 `线性表` 数据结构。它用一组 `连续` 的内存空间，来存储一组具有 `相同类型` 的数据。

数组的特点如下：
* 线性表
  * 同样属于 `线性表` 的有： `链表` 、 `栈` 和 `队列`
  * 属于 `非线性表` 的有： `树` 、 `图` 等
* **连续的内存空间和相同类型的数据**

数组有了如上这些特点之后，才造就了数组的 `随机访问` 特性。但有利就有弊，这两个限制也让数组的很多操作变得非常 `低效` ，比如要想在数组中 `删除` 、 `插入` 一个数据，为了保证 `连续性` ，就需要做大量的 `数据搬移` 工作。

这里需要注意一下，数组是适合 `查找` 操作，但是查找的时间复杂度并不为 $O(1)$ 。即便是排好序的数组，你用 `二分查找` ，时间复杂度也是 $O(logn)$ 。所以，正确的表述应该是，数组支持 `随机访问` ，根据下标 `随机访问` 的 `时间复杂度` 为 $O(1)$。

### 低效的插入和删除
#### 1、插入操作
假设数组的长度为 $n$，现在，如果我们需要将一个数据插入到数组中的第 $k$ 个位置。

如果在数组的 `末尾` 插入元素，那就不需要移动数据了，这时的时间复杂度为 $O(1)$ 。

但如果 在数组的 `开头` 插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 $O(n)$ 。

因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 $\frac{(1 + 2 +\cdots+n)}{n} = O(n)$。

如果数组中的数据是 `有序` 的，我们在某个位置 `插入` 一个新的元素时，就必须按照刚才的方法 `搬移` $k$ 之后的数据。

但是，如果数组中存储的数据并 `没有` 任何规律，数组只是被当作一个 `存储数据` 的 `集合` 。在这种情况下，如果要将某个数组插入到第 $k$ 个位置，为了避免 `大规模` 的数据 `搬移` ，我们还有一个简单的办法就是，直接将第 $k$ 位的数据搬移到数组元素的 `尾部` ，把 `新的元素` 直接放入第 $k$ 个位置。

利用这种处理技巧，在 `特定场景` 下，在第 $k$ 个位置插入一个元素的 `时间复杂度` 就会降为 $O(1)$ 。这个处理思想在 `快速排序` 中也会用到。
#### 2、删除操作
跟 `插入数据` 类似，如果我们要删除第 $k$ 个位置的数据，为了内存的 `连续性` ，也需要 `搬移数据` ，不然中间就会出现空洞，内存就 `不连续` 了。

和 `插入` 类似，如果删除数组 `末尾` 的数据，则 `最好情况时间复杂度` 为 $O(1)$；如果删除 `开头` 的数据，则 `最坏情况时间复杂度` 为 $O(n)$； `平均情况时间复杂度` 也为 $O(n)$。

实际上，在某些 `特殊场景` 下，我们并不一定非得追求数组中数据的 `连续性` 。如果我们将多次 `删除` 操作 `合并` ，一并执行。其实就是 JVM 标记清除垃圾回收算法的核心思想。
### 警惕数组的访问越界问题
目前越来越多的语言都会做数组访问 `越界检查` ，这部分就不在展开讲述。
### 容器能否完全替代数组？
针对数组类型，很多语言都提供了 `容器类` ，比如 `Java` 中的 `ArrayList` 、 `C++ STL` 中的 `vector` 。

这些 `容器类` 可以将很多数组操作的细节 `封装` 起来，并且还有另外一个优势，就是支持 `动态扩容` 。

但是我们需要清楚的一点是， `扩容` 逻辑实现的核心是**语言底层根据当前数组大小动态的申请更大的数组空间**。这也就导致了 `扩容` 操作涉及 `内存申请` 和 `数据搬移` ，是比较耗时的。

所以，如果事先能确定需要存储的数据大小，最好在创建 `容器类` 的时候事先指定 `数据大小` 。

那么这里我们总结一下：
* 对于业务开发，直接使用 `容器` 就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。
* 但如果你是做一些非常底层的开发，比如开发网络框架，性能的 `优化` 需要做到极致，这个时候数组就会优于容器，成为首选。
### 总结
数组是最基础、最简单的数据结构。

数组用一块 `连续` 的内存空间，来存储相同类型的一组数据，最大的特点就是支持 `随机访问` ，但 `插入` 、 `删除` 操作也因此变得比较低效，平均情况时间复杂度为 $O(n)$ 。

在平时的业务开发中，我们可以直接使用编程语言提供的 `容器类` ，但是，如果是特别 `底层` 的开发，直接使用 `数组` 可能会更合适。
## 链表
从底层的 `存储结构` 来看， `数组` 需要一块 `连续` 的内存空间来存储，对内存的要求比较高；而 `链表` 恰恰相反，它并 `不需要` 一块 `连续` 的内存空间，它通过 `指针` 将一组 `零散` 的内存块串联起来使用，对内存空间的要求没有数组高。
### 单链表
`链表` 通过 `指针` 将一组零散的内存块 `串联` 在一起。其中，我们把内存块称为链表的 `结点` 。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的 `下一个结点` 的 `地址` 。我们把这个记录下个结点地址的 `指针` 叫作 `后继指针 next` 。
![simple-linked-list](~@assets/posts/algorithm-linear-list/simple-linked-list.png)

从单链表图中，可以看到，其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作 `头结点` ，把最后一个结点叫作 `尾结点` 。

其中， `头结点` 用来记录链表的 `基地址` 。而 `尾结点` 特殊的地方是：指针不是指向下一个结点，而是指向一个 `空地址 NULL` ，表示这是链表上最后一个结点。

与数组一样，链表也支持数据的 `查找` 、 `插入` 和 `删除` 操作。

我们知道，在进行数组的 `插入` 、 `删除` 操作时，为了保持内存数据的 `连续性` ，需要做大量的 `数据搬移` ，所以 `时间复杂度` 是 $O(n)$。

而在 `链表` 中 `插入` 或者 `删除` 一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就是 `不连续` 的。所以，在链表中 `插入` 和 `删除` 一个数据是非常快速的。对应的 `时间复杂度` 是 $O(1)$。
![simple-linked-list-insert-and-delete](~@assets/posts/algorithm-linear-list/simple-linked-list-insert-and-delete.png)

但是，有利就有弊。链表要想随机访问第 $k$ 个元素，就没有数组那么高效了。

因为链表中的数据是 `非连续存储` 的，所以无法像数组那样，根据首地址和下标，通过 `寻址公式` 就能直接 `计算` 出对应的 `内存地址` ，而是需要根据指针一个结点一个结点地 `依次遍历` ，直到找到相应的结点。需要的时间复杂度是 $O(n)$ 。
### 循环链表
**循环链表是一种特殊的单链表**。实际上，循环链表也很简单。它跟单链表唯一的区别就在 `尾结点` 。

单链表的 `尾结点` 指针指向 `空地址` ，表示这就是最后的结点了。而循环链表的 `尾结点` 指针是指向链表的 `头结点` 。它像一个环一样 `首尾相连` ，所以叫作 `循环链表` 。
![circular-linked-list](~@assets/posts/algorithm-linear-list/circular-linked-list.png)

和单链表相比， `循环链表` 的优点是从链尾到链头比较方便。当要处理的数据具有 `环型结构` 特点时，就特别适合采用 `循环链表` 。比如著名的 [约瑟夫问题](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98) 。
### 双向链表
单向链表只有一个方向，结点只有一个 `后继指针 next` 指向后面的结点。而双向链表，顾名思义，它支持 `两个` 方向，每个结点不止有一个 `后继指针 next` 指向后面的结点，还有一个 `前驱指针 prev` 指向前面的结点。
![double-linked-list](~@assets/posts/algorithm-linear-list/double-linked-list.png)

`双向链表` 需要额外的两个空间来存储 `后继结点` 和 `前驱结点` 的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。

虽然两个指针占用 `更多存储空间` ，但可以支持 `双向遍历` ，这样也带来了双向链表操作的 `灵活性` 。

从结构上来看， `双向链表` 可以支持 $O(1)$ `时间复杂度` 的情况下找到 `前驱结点` 。

之前将单链表的 `插入` 、 `删除` 操作的时间复杂度已经是 $O(1)$ ，双向链表还能再怎么高效呢？其实这种说法实际上是不准确的，或者说是有 `先决条件` 的。我们先分析一下链表的 `插入` 和 `删除` 这两个操作。
#### 1、删除操作
在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：
* 删除结点中 `给定值` 的结点 (这里的 `给定值` 表示链表中的值等于给定的值)
* 删除 `给定指针` 指向的结点

对于第一种情况，不管是 `单链表` 还是 `双向链表` ，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次 `遍历` 对比，直到找到值等于给定值的结点，然后再通过我前面讲的 `指针操作` 将其删除。

尽管单纯的 `删除操作` 时间复杂度是 $O(1)$，但 `遍历查找` 的时间是主要的耗时点，对应的 `时间复杂度` 为 $O(n)$ 。根据 `时间复杂度` 分析中的 `加法法则` ，删除值等于给定值的结点对应的链表操作的 `总时间复杂度` 为 $O(n)$ 。

对于第二种情况，我们已经 `找到` 要删除的结点，但是删除某个结点 `q` 需要知道其 `前驱结点` ，而 `单链表` 并不支持 `直接` 获取 `前驱结点` ，所以，为了找到 `前驱结点` ，我们还是要从头结点开始 `遍历` 链表，直到 `p.next === q`，说明 `p` 是 `q` 的 `前驱结点` 。所以 `单链表` 操作的 `总时间复杂度` 为 $O(n)$ 。

对于 `双向链表` 来说，第二种情况就比较有 `优势` 了。因为双向链表中的结点已经保存了 `前驱结点` 的指针，不需要像 `单链表` 那样 `遍历` 。所以 `双向链` 的 `时间复杂度` 为 $O(1)$ 。
#### 2、插入操作
同理，如果我们希望在链表的某个 `指定结点` 前面 `插入` 一个结点， `双向链表` 比 `单链表` 有很大的优势。 `双向链表` 可以在 $O(1)$ `时间复杂度` 搞定，而 `单链表` 需要 $O(n)$ 的 `时间复杂度` 。
### 双向循环链表
![double-circular-linked-list](~@assets/posts/algorithm-linear-list/double-circular-linked-list.png)
### 链表 VS 数组
| 时间复杂度 | 数组    | 链表   |
| :------: | :----: | :----: |
| 插入、删除 | $O(n)$ | $O(1)$ |
| 随机访问 | $O(1)$ | $O(n)$ |

不过， `数组` 和 `链表` 的对比，并不能局限于时间复杂度。

`数组` 简单易用，在实现上使用的是 `连续` 的内存空间，可以借助 `CPU` 的缓存机制， `预读` 数组中的数据，所以 **访问效率更高** 。

`数组` 的缺点是 `大小固定` ，一经声明就要占用整块 `连续` 内存空间。 `链表` 本身没有大小的限制，天然地支持 `动态扩容` ，我觉得这也是它与 `数组` 最大的区别。
### 链表代码技巧
#### 1、理解指针或引用的含义
将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针。

或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。
#### 2、警惕指针丢失和内存泄漏
比如有如下图的插入操作：
![linked-list-insert](~@assets/posts/algorithm-linear-list/linked-list-insert.png)
很自然的写出了如下的代码：
```javascript
p.next = x; // 将 p 的 next 指针指向 x 结点
x.next = p.next; // 将 x 的结点的 next 指针指向 b 结点
```
而这样维护链表指针，则会导致链表断裂。

所以我们编写插入结点代码时，一定要注意操作的顺序，要先将 `结点 x` 的 `next 指针` 指向 `结点 b` ，再把 `结点 a` 的 `next 指针` 指向 `结点 x` ，这样才不会丢失指针，导致内存泄漏。
```javascript
x.next = p.next;
p.next = x;
```
#### 3、利用哨兵简化实现难度
一般我们在 `单链表` 中 `插入` 节点时，只需要两行代码：
```javascript
newNode.next = p.next;
p.next = newNode;
```
但是，当我们要向一个 `空链表` 中插入 `第一个结点` ，刚刚的逻辑就不能用了。所以我们对这种情况只能单独处理：
```javascript
if(head === null) {
  head = newNode;
}
```
我们再来看 `单链表` 结点 `删除` 操作。如果要删除 `结点 p` 的 `后继结点` ，我们只需要一行代码就可以搞定：
```javascript
p.next = p.next.next;
```
但是，如果我们要删除链表中的最后一个结点，前面的删除代码就不 work 了。所以我们对这种情况只能单独处理：
```javascript
if(head.next === null) {
  head = null;
}
```
我们由上面的情况可以得出：**针对链表的插入、删除操作，需要对插入第一个结 点和删除最后一个结点的情况进行特殊处理**。

这是就需要引入我们的 `哨兵节点` 了。如果我们引入 `哨兵结点` ，在任何时候，不管链表是不是空，`head 指针` 都会一直指向这个 `哨兵结点` 。我们也把这种有 `哨兵结点` 的链表叫 `带头链表` 。
![sentinel-node](~@assets/posts/algorithm-linear-list/sentinel-node.png)
#### 4、重点留意边界条件处理
经常用来检查链表代码是否正确的边界条件有这样几个：
* 如果链表为 `空` 时，代码是否能正常工作？
* 如果链表只包含 `一个结点` 时，代码是否能正常工作？
* 如果链表只包含 `两个结点` 时，代码是否能正常工作？
* 代码逻辑在处理 `头结点` 和 `尾结点` 的时候，是否能正常工作？
#### 5、举例画图，辅助思考
#### 6、多写多练，没有捷径
### 总结
`链表` 也是非常基础、非常常用的 `数据结构` 。不过 `链表` 要比 `数组` 稍微复杂，从普通的 `单链表` 衍生出来好几种链表结构，比如 `双向链表` 、 `循环链表` 、 `双向循环链表` 。

`链表` 和 `数组` 相比， `链表` 更适合 `插入` 、 `删除` 操作频繁的场景， `查询` 的时间复杂度较高。
## 栈
## 队列