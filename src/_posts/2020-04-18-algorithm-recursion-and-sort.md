---
title: 算法与数据结构
subtitle: 递归及排序
date: 2020-04-18
tags:
  - algorithm
  - data structure
author: ArtoriasChan
location: Beijing  
---
## 递归
`递归` 是一种应用非常广泛的算法（或者编程技巧）。之后我们要讲的很多数据结构和算法的编码实现都要用到递归，比如 `DFS 深度优先搜索` 、 `前中后序二叉树遍历` 等等。
### 递归需要满足的三个条件
那究竟什么样的问题可以用递归来解决呢？我总结了三个条件，只要同时满足以下三个条件，就可以用递归来解决。
* 1、一个问题的解可以分解为几个子问题的解
* 2、这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样  
* 3、存在递归终止条件
### 如何编写递归代码
写 `递归` 代码最关键的是 **写出递推公式，找到终止条件**，剩下将 `递推公式` 转化为代码就很简单了。注意，这里是两个步骤。

我们根据一个例子来讲解：假如这里有 `n` 个台阶，每次你可以跨 `1` 个台阶或者 `2` 个台阶，请问走这 `n` 个台阶有多少种走法？

我们仔细想下，实际上，可以根据`第一步的走法`把所有走法分为两类：
* 第一类是第一步走了 `1` 个台阶
* 另一类是第一步走了 `2` 个台阶

所以 `n` 个台阶的走法就等于先走 `1` 阶后，`n - 1` 个台阶的走法加上先走 `2` 阶后，`n - 2` 个台阶的走法。

用公式表示就是：$f(n) = f(n - 1) + f(n - 2)$ 。有了**递推公式**，递归代码基本上就完成了一半。

我们再来看下终止条件：当有一个台阶时， 我们不需要再继续递归，就只有一种走法。所以 $f(1) = 1$ 。又因为每次可以走 2 个台阶，所以 $f(2) = 2$。

我们把递归 终止条件 和刚刚得到的 递推公式 放到一起就是这样的：

$f(1) = 1$

$f(2) = 2$

$f(n) = f(n - 1) + f(n - 2)$

有了这个公式，我们转化成递归代码就简单多了。最终的递归代码是这样的：
```javascript
function f(n) {
  if(n === 1) return 1;
  if(n === 2) return 2;
  return f(n - 1) + f(n - 2)
}
```
总结一下，**写递归代码的关键就是找到如何将大问题 `分解` 为小问题的规律，并且基于此写出 `递推公式` ，然后再推敲 `终止条件` ，最后将 `递推公式` 和 `终止条件` 翻译成代码**。

另外编写递归代码的关键是：**只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤**。
### 递归代码要警惕堆栈溢出
`函数调用` 会使用 `栈` 来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧 `压入` 内存栈，等函数执行完成返回时，才出栈。

系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据 `规模很大` ，调用层次很深，一直压入栈，就会有 `堆栈溢出` 的风险。

遇到这种情况可以使用 `尾递归` 优化。

`尾递归` 优化主要是对 `栈内存空间` 的优化, 这个优化是 $O(n)$ 到 $O(1)$ 的；至于 `时间` 的优化，其实是由于对空间的优化导致内存分配的工作减少所产生的，是一个常数优化，不会带来质的变化。

我们将上面的例子的代码改成 `尾递归` 形式：
```javascript
function f(n) {
    function cs(n, ret1, ret2) {
        // 递到底了
        if(n === 0){
            return ret1;
        }
        return cs(n - 1, ret2, ret1 + ret2);
    }
    return cs(n, 1, 1);
};
```
### 递归代码要警惕重复计算
除此之外，使用 `递归` 时还会出现 `重复计算` 的问题。

为了避免重复计算，我们可以通过一个 `数据结构` （比如散列表）来保存已经 `求解过` 的 $f(k)$ 。 

当递归调用到 $f(k)$ 时，先看下是否已经求解过了。

如果是，则直接从 `散列表` 中取值返回，不需要重复计算，这样就能避免刚讲的问题了。

按照上面的思路，我们来改造一下刚才的代码：
```javascript
function f(n) {
  if(n === 1) return 1;
  if(n === 2) return 2;
  if (hasSolvedList.has(n)) { 
    return hasSovledList.get(n); 
  }
  let ret = f(n - 1) + f(n - 2);
  hasSovledList.set(n, ret);
  return ret;
}
```
### 将递归代码改写为非递归代码
`递归` 有利有弊，利是递归代码的表达力很强，写起来非常 `简洁` ；而弊就是 `空间复杂度` 高、有 `堆栈溢出` 的风险、存在 `重复计算` 、过多的函数调用会 `耗时较多` 等问题。

我们可以将上面的例子用非递归的方式实现：
```javascript
function f(n) {
  if(n === 1) return 1;
  if(n === 2) return 2;

  let ret = 0;
  let pre = 2;
  let prepre = 1;
  for(let i = 3; i <= n; i ++) {
    ret = pre + prepre;
    prepre = pre;
    pre = ret;
  }
  return ret;
}
```
因为递归本身就是借助 `栈` 来实现的，只不过我们使用的 `栈` 是 `系统或者虚拟机` 本身提供的，我们没有感知罢了。

如果我们自己在内存堆上实现 `栈` ，手动模拟 `入栈` 、 `出栈` 过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。

但是这种思路实际上是将递归改为了 `手动` 递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。
## 排序
### 冒泡排序
### 插入排序
### 选择排序
### 归并排序
### 快速排序
### 桶排序
### 计数排序
### 基数排序
### 快速排序优化