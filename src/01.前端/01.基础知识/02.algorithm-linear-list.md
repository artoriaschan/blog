---
title: 算法与数据结构
subtitle: 线性表结构及算法
date: 2020-04-12 00:00:00
permalink: /pages/fabf80/
sidebar: auto
categories: 
  - 基础知识
tags: 
  - Algorithm
  - Data Structure
---
## 数组
`数组`（Array）是一种 `线性表` 数据结构。它用一组 `连续` 的内存空间，来存储一组具有 `相同类型` 的数据。

数组的特点如下：
* 线性表
  * 同样属于 `线性表` 的有： `链表` 、 `栈` 和 `队列`
  * 属于 `非线性表` 的有： `树` 、 `图` 等
* **连续的内存空间和相同类型的数据**

数组有了如上这些特点之后，才造就了数组的 `随机访问` 特性。但有利就有弊，这两个限制也让数组的很多操作变得非常 `低效` ，比如要想在数组中 `删除` 、 `插入` 一个数据，为了保证 `连续性` ，就需要做大量的 `数据搬移` 工作。

这里需要注意一下，数组是适合 `查找` 操作，但是查找的时间复杂度并不为 $O(1)$ 。即便是排好序的数组，你用 `二分查找` ，时间复杂度也是 $O(logn)$ 。所以，正确的表述应该是，数组支持 `随机访问` ，根据下标 `随机访问` 的 `时间复杂度` 为 $O(1)$。

### 低效的插入和删除
#### 1、插入操作
假设数组的长度为 $n$，现在，如果我们需要将一个数据插入到数组中的第 $k$ 个位置。

如果在数组的 `末尾` 插入元素，那就不需要移动数据了，这时的时间复杂度为 $O(1)$ 。

但如果 在数组的 `开头` 插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 $O(n)$ 。

因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 $\frac{(1 + 2 +\cdots+n)}{n} = O(n)$。

如果数组中的数据是 `有序` 的，我们在某个位置 `插入` 一个新的元素时，就必须按照刚才的方法 `搬移` $k$ 之后的数据。

但是，如果数组中存储的数据并 `没有` 任何规律，数组只是被当作一个 `存储数据` 的 `集合` 。在这种情况下，如果要将某个数组插入到第 $k$ 个位置，为了避免 `大规模` 的数据 `搬移` ，我们还有一个简单的办法就是，直接将第 $k$ 位的数据搬移到数组元素的 `尾部` ，把 `新的元素` 直接放入第 $k$ 个位置。

利用这种处理技巧，在 `特定场景` 下，在第 $k$ 个位置插入一个元素的 `时间复杂度` 就会降为 $O(1)$ 。这个处理思想在 `快速排序` 中也会用到。
#### 2、删除操作
跟 `插入数据` 类似，如果我们要删除第 $k$ 个位置的数据，为了内存的 `连续性` ，也需要 `搬移数据` ，不然中间就会出现空洞，内存就 `不连续` 了。

和 `插入` 类似，如果删除数组 `末尾` 的数据，则 `最好情况时间复杂度` 为 $O(1)$；如果删除 `开头` 的数据，则 `最坏情况时间复杂度` 为 $O(n)$； `平均情况时间复杂度` 也为 $O(n)$。

实际上，在某些 `特殊场景` 下，我们并不一定非得追求数组中数据的 `连续性` 。如果我们将多次 `删除` 操作 `合并` ，一并执行。其实就是 JVM 标记清除垃圾回收算法的核心思想。
### 警惕数组的访问越界问题
目前越来越多的语言都会做数组访问 `越界检查` ，这部分就不在展开讲述。
### 容器能否完全替代数组？
针对数组类型，很多语言都提供了 `容器类` ，比如 `Java` 中的 `ArrayList` 、 `C++ STL` 中的 `vector` 。

这些 `容器类` 可以将很多数组操作的细节 `封装` 起来，并且还有另外一个优势，就是支持 `动态扩容` 。

但是我们需要清楚的一点是， `扩容` 逻辑实现的核心是**语言底层根据当前数组大小动态的申请更大的数组空间**。这也就导致了 `扩容` 操作涉及 `内存申请` 和 `数据搬移` ，是比较耗时的。

所以，如果事先能确定需要存储的数据大小，最好在创建 `容器类` 的时候事先指定 `数据大小` 。

那么这里我们总结一下：
* 对于业务开发，直接使用 `容器` 就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。
* 但如果你是做一些非常底层的开发，比如开发网络框架，性能的 `优化` 需要做到极致，这个时候数组就会优于容器，成为首选。
### 总结
数组是最基础、最简单的数据结构。

数组用一块 `连续` 的内存空间，来存储相同类型的一组数据，最大的特点就是支持 `随机访问` ，但 `插入` 、 `删除` 操作也因此变得比较低效，平均情况时间复杂度为 $O(n)$ 。

在平时的业务开发中，我们可以直接使用编程语言提供的 `容器类` ，但是，如果是特别 `底层` 的开发，直接使用 `数组` 可能会更合适。
## 链表
从底层的 `存储结构` 来看， `数组` 需要一块 `连续` 的内存空间来存储，对内存的要求比较高；而 `链表` 恰恰相反，它并 `不需要` 一块 `连续` 的内存空间，它通过 `指针` 将一组 `零散` 的内存块串联起来使用，对内存空间的要求没有数组高。
### 单链表
`链表` 通过 `指针` 将一组零散的内存块 `串联` 在一起。其中，我们把内存块称为链表的 `结点` 。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的 `下一个结点` 的 `地址` 。我们把这个记录下个结点地址的 `指针` 叫作 `后继指针 next` 。
![simple-linked-list](~@assets/posts/algorithm-linear-list/simple-linked-list.png)

从单链表图中，可以看到，其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作 `头结点` ，把最后一个结点叫作 `尾结点` 。

其中， `头结点` 用来记录链表的 `基地址` 。而 `尾结点` 特殊的地方是：指针不是指向下一个结点，而是指向一个 `空地址 NULL` ，表示这是链表上最后一个结点。

与数组一样，链表也支持数据的 `查找` 、 `插入` 和 `删除` 操作。

我们知道，在进行数组的 `插入` 、 `删除` 操作时，为了保持内存数据的 `连续性` ，需要做大量的 `数据搬移` ，所以 `时间复杂度` 是 $O(n)$。

而在 `链表` 中 `插入` 或者 `删除` 一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就是 `不连续` 的。所以，在链表中 `插入` 和 `删除` 一个数据是非常快速的。对应的 `时间复杂度` 是 $O(1)$。
![simple-linked-list-insert-and-delete](~@assets/posts/algorithm-linear-list/simple-linked-list-insert-and-delete.png)

但是，有利就有弊。链表要想随机访问第 $k$ 个元素，就没有数组那么高效了。

因为链表中的数据是 `非连续存储` 的，所以无法像数组那样，根据首地址和下标，通过 `寻址公式` 就能直接 `计算` 出对应的 `内存地址` ，而是需要根据指针一个结点一个结点地 `依次遍历` ，直到找到相应的结点。需要的时间复杂度是 $O(n)$ 。
### 循环链表
**循环链表是一种特殊的单链表**。实际上，循环链表也很简单。它跟单链表唯一的区别就在 `尾结点` 。

单链表的 `尾结点` 指针指向 `空地址` ，表示这就是最后的结点了。而循环链表的 `尾结点` 指针是指向链表的 `头结点` 。它像一个环一样 `首尾相连` ，所以叫作 `循环链表` 。
![circular-linked-list](~@assets/posts/algorithm-linear-list/circular-linked-list.png)

和单链表相比， `循环链表` 的优点是从链尾到链头比较方便。当要处理的数据具有 `环型结构` 特点时，就特别适合采用 `循环链表` 。比如著名的 [约瑟夫问题](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98) 。
### 双向链表
单向链表只有一个方向，结点只有一个 `后继指针 next` 指向后面的结点。而双向链表，顾名思义，它支持 `两个` 方向，每个结点不止有一个 `后继指针 next` 指向后面的结点，还有一个 `前驱指针 prev` 指向前面的结点。
![double-linked-list](~@assets/posts/algorithm-linear-list/double-linked-list.png)

`双向链表` 需要额外的两个空间来存储 `后继结点` 和 `前驱结点` 的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。

虽然两个指针占用 `更多存储空间` ，但可以支持 `双向遍历` ，这样也带来了双向链表操作的 `灵活性` 。

从结构上来看， `双向链表` 可以支持 $O(1)$ `时间复杂度` 的情况下找到 `前驱结点` 。

之前将单链表的 `插入` 、 `删除` 操作的时间复杂度已经是 $O(1)$ ，双向链表还能再怎么高效呢？其实这种说法实际上是不准确的，或者说是有 `先决条件` 的。我们先分析一下链表的 `插入` 和 `删除` 这两个操作。
#### 1、删除操作
在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：
* 删除结点中 `给定值` 的结点 (这里的 `给定值` 表示链表中的值等于给定的值)
* 删除 `给定指针` 指向的结点

对于第一种情况，不管是 `单链表` 还是 `双向链表` ，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次 `遍历` 对比，直到找到值等于给定值的结点，然后再通过我前面讲的 `指针操作` 将其删除。

尽管单纯的 `删除操作` 时间复杂度是 $O(1)$，但 `遍历查找` 的时间是主要的耗时点，对应的 `时间复杂度` 为 $O(n)$ 。根据 `时间复杂度` 分析中的 `加法法则` ，删除值等于给定值的结点对应的链表操作的 `总时间复杂度` 为 $O(n)$ 。

对于第二种情况，我们已经 `找到` 要删除的结点，但是删除某个结点 `q` 需要知道其 `前驱结点` ，而 `单链表` 并不支持 `直接` 获取 `前驱结点` ，所以，为了找到 `前驱结点` ，我们还是要从头结点开始 `遍历` 链表，直到 `p.next === q`，说明 `p` 是 `q` 的 `前驱结点` 。所以 `单链表` 操作的 `总时间复杂度` 为 $O(n)$ 。

对于 `双向链表` 来说，第二种情况就比较有 `优势` 了。因为双向链表中的结点已经保存了 `前驱结点` 的指针，不需要像 `单链表` 那样 `遍历` 。所以 `双向链` 的 `时间复杂度` 为 $O(1)$ 。
#### 2、插入操作
同理，如果我们希望在链表的某个 `指定结点` 前面 `插入` 一个结点， `双向链表` 比 `单链表` 有很大的优势。 `双向链表` 可以在 $O(1)$ `时间复杂度` 搞定，而 `单链表` 需要 $O(n)$ 的 `时间复杂度` 。
### 双向循环链表
![double-circular-linked-list](~@assets/posts/algorithm-linear-list/double-circular-linked-list.png)
### 链表 VS 数组
| 时间复杂度 | 数组    | 链表   |
| :------: | :----: | :----: |
| 插入、删除 | $O(n)$ | $O(1)$ |
| 随机访问 | $O(1)$ | $O(n)$ |

不过， `数组` 和 `链表` 的对比，并不能局限于时间复杂度。

`数组` 简单易用，在实现上使用的是 `连续` 的内存空间，可以借助 `CPU` 的缓存机制， `预读` 数组中的数据，所以 **访问效率更高** 。

`数组` 的缺点是 `大小固定` ，一经声明就要占用整块 `连续` 内存空间。 `链表` 本身没有大小的限制，天然地支持 `动态扩容` ，我觉得这也是它与 `数组` 最大的区别。
### 链表代码技巧
#### 1、理解指针或引用的含义
将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针。

或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。
#### 2、警惕指针丢失和内存泄漏
比如有如下图的插入操作：
![linked-list-insert](~@assets/posts/algorithm-linear-list/linked-list-insert.png)
很自然的写出了如下的代码：
```javascript
p.next = x; // 将 p 的 next 指针指向 x 结点
x.next = p.next; // 将 x 的结点的 next 指针指向 b 结点
```
而这样维护链表指针，则会导致链表断裂。

所以我们编写插入结点代码时，一定要注意操作的顺序，要先将 `结点 x` 的 `next 指针` 指向 `结点 b` ，再把 `结点 a` 的 `next 指针` 指向 `结点 x` ，这样才不会丢失指针，导致内存泄漏。
```javascript
x.next = p.next;
p.next = x;
```
#### 3、利用哨兵简化实现难度
一般我们在 `单链表` 中 `插入` 节点时，只需要两行代码：
```javascript
newNode.next = p.next;
p.next = newNode;
```
但是，当我们要向一个 `空链表` 中插入 `第一个结点` ，刚刚的逻辑就不能用了。所以我们对这种情况只能单独处理：
```javascript
if(head === null) {
  head = newNode;
}
```
我们再来看 `单链表` 结点 `删除` 操作。如果要删除 `结点 p` 的 `后继结点` ，我们只需要一行代码就可以搞定：
```javascript
p.next = p.next.next;
```
但是，如果我们要删除链表中的最后一个结点，前面的删除代码就不 work 了。所以我们对这种情况只能单独处理：
```javascript
if(head.next === null) {
  head = null;
}
```
我们由上面的情况可以得出：**针对链表的插入、删除操作，需要对插入第一个结 点和删除最后一个结点的情况进行特殊处理**。

这是就需要引入我们的 `哨兵节点` 了。如果我们引入 `哨兵结点` ，在任何时候，不管链表是不是空，`head 指针` 都会一直指向这个 `哨兵结点` 。我们也把这种有 `哨兵结点` 的链表叫 `带头链表` 。
![sentinel-node](~@assets/posts/algorithm-linear-list/sentinel-node.png)
#### 4、重点留意边界条件处理
经常用来检查链表代码是否正确的边界条件有这样几个：
* 如果链表为 `空` 时，代码是否能正常工作？
* 如果链表只包含 `一个结点` 时，代码是否能正常工作？
* 如果链表只包含 `两个结点` 时，代码是否能正常工作？
* 代码逻辑在处理 `头结点` 和 `尾结点` 的时候，是否能正常工作？
#### 5、举例画图，辅助思考
#### 6、多写多练，没有捷径
### 总结
`链表` 也是非常基础、非常常用的 `数据结构` 。不过 `链表` 要比 `数组` 稍微复杂，从普通的 `单链表` 衍生出来好几种链表结构，比如 `双向链表` 、 `循环链表` 、 `双向循环链表` 。

`链表` 和 `数组` 相比， `链表` 更适合 `插入` 、 `删除` 操作频繁的场景， `查询` 的时间复杂度较高。
## 栈
后进者先出，先进者后出，这就是典型的`栈`结构。

从栈的 `操作特性` 上来看，**栈是一种 `操作受限` 的线性表**，只允许在一端插入和删除数据。

当某个数据集合只涉及在 `一端` 插入和删除数据，并且满足 `后进先出` 、 `先进后出` 的特性，我们就应该首选 `栈` 这种数据结构。
### 栈的实现
实际上， `栈` 既可以用 `数组` 来实现，也可以用 `链表` 来实现。用 `数组` 实现的栈，我们叫作 `顺序栈` ，用 `链表` 实现的栈，我们叫作 `链式栈` 。

下面我们用数组和链表分别来实现一个栈：
```javascript
// 数组
class ArrayStack {
  constructor() {
    this.content = [];
  }

  push(item) {
    this.content.push(item);
  }

  pop() {
    const item = this.content.pop();
    return item;
  }
}
// 链表
class LinkedListNode {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}
class LinkedListStack {
  constructor() {
    this.top = null;
  }

  push(item) {
    const node = new LinkedListNode(item);
    node.next = this.top;
    this.top = node;
  }

  pop() {
    if (this.top === null) return null;
    const item = this.top.data;
    this.top = this.top.next;
    return item;
  }
}
```
至于栈的空间复杂度和时间复杂度是什么？

不管是 `顺序栈` 还是 `链式栈` ，我们存储数据只需要一个大小为 `n` 的数组就够了。在 `入栈` 和 `出栈` 过程中，只需要一两个临时变量存储空间，所以 `空间复杂度` 是 $O(1)$。

不管是 `顺序栈` 还是 `链式栈` ， `入栈` 、 `出栈` 只涉及栈顶个别数据的操作，所以 `时间复杂度` 都是 $O(1)$。
### 动态扩容的顺序栈
如果要实现一个支持 `动态扩容` 的栈，我们只需要底层依赖一个支持 `动态扩容` 的数组就可以了。当栈空间满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。

那么对于支持 `动态扩容` 的顺序栈来说，他的时间复杂度又是多少呢？

对于 `出栈` 操作来说，我们不会涉及内存的重新申请和数据的搬移，所以 `出栈` 的 `时间复杂度` 仍然是 $O(1)$。

但是，对于 `入栈` 操作来说，情况就不一样了。当栈中有空闲空间时， `入栈` 操作的 `时间复杂度` 为 $O(1)$。但当空间不够时，就需要重新申请内存和数据搬移，所以 `时间复杂度` 就变成了 $O(n)$。

也就是说，对于 `入栈` 操作来说， `最好情况时间复杂度` 是 $O(1)$， `最坏情况时间复杂度` 是 $O(n)$。这个 `入栈` 操作的 `平均情况时间复杂度` 可以用 `摊还分析法` 来分析。

如果当前栈大小为 `K` ，并且已满，当再有新的数据要入栈时，就需要重新申请 `2` 倍大小的内存，并且做 `K` 个数据的搬移操作，然后再入栈。

但是，接下来的 `K - 1` 次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这 `K - 1` 次入栈操作都只需要一个 `simple-push` 操作就可以完成。

以此类推， `入栈` 操作的 `均摊时间复杂度` 就为 $O(1)$ 。

通过这个例子的实战分析，也印证了前面讲到的，**`均摊时间复杂度` 一般都等于 `最好情况时间复杂度`**。
### 栈的应用场景
#### 1、栈在函数调用中的应用
栈作为一个比较基础的数据结构，应用场景还是蛮多的。其中，比较经典的一个应用场景就是 `函数调用栈` 。
#### 2、栈在表达式求值中的应用
我们再来看栈的另一个常见的应用场景，编译器如何利用栈来实现 `表达式求值` 。

对于计算机来说，理解表达式本身就是个挺难的事儿。

实际上，编译器就是通过两个栈来实现的。其中一个保存 `操作数` 的栈，另一个是保存 `运算符` 的栈。我们从左向右遍历表达式，当遇到数字，我们就直接 `压入` 操作数栈；当遇到运算符，就与 `运算符栈` 的 `栈顶元素` 进行比较。
#### 3、栈在括号匹配中的应用
除了用栈来实现表达式求值，我们还可以借助栈来检查表达式中的括号是否匹配。

我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。

当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如 `(` 跟 `)` 匹配， `[` 跟 `]` 匹配， `{` 跟 `}` 匹配，则继续扫描剩下的字符串。

如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。
## 队列
`先进先出` ，这就是典型的 `队列` 。

`队列` 跟 `栈` 非常相似，支持的操作也很有限，最基本的操作也是两个： `入队(enqueue)` ，放一个数据到队列尾部； `出队(dequeue)` ，从队列头部取一个元素。

所以，队列跟栈一样，也是 **一种操作受限的线性表数据结构** 。
### 顺序队列和链式队列
跟 `栈` 一样， `队列` 可以用 `数组` 来实现，也可以用 `链表` 来实现。

用 `数组` 实现的`栈`叫作 `顺序栈` ，用 `链表` 实现的`栈`叫作 `链式栈` 。

同样，用 `数组` 实现的 `队列` 叫作**顺序队列**，用 `链表` 实现的 `队列` 叫作**链式队列** 。

下面我们来实现 `顺序队列` 和 `链式队列` ：
```javascript
// 数组实现
class ArrayQueue {
  constructor() {
    this.content = [];
  }

  enqueue(item) {
    this.content.push(item);
  }

  dequeue() {
    const item = this.content.shift();
    return item;
  }
}
// 链表实现
class LinkedListNode {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedListQueue {
  constructor() {
    this.head = null;
    this.tail = null;
  }

  enqueue(item) {
    const node = new LinkedListNode(item);
    if (this.head === null) {
      this.tail = node;
      this.head = node;
    } else {
      this.tail.next = node;
      this.tail = this.tail.next;
    }
  }

  dequeue() {
    if (this.head === null) return null;
    const item = this.head.data;
    this.head = this.head.next;
    return item;
  }
}
```
对于 `栈` 来说，我们只需要一个 `栈顶指针` 就可以了。但是队列需要两个指针：一个是 `head 指针` ，指向队头；一个是 `tail 指针` ，指向队尾。

当然基于 `数组` 实现的 `队列` 有一些缺陷。随着不停地进行 `入队` 、 `出队` 操作， `head` 和 `tail` 都会持续往后移动。当 `tail` 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。

当然我们可以通过 **数据搬移** ，来解决这个问题。但是，每次进行 `出队` 操作都相当于删除数组下标为 `0` 的数据，要搬移整个队列中的数据，这样出队操作的 `时间复杂度` 就会从原来的 $O(1)$ 变为 $O(n)$。

实际上，我们在 `出队` 时可以不用 **搬移数据** 。如果没有空闲空间了，我们只需要在 `入队` 时，再集中触发一次数据的搬移操作。这种实现思路中， `出队` 操作的 `时间复杂度` 仍然是 $O(1)$ ，根据 `摊还分析` ， `入队` 操作的 `时间复杂度` 还是 $O(1)$ 。
### 循环队列
我们刚才用 `数组` 来实现 `队列` 的时候，在 `tail === n` 时，会有数据搬移操作，这样 `入队` 操作性能就会受到影响。可以通过 `循环队列` 解决这个问题。

使用 `循环队列` 的关键点就是 **确定好队空和队满的判定条件** 。

`队列为空` 的判断条件仍然是 `head === tail`。但 `队列满` 的判断条件就稍微有点复杂了：当队满时，`(tail + 1) % n = head` 。

当队列满时，`tail 指针` 指向的位置实际上是没有存储数据的。所以， `循环队列` 会浪费一个数组的存储空间。因为若是这个空间也保存数据的话，就会导致 `head === tail` ，与 `队列为空` 的条件判断相冲突。
```javascript {24,36}
class CircularQueue {
  constructor(size = 3) {
    this.size = size;
    this.head = -1;
    this.tail = -1;
    this.content = [];
  }

  isEmpty() {
    return this.tail === -1 && this.head === -1;
  }

  isFull() {
    return (this.tail + 1) % this.size === this.head;
  }

  enqueue(item) {
    if (this.isFull()) {
      return false;
    }
    if (this.isEmpty()) {
      this.head = 0;
    }
    this.tail = (this.tail + 1) % this.size;
    this.content[this.tail] = item;
    return true;
  }

  dequeue() {
    if (!this.isEmpty()) {
      const item = this.content[this.head];
      if (this.tail === this.head) {
        this.tail = -1;
        this.head = -1;
      } else {
        this.head = (this.head + 1) % this.size;
      }
      return item;
    }
    return null;
  }
}
```
> 注意入队和出队时，`tail 指针` 和 `head 指针` 的变化。