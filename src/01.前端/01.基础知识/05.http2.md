---
title: HTTP/2
subtitle: 如何提升网络速度
date: 2020-11-20 00:00:00
permalink: /pages/bb867b/
sidebar: auto
categories: 
  - 基础知识
tags: 
  - HTTP/2
---
## 超文本传输协议 HTTP/0.9
首先我们来看看诞生最早的 `HTTP/0.9` 。

`HTTP/0.9` 是于 `1991` 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 `HTML` 超文本的内容，所以被称为**超文本传输协议**。

下面我们就来看看 `HTTP/0.9` 的一个完整的请求流程（可参考下图）。
![http0.9](~@assets/posts/http2/http0.9.png)

`HTTP/0.9` 的实现有以下三个特点：
* 只有一个请求行，并没有 `HTTP` 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。
* 服务器也没有 `返回头` 信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。
* 返回的文件内容是以 `ASCII` 字符流来传输的，因为都是 `HTML` 格式的文件，所以使用 `ASCII` 字节码来传输是最合适的。
## 被浏览器推动的 HTTP/1.0
万维网的高速发展带来了很多新的需求，而 `HTTP/0.9` 已经不能适用新兴网络的发展，所以这时就需要一个新的协议来支撑新兴网络，这就是 `HTTP/1.0` 诞生的原因。

不过在详细分析 `HTTP/1.0` 之前，我们先来分析下新兴网络都带来了哪些新需求：
* 首先在浏览器中展示的不单是 `HTML` 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此**支持多种类型的文件下载**是 `HTTP/1.0` 的一个核心诉求。
* 而且文件格式不仅仅局限于 `ASCII` 编码，还有很多其他类型编码的文件。

`HTTP/1.0` 引入了 `请求头` 和 `响应头` ，它们都是以为 `Key-Value` 形式保存的，在 `HTTP` 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。

至于 `HTTP/1.0` 具体的请求流程，你可以参考下图：
![http1.0](~@assets/posts/http2/http1.0.png)

那 `HTTP/1.0` 是怎么通过请求头和响应头来支持多种不同类型的数据呢？
要支持多种类型的文件，我们就需要解决以下几个问题：
* 浏览器需要知道服务器返回的数据是什么 `类型` ，从而做针对性处理
* 为了减轻传输性能，服务器会对数据进行压缩后再传输，所以浏览器需要知道服务器 `压缩方法`
* 提供 `国际化` 的支持
* 需要知道不同类型文件的 `编码类型` 

基于以上问题，`HTTP/1.0` 的方案是通过请求头和响应头来进行协商。

在发起请求时候会通过 `HTTP` 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。

最终发送出来的请求头内容如下：
```sh
# 接受类型
accept: text/html
# 接受压缩方式
accept-encoding: gzip, deflate, br
# 接受字符编码
accept-Charset: ISO-8859-1,utf-8
# 期望页面的优先语言
accept-language: zh-CN,zh
```
最终浏览器需要根据 `响应头` 的信息来处理数据。下面是一段 `响应头` 的数据信息：
```sh
# 返回内容的压缩方式
content-encoding: br
# 返回文件类型及编码
content-type: text/html; charset=UTF-8
```
`HTTP/1.0` 除了对 `多文件` 提供良好的支持外，还依据当时实际的需求引入了很多其他的特性。

这些特性都是通过 `请求头` 和 `响应头` 来实现的。下面我们来看看新增的几个典型的特性：
* 引入了**状态码**。状态码 是通过 `响应行` 的方式来通知 `浏览器` 的。
* 在 `HTTP/1.0` 中提供了 `Cache` 机制，用来缓存已经下载过的数据。
* `HTTP/1.0` 的请求头中还加入了 `用户代理` 的字段。
## 缝缝补补的 HTTP/1.1
不过随着技术的继续发展，需求也在不断迭代更新，很快 `HTTP/1.0` 也不能满足需求了，所以 `HTTP/1.1` 又在 `HTTP/1.0` 的基础之上做了大量的更新。
### 1、改进持久连接
`HTTP/1.0` 每进行一次 `HTTP` 通信，都需要经历建立 `TCP` 连接、传输 `HTTP` 数据和断开 `TCP` 连接三个阶段。

随着浏览器普及，单个页面中的图片文件越来越多，有时候一个页面可能包含了几百个外部引用的资源文件，这样的传输方式会增加大量无谓的开销。

于是 `HTTP/1.1` 中增加了持久连接的方法，它的特点是在一个 `TCP` 连接上可以传输多个 `HTTP` 请求，只要浏览器或者服务器没有明确断开连接，那么该 `TCP` 连接会一直保持。

持久连接在 `HTTP/1.1` 中是默认开启的，所以你不需要专门为了持久连接去 `HTTP` 请求头设置信息。

如果你不想要采用持久连接，可以在 `HTTP` 请求头中加上 `Connection: close` 。

目前浏览器中对于 `同一个域名` ，默认允许同时建立 `6` 个 `TCP` 持久连接。
### 2、不成熟的 HTTP 管线化
持久连接虽然能减少 `TCP` 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。

如果 `TCP` 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的 **队头阻塞** 的问题。

`HTTP/1.1` 中试图通过管线化的技术来解决队头阻塞的问题。 `HTTP` 请求整批提交给服务器，不过服务器依然需要根据 `请求顺序` 来回复浏览器的请求。
### 3、提供虚拟主机的支持
在 `HTTP/1.0` 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。

`HTTP/1.1` 的请求头中增加了 `Host` 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 `Host` 值做不同的处理。
### 4、对动态生成的内容提供了完美支持
在设计 `HTTP/1.0` 时，需要在响应头中设置完整的数据大小，如 `Content-Length: 901` ，这样浏览器就可以根据设置的数据大小来接收数据。

`HTTP/1.1` 通过引入 `Chunk transfer` 机制来解决这个问题。

服务器会将数据 `分割` 成若干个任意大小的 `数据块` ，每个数据块发送时会附上上个数据块的长度，最后使用一个 `零长度` 的块作为 `发送数据完成` 的标志。这样就提供了对动态内容的支持。
### 5、客户端 Cookie、安全机制
``HTTP/1.1`` 还引入了客户端 `Cookie 机制` 和 `安全机制` 。
## HTTP/2
### HTTP/1.1 的主要问题
虽然 `HTTP/1.1` 采取了很多优化资源加载速度的策略，也取得了一定的效果。但是 `HTTP/1.1` 对**带宽的利用率却并不理想**，这也是 `HTTP/1.1` 的一个核心问题。因为 `HTTP/1.1` 很难将带宽用满。

之所以会出现这个问题，主要是由以下三个原因导致的：
* **TCP 的慢启动**

刚开始 `TCP` 协议会采用一个 `非常慢` 的速度去发送数据，然后 `慢慢加快` 发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为 `慢启动` 。

慢启动 是 `TCP` 为了 **减少网络拥塞** 的一种策略，我们是没有办法改变的。

但是 `慢启动` 会带来 `性能问题` ，因为 `慢启动` 会推迟宝贵的 `首次渲染` 页面的时长。

* **同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽**

多条 `TCP` 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。

* **HTTP/1.1 队头阻塞的问题**

`HTTP/1.1` 中使用持久连接时，虽然能公用一个 `TCP` 管道，但是在一个管道中 `同一时刻` 只能处理 `一个请求` ，在当前的请求没有结束之前，其他的请求只能处于 `阻塞状态` 。

`队头阻塞` 使得这些数据不能 `并行` 请求，所以 `队头阻塞` 是很不利于浏览器优化的。
### HTTP/2 的多路复用
`HTTP/1.1` 所存在的一些主要问题：
* `慢启动` 和 `TCP` 连接之间相互竞争带宽是由于 `TCP` 本身的机制导致的
* `队头阻塞` 是由于 `HTTP/1.1` 的机制导致的。

虽然 `TCP` 有问题，但是我们依然没有换掉 `TCP` 的能力，所以我们就要想办法去规避 `TCP` 的慢启动和 `TCP` 连接之间的竞争问题。

基于此，`HTTP/2` 的思路就是 `一个域名` 只使用一个 `TCP` 长连接来传输数据，这样整个页面资源的下载过程只需要 `一次慢启动` ，同时也避免了多个 `TCP` 连接竞争带宽所带来的问题。

另外，解决 `队头阻塞` 的问题，`HTTP/2` 需要实现资源的并行请求。

所以，`HTTP/2` 的解决方案可以总结为：**一个域名只使用一个 TCP 长连接和消除队头阻塞问题**。

![multiplexing](~@assets/posts/http2/multiplexing.png)

该图就是 `HTTP/2` 最核心、最重要且最具颠覆性的 **多路复用机制**。

`HTTP/2` 使用了 `多路复用` 技术，可以将请求分成 `一帧一帧` 的数据去传输，这样带来了一个额外的好处，就是当收到一个 `优先级高` 的请求时，比如接收到 `JavaScript` 或者 `CSS` 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。
### 多路复用的实现
![http2-protocol-stack](~@assets/posts/http2/http2-protocol-stack.png)

**HTTP/2 通过添加一个二进制分帧层，就实现了 HTTP 的多路复用技术**。

`二进制分帧层` 的流程如下：
* 将之前的请求数据，转换为一个个带有请求 `ID` 编号的帧，通过协议栈将这些帧发送给服务器。
* 服务器接收到所有帧之后，会将所有相同 `ID` 的帧合并为一条完整的请求信息。
* 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。
* 同样，二进制分帧层会将这些响应数据转换为一个个带有请求 `ID` 编号的帧，经过协议栈发送给浏览器。

可以从上面的流程看到，虽然 `HTTP/2` 引入了二进制分帧层，不过 `HTTP/2` 的语义和 `HTTP/1.1` 依然是一样的，也就是说它们通信的语言并没有改变。

这一点对开发者来说尤为重要，这意味着我们不需要为 `HTTP/2` 去重建生态，并且 `HTTP/2` 推广起来会也相对更轻松了。
### HTTP/2 其他特性
**1. 可以设置请求的优先级**

`HTTP/2` 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。

这样可以使得重要的请求，可以优先被服务器处理。

**2. 服务器推送**

`HTTP/2` 还可以直接将数据提前推送到浏览器。该特性可以使得服务器可以自主的根据用户请求连接 提前推送 相关的资源，这对首次打开页面的速度起到了至关重要的作用。

**3. 头部压缩**

`HTTP/2` 对请求头和响应头进行了压缩。其实在浏览器发送请求的时候，基本上都是发送 `HTTP` 请求头，很少有请求体的发送。

通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。