---
title: Vue 3.0 源码解读(二) - 响应式系统
date: 2020-12-29 00:00:00
tags: 
  - Vue
  - Vue 3.0
permalink: /pages/ca46c4/
sidebar: auto
categories: 
  - Vue 3 源码解析
---
## 前言
在 `Vue 2.x` 中，我们知道**响应式是 Vue 组件化更新渲染的一个核心机制**。

在介绍 `Vue 3.0` 响应式实现之前，我们先来回顾一下 `Vue 2.x` 响应式实现的部分：
* 它在内部通过 `Object.defineProperty API` 劫持数据的变化
* 在数据被访问的时候`收集依赖`
* 在数据被修改的时候`通知依赖更新`。

我们用一张图可以直观地看清这个流程。
![vue2-reactivity](~@assets/posts/vue3-source-reactivity/vue2-reactivity.png)

在 `Vue 2.x` 中， `Watcher` 就是依赖，有专门针对组件渲染的 `render watcher`。
注意这里有两个流程：
* 首先是`依赖收集`流程，组件在 `render` 的时候会访问模板中的数据，触发 `getter` 把 `render watcher` 作为依赖收集，并和数据建立联系
* 然后是`派发通知`流程，当我对这些数据修改的时候，会触发 `setter`，通知 `render watcher` 更新，进而触发了组件的重新渲染。

但是这边劫持数据使用的 `Object.defineProperty API` 有一些缺陷：
* 不能检测到对象属性的新增和删除
* 初始化阶段的递归执行劫持数据带来一定的性能负担

`Vue 3.0` 为了解决这些问题，摒弃了 `Object.defineProperty API` ，改用 `Proxy API` 来重构了响应式部分，下面我们来看一下 `Vue 3.0` 具体的实现细节。
## 响应式系统实现差异
在 `Vue 2.x` 中我们使用 `Options API` 来组织我们的代码，只要我们在 `data`、`props`、`computed` 中定义数据，那么它就是响应式的，举个例子：
```vue {9-13}
<template>
  <div>
    <p>{{ msg }}</p>
    <button @click="change">change msg</button>
  </div>
</template>
<script>
  export default {
    data() {
      return {
        msg: 'msg reactive'
      }
    },
    methods: {
      change() {
        this.msg = 'msg reactive!'
      }
    }
  }
</script>
```
上述例子在首次渲染时，会在页面上渲染 `"msg reactive"` ，如果当我们点击按钮后，`msg` 的值发生改变，进而页面重新渲染，并且展示为使我们修改后的 `msg` 值 。

但是如果我们模板部分不变，JS代码稍作一下的修改：
```vue
<script>
  export default {
    created(){
      this.msg = 'msg reactive'
    },
    methods: {
      change() {
        this.msg = 'msg reactive!'
      }
    }
  }
</script>
```
该例子在首次渲染时，也会在页面上渲染 `"msg reactive"` ，但是当我们点击按钮后，则不会发生页面的重新渲染。

根本原因是我们在 `created` 中定义的 `this.msg` 并不是响应式对象，所以 `Vue` 内部不会对它做额外的处理。

在 `Vue 2.x` 中，框架会约定俗成的将 `data`、`props`、`computed` 等组件选项变成响应式的数据。这个过程相对黑盒，用户无法感知和介入的过程。

所以在使用 `Vue 2.x` 时有些技巧我们可以使用，当我们组件模板依赖一些静态数据，那我们没有必要将其放入 `data` 中声明，可以在 `created` 声明周期钩子中绑定到 `this` 中。

因为声明响应式数据有性能开销，这样可以提升应用的执行效率。

而在 `Vue 3.0` 中虽然保留了 `Options API` 的开发范式，但是他为用户提供了一个新的基于 `Composition API` 的新范式。在 `Composition API` 范式中，用户可以自己手动的去创建一个响应式数据。

例如下面这个例子：
```vue {11-13}
<template>
  <div>
    <p>{{ msg }}</p>
    <button @click="change">change msg</button>
  </div>
</template>
<script>
  import { reactive } from 'vue'
  export default {
    setup() {
      const state = reactive({
        msg: 'msg reactive'
      })
      const change = function() {
        state.msg = 'msg reactive!'
      }
      return {
        random,
        state
      }
    }
  }
</script>
```
可以看出来 `Composition API` 更推荐用户主动定义响应式对象，而非内部的黑盒处理。这样用户可以更加明确哪些数据是响应式的，如果你不想让数据变成响应式，就定义成它的原始数据类型即可。
## Reactive API
我们先看一下 `reactive` 函数的具体代码实现：
```ts
// packages/reactivity/src/reactive.ts

export const enum ReactiveFlags {
  SKIP = '__v_skip',
  IS_REACTIVE = '__v_isReactive',
  IS_READONLY = '__v_isReadonly',
  RAW = '__v_raw'
}
// key 为原始对象，value 为代理对象
export const reactiveMap = new WeakMap<Target, any>()
// ...
export function reactive<T extends object>(target: T): UnwrapNestedRefs<T>
export function reactive(target: object) {
  // 判断如果是 readonly proxy，则直接返回该对象。
  if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {
    return target
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers
  )
}

function createReactiveObject(
  target: Target,
  isReadonly: boolean,
  baseHandlers: ProxyHandler<any>,
  collectionHandlers: ProxyHandler<any>
) {
  // 不是对象直接返回
  if (!isObject(target)) {
    return target
  }
  // 对象已经是响应式的，直接返回。
  if (
    target[ReactiveFlags.RAW] &&
    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])
  ) {
    return target
  }
  // 判断当前使用哪个响应式缓存
  const proxyMap = isReadonly ? readonlyMap : reactiveMap
  // 从缓存中获取proxy对象，若存在则直接返回
  const existingProxy = proxyMap.get(target)
  if (existingProxy) {
    return existingProxy
  }
  // 获取对象的类型
  const targetType = getTargetType(target)
  if (targetType === TargetType.INVALID) {
    return target
  }
  // 调用 Proxy 对传入对象 target 进行代理
  const proxy = new Proxy(
    target,
    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
  )
  // 放入缓存
  proxyMap.set(target, proxy)
  return proxy
}
```
`reactive` 函数内部通过对 `createReactiveObject` 函数的调用，进而返回相应的代理对象。

而 `createReactiveObject` 函数内部有以下几个重要逻辑：
* 首先判断是否是对象，不是对象直接返回
* 判断对象是否已经是响应式对象，若是则直接返回
* 根据 `isReadonly` 参数判断使用哪个缓存
* 尝试从缓存中获取当前对象对应的代理对象，若存在则直接返回
* 然后判断对象是否存在 `__v_skip` 或者该对象无法扩展，若满足条件，则直接返回该对象
* 调用 `Proxy` 创建代理对象，并放入到相应的缓存中

可以看到，把对象变为代理对象的核心步骤则是通过 `new Proxy `，我们知道在使用 `new Proxy API` 时，不止需要传递目标对象，还需要传递一个拦截方法对象。

那我们先看一下 `mutableHandlers` 中的定义：
```ts {28-34}
// packages/reactivity/src/baseHandlers.ts

const get = /*#__PURE__*/ createGetter()
const set = /*#__PURE__*/ createSetter()
function deleteProperty(target: object, key: string | symbol): boolean {
  const hadKey = hasOwn(target, key)
  const oldValue = (target as any)[key]
  const result = Reflect.deleteProperty(target, key)
  if (result && hadKey) {
    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)
  }
  return result
}

function has(target: object, key: string | symbol): boolean {
  const result = Reflect.has(target, key)
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, TrackOpTypes.HAS, key)
  }
  return result
}

function ownKeys(target: object): (string | number | symbol)[] {
  track(target, TrackOpTypes.ITERATE, ITERATE_KEY)
  return Reflect.ownKeys(target)
}

export const mutableHandlers: ProxyHandler<object> = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys
}
```
它其实就是劫持了我们对 target 对象的一些操作，比如：
* 访问对象属性会触发 `get` 函数
* 设置对象属性会触发 `set` 函数
* 删除对象属性会触发 `deleteProperty` 函数
* `in` 操作符会触发 `has` 函数
* 通过 `Object.getOwnPropertyNames` 访问对象属性名会触发 `ownKeys` 函数

因为无论命中哪个处理器函数，它都会做依赖收集和派发通知这两件事其中的一个，所以这里我只要分析常用的 `get` 和 `set` 函数就可以了。
### 依赖收集
**依赖收集发生在数据访问的阶段**，由于我们用 `Proxy API` 劫持了数据对象，所以当这个响应式对象属性被访问的时候就会执行 `get` 函数。

捕捉器 `get` 函数是 `createGetter` 函数的返回值，我们看一下 `createGetter` 函数的代码实现。
```ts
// packages/reactivity/src/baseHandlers.ts

function createGetter(isReadonly = false, shallow = false) {
  return function get(target: Target, key: string | symbol, receiver: object) {
    // 访问扩展属性 __v_isReactive，返回 !isReadonly
    if (key === ReactiveFlags.IS_REACTIVE) {
      return !isReadonly
    } else if (key === ReactiveFlags.IS_READONLY) {
      // 访问扩展属性 __v_isReadonly，返回 isReadonly
      return isReadonly
    } else if (
      key === ReactiveFlags.RAW &&
      receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)
    ) {
      // 访问扩展属性 __v_raw，并且该目标对象在缓存中存在代理对象，则直接返回该目标对象
      // __v_raw 属性中存储 原始对象
      return target
    }
    // 判断原始对象是否为数组
    const targetIsArray = isArray(target)
    if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver)
    }
    // 利用 Reflect.get 获取属性值
    const res = Reflect.get(target, key, receiver)
    // 判断 key 是否为 Symbol
    const keyIsSymbol = isSymbol(key)
    // 判断 Symbol 属性是否为内建属性，还是 __v_isRef 或 __proto__ ，是的话直接返回值
    if (
      keyIsSymbol
        ? builtInSymbols.has(key as symbol)
        : key === `__proto__` || key === `__v_isRef`
    ) {
      return res
    }
    // 判断是否为 isReadonly，不是的话调用 track 函数收集依赖
    if (!isReadonly) {
      track(target, TrackOpTypes.GET, key)
    }

    if (shallow) {
      return res
    }
    // 判断是否为引用包装对象，是的话需要去掉包装
    if (isRef(res)) {
      // ref unwrapping - does not apply for Array + integer key.
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key)
      return shouldUnwrap ? res.value : res
    }
    // 如果获取的属性值为对象的话，将属性值变为响应式
    if (isObject(res)) {
      // Convert returned value into a proxy as well. we do the isObject check
      // here to avoid invalid value warning. Also need to lazy access readonly
      // and reactive here to avoid circular dependency.
      return isReadonly ? readonly(res) : reactive(res)
    }
    return res
  }
}
```
可以看到，整个 `get` 函数返回值中的逻辑大致为分四部分：
* 特殊属性处理
* 使用 `Reflect.get` 获取属性值
* 使用 `track` 函数收集依赖
* 判断属性值是否为对象，并将其也变为响应式对象

从这整个的逻辑看下来，在响应式对象的属性值时，对其进行判断，如果它也是数组或对象，则递归执行 `reactive` 把 `res` 变成响应式对象。

这么做是因为 `Proxy` 劫持的是对象本身，并不能劫持子对象的变化，这点和 `Object.defineProperty API` 一致。

整个 `get` 函数最核心的部分其实是**执行 track 函数收集依赖**，下面我们重点分析这个过程。

我们先来看一下 `track` 函数的实现：
```ts {27-33}
// packages/reactivity/src/baseHandlers.ts

// 原始数据对象 map
const targetMap = new WeakMap<any, KeyToDepMap>()
// 当前激活的 effect
let activeEffect: ReactiveEffect | undefined
// 是否收集依赖
let shouldTrack = true

export function track(target: object, type: TrackOpTypes, key: unknown) {
  // shouldTrack 为 false 或者当前没有激活的 effect
  if (!shouldTrack || activeEffect === undefined) {
    return
  }
  // 根据原始对象，获取其收集的依赖 Map
  let depsMap = targetMap.get(target)
  // 若不存在，则往 targetMap 中新加一个 Map
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()))
  }
  // 根据属性 key 获取收集的依赖的 Set 集合
  let dep = depsMap.get(key)
  // 若不存在，则往 depsMap 中新加一个 Set
  if (!dep) {
    depsMap.set(key, (dep = new Set()))
  }
  // 若依赖 Set 中没包含当前激活的 effect
  if (!dep.has(activeEffect)) {
    // 收集当前激活的 effect 作为依赖
    dep.add(activeEffect)
    // 当前激活的 effect 收集 dep 集合作为依赖
    activeEffect.deps.push(dep)
  }
}
```
在这个 `get` 函数中，**我们收集的依赖是数据变化后执行的副作用函数**。

再来看实现，我们把 `target` 作为原始的数据，`key` 作为访问的属性。

我们创建了全局的 `targetMap` 作为原始数据对象的 `Map`，它的键是 `target`，值是 `depsMap`，作为依赖的 `Map`。

这个 `depsMap` 的键是 `target` 的 `key`，值是 `dep` 集合，`dep` 集合中存储的是依赖的副作用函数。

具体的结构入下图所示：
![reactive-getter](~@assets/posts/vue3-source-reactivity/reactive-getter.png)

所以每次 `track` ，就是把当前激活的副作用函数 `activeEffect` 作为依赖，然后收集到 `target` 相关的 `depsMap` 对应 `key` 下的依赖集合 `dep` 中。
### 派发通知
**派发通知发生在数据更新的阶段**，由于我们用 `Proxy API` 劫持了数据对象，所以当这个响应式对象属性被修改的时候就会执行 `set` 函数。

捕捉器 `set` 函数是 `createSetter` 函数的返回值，我们看一下 `createSetter` 函数的代码实现。
```ts {28,30-38}
// packages/reactivity/src/baseHandlers.ts

function createSetter(shallow = false) {
  return function set(
    target: object,
    key: string | symbol,
    value: unknown,
    receiver: object
  ): boolean {
    // 获取旧属性值
    const oldValue = (target as any)[key]
    if (!shallow) {
      // 获取新属性值的原始对象
      value = toRaw(value)
      // 目标对象不是数组，并且旧属性值为包装对象，新属性值为原始值
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {、
        // 直接修改包装对象的value为新属性值
        oldValue.value = value
        return true
      }
    } else {}
    // 判断目标对象上是否存在该属性 key
    const hadKey =
      isArray(target) && isIntegerKey(key)
        ? Number(key) < target.length
        : hasOwn(target, key)
    // 调用Reflect.set对属性key赋值
    const result = Reflect.set(target, key, value, receiver)
    // 如果目标对象的代理对象是当前receiver
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        // 触发添加新属性 key 的通知
        trigger(target, TriggerOpTypes.ADD, key, value)
      } else if (hasChanged(value, oldValue)) {
        // 触发修改属性 key 的通知
        trigger(target, TriggerOpTypes.SET, key, value, oldValue)
      }
    }
    // 返回赋值结果
    return result
  }
}
```
结合上述代码来看，`set` 函数的实现逻辑很简单，主要就做两件事情：
* 首先**通过 Reflect.set 求值**
* 然后**通过 trigger 函数派发通知**，并依据 `key` 是否存在于 `target` 上来确定通知类型，即新增还是修改。

整个 `set` 函数最核心的部分就是**执行 trigger 函数派发通知**，下面我们将重点分析这个过程。
```ts {17,19-27,75-83,85}
// packages/reactivity/src/effect.ts

export function trigger(
  target: object,
  type: TriggerOpTypes,
  key?: unknown,
  newValue?: unknown,
  oldValue?: unknown,
  oldTarget?: Map<unknown, unknown> | Set<unknown>
) {
  // 根据 target 从 targetMap 中获取 depsMap
  const depsMap = targetMap.get(target)
  if (!depsMap) {
    return
  }
  // 创建运行的 effects 集合
  const effects = new Set<ReactiveEffect>()
  // 添加 effects 的函数
  const add = (effectsToAdd: Set<ReactiveEffect> | undefined) => {
    if (effectsToAdd) {
      effectsToAdd.forEach(effect => {
        if (effect !== activeEffect || effect.options.allowRecurse) {
          effects.add(effect)
        }
      })
    }
  }

  if (type === TriggerOpTypes.CLEAR) {
    // type 为 clear，触发所有的effects
    depsMap.forEach(add)
  } else if (key === 'length' && isArray(target)) {
    // 判断目标对象为数组并且访问的属性为 length
    depsMap.forEach((dep, key) => {
      // ?
      if (key === 'length' || key >= (newValue as number)) {
        add(dep)
      }
    })
  } else {
    // SET | ADD | DELETE 操作之一，添加对应的 effects
    if (key !== void 0) {
      add(depsMap.get(key))
    }

    // 在 ADD | DELETE | Map.SET 时也添加迭代key的effects
    switch (type) {
      case TriggerOpTypes.ADD:
        if (!isArray(target)) {
          add(depsMap.get(ITERATE_KEY))
          if (isMap(target)) {
            add(depsMap.get(MAP_KEY_ITERATE_KEY))
          }
        } else if (isIntegerKey(key)) {
          // 新下标增加 --> 数组长度改变
          add(depsMap.get('length'))
        }
        break
      case TriggerOpTypes.DELETE:
        if (!isArray(target)) {
          add(depsMap.get(ITERATE_KEY))
          if (isMap(target)) {
            add(depsMap.get(MAP_KEY_ITERATE_KEY))
          }
        }
        break
      case TriggerOpTypes.SET:
        if (isMap(target)) {
          add(depsMap.get(ITERATE_KEY))
        }
        break
    }
  }

  const run = (effect: ReactiveEffect) => {
    if (effect.options.scheduler) {
      // 调度执行
      effect.options.scheduler(effect)
    } else {
      // 直接运行
      effect()
    }
  }
  // 遍历执行 effects
  effects.forEach(run)
}
```
`trigger` 函数的实现也很简单，主要做了四件事情：
* 通过 `targetMap` 拿到 `target` 对应的依赖集合 `depsMap`
* 创建运行的 `effects` 集合
* 根据 `key` 从 `depsMap` 中找到对应的 `effects` 添加到 `effects` 集合
* 遍历 `effects` 执行相关的副作用函数

所以每次 `trigger` 函数就是根据 `target` 和 `key` ，从 `targetMap` 中找到相关的所有副作用函数遍历执行一遍。
## 副作用函数 Effect
在描述依赖收集和派发通知的过程中，我们都提到了一个词：**副作用函数**，依赖收集过程中我们把 `activeEffect`（当前激活副作用函数）作为依赖收集。

下面就让我们看一下 `effect` 是什么吧。
```ts {18,40-56}
// packages/reactivity/src/effect.ts

// 全局 effect 栈
const effectStack: ReactiveEffect[] = []
// 当前激活的 effect
let activeEffect: ReactiveEffect | undefined

export function effect<T = any>(
  fn: () => T,
  options: ReactiveEffectOptions = EMPTY_OBJ
): ReactiveEffect<T> {
  // 如果传入的回调函数 fn 为 effect
  if (isEffect(fn)) {
    // 则将 fn 重新赋值为其原始回调
    fn = fn.raw
  }
  // 使用 createReactiveEffect 创建 effect 副作用函数
  const effect = createReactiveEffect(fn, options)
  // 如果 lazy 不为 true，则立即调用 effect
  if (!options.lazy) {
    effect()
  }
  // 返回effect
  return effect
}

function createReactiveEffect<T = any>(
  fn: () => T,
  options: ReactiveEffectOptions
): ReactiveEffect<T> {
  const effect = function reactiveEffect(): unknown {
    if (!effect.active) {
      // 非激活状态，则判断如果非调度执行，则直接执行原始函数。
      return options.scheduler ? undefined : fn()
    }
    // 全局 effect 栈中不存在当前 effect
    if (!effectStack.includes(effect)) {
      // 清空当前 effect 引用的依赖
      cleanup(effect)
      try {
        // 开启全局 shouldTrack，允许依赖收集
        enableTracking()
        // 压栈
        effectStack.push(effect)
        // 将当前的 effect 赋值为全局激活的 effect
        activeEffect = effect
        // 执行原始回调
        return fn()
      } finally {
        // 出栈
        effectStack.pop()
        // 恢复 shouldTrack 开启之前的状态
        resetTracking()
        // 指向当前栈顶 effect
        activeEffect = effectStack[effectStack.length - 1]
      }
    }
  } as ReactiveEffect
  effect.id = uid++
  // 标识是一个 effect 函数
  effect._isEffect = true
  // effect 自身的状态
  effect.active = true
  // 包装的原始回调函数
  effect.raw = fn
  // effect 对应的依赖，双向指针，依赖包含对 effect 的引用，effect 也包含对依赖的引用
  effect.deps = []
  // effect 的相关配置
  effect.options = options
  return effect
}
```
结合上述代码来看，`effect` 内部通过执行 `createReactiveEffect` 函数去创建一个新的 `effect` 函数。

为了和外部的 `effect` 函数区分，我们把它称作 `reactiveEffect` 函数，并且还给它添加了一些额外属性。

这个 `reactiveEffect` 函数就是响应式的副作用函数，当执行 `trigger` 过程派发通知的时候，执行的 `effect` 就是它。

这个 `reactiveEffect` 函数只需要做两件事情： 
* 把全局的 `activeEffect` 指向它
* 然后执行被包装的原始回调函数 `fn` 即可

至于在执行过程中为什么需要 `effectStack` 这一个栈的结构呢？为什么不能直接执行 `activeEffect = effect` ？其实这是为了解决嵌套 `effect` 的问题。

我们看如下的一个例子：
```ts
import { reactive, effect } from "@vue/reactivity"

const counter = reactive({
  num: 0, 
  num2: 0 
})
function logCount() {
  effect(logCount2) 
  console.log('num:', counter.num) 
}
function count() {
  counter.num++
}
function logCount2() {
  console.log('num2:', counter.num2)
}
effect(logCount)
count()
```
我们每次执行 `effect` 函数时，如果仅仅把 `reactiveEffect` 函数赋值给 `activeEffect`，那么针对这种嵌套场景，执行完 `effect(logCount2)` 后，`activeEffect` 还是 `effect(logCount2)` 返回的 `reactiveEffect` 函数。
这样后续访问 `counter.num` 的时候，依赖收集对应的 `activeEffect` 就不对了，此时我们外部执行 `count` 函数修改 `counter.num` 后执行的便不是 `logCount` 函数，而是 `logCount2` 函数。

最终输出的结果如下：
```sh
  num2: 0
  num: 0
  num2: 0
```
而我们期望的结果应该如下：
```sh
  num2: 0
  num: 0
  num2: 0
  num: 1
```
因此针对嵌套 `effect` 的场景，我们不能简单地赋值 `activeEffect` ，应该考虑到函数的执行本身就是一种入栈出栈操作。

这里我们还注意到一个细节，在入栈前会**执行 cleanup 函数清空 reactiveEffect 函数对应的依赖**。 `cleanup` 函数的定义如下：
```ts {7}
// packages/reactivity/src/effect.ts

function cleanup(effect: ReactiveEffect) {
  const { deps } = effect
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect)
    }
    deps.length = 0
  }
}
```
在执行 `track` 函数的时候，除了收集当前激活的 `effect` 作为依赖，还通过 `activeEffect.deps.push(dep)` 把 `dep` 作为 `activeEffect` 的依赖。

这样在 `cleanup` 的时候我们就可以找到 `effect` 对应的 `dep` 了，然后把 `effect` 从这些 `dep` 中删除。

那么为什么需要 `cleanup` 呢？是为了防止之前的副作用函数影响到当前的渲染触发，所以将其从之前被收集的 `dep`（ `depsMap` 中的 `key` 对应的 `dep` Set集合）中将其删除。
## Readonly API
如果用 `const` 声明一个对象变量，虽然不能直接对这个变量赋值，但我们可以修改它的属性。

如果我们希望创建只读对象，不能修改它的属性，也不能给这个对象添加和删除属性，让它变成一个真正意义上的只读对象。

显然，想实现上述需求就需要劫持对象，于是 `Vue 3.0` 在 `reactive API` 的基础上，设计并实现了 `readonly API`。
```ts
// packages/reactivity/src/reactive.ts

export const readonlyMap = new WeakMap<Target, any>()

export function readonly<T extends object>(
  target: T
): DeepReadonly<UnwrapNestedRefs<T>> {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers
  )
}

function createReactiveObject(
  target: Target,
  isReadonly: boolean,
  baseHandlers: ProxyHandler<any>,
  collectionHandlers: ProxyHandler<any>
) {
  if (!isObject(target)) {
    return target
  }
  // target 已经是 Proxy 对象，直接返回
  // 有个例外，如果是 readonly 作用于一个响应式对象，则继续
  if (
    target[ReactiveFlags.RAW] &&
    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])
  ) {
    return target
  }
  const proxyMap = isReadonly ? readonlyMap : reactiveMap
  const existingProxy = proxyMap.get(target)
  if (existingProxy) {
    return existingProxy
  }
  const targetType = getTargetType(target)
  if (targetType === TargetType.INVALID) {
    return target
  }
  const proxy = new Proxy(
    target,
    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
  )
  proxyMap.set(target, proxy)
  return proxy
}
```
其实 `readonly` 和 `reactive` 函数的主要区别，就是执行 `createReactiveObject` 函数时的参数 `isReadonly` 及 传入的 `baseHandlers` 和 `collectionHandlers` 不同。

首先调用时 `isReadonly` 传递的是 `true` ，其次是传递了 `readonlyHandlers` 和 `readonlyCollectionHandlers` 。

我们来看一下其中 `readonlyHandlers` 的实现：
```ts {19-21}
// packages/reactivity/src/baseHandlers.ts

const readonlyGet = /*#__PURE__*/ createGetter(true)

function createGetter(isReadonly = false, shallow = false) {
  return function get(target: Target, key: string | symbol, receiver: object) {
    if (key === ReactiveFlags.IS_REACTIVE) {
      return !isReadonly
    } else if (key === ReactiveFlags.IS_READONLY) {
      return isReadonly
    } else if (
      key === ReactiveFlags.RAW &&
      receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)
    ) {
      return target
    }
    // ...
    // isReadonly 为 true，不做依赖收集
    if (!isReadonly) {
      track(target, TrackOpTypes.GET, key)
    }
    // ...
    if (isObject(res)) {
      // 对于对象，依然递归将其变为 readonly
      return isReadonly ? readonly(res) : reactive(res)
    }
    return res
  }
}

export const readonlyHandlers: ProxyHandler<object> = {
  get: readonlyGet,
  set(target, key) {
    if (__DEV__) {
      console.warn(
        `Set operation on key "${String(key)}" failed: target is readonly.`,
        target
      )
    }
    return true
  },
  deleteProperty(target, key) {
    if (__DEV__) {
      console.warn(
        `Delete operation on key "${String(key)}" failed: target is readonly.`,
        target
      )
    }
    return true
  }
}
```
`readonlyHandlers` 和 `mutableHandlers` 的区别主要在 `get`、`set` 和 `deleteProperty` 三个函数上。

很显然，作为一个只读的响应式对象，是不允许修改属性以及删除属性的，所以在非生产环境下 `set` 和 `deleteProperty` 函数的实现都会报警告，提示用户 `target` 是 `readonly` 的。

至于 `get` ，则是它和 `reactive API` 最大的区别就是不做依赖收集了，这一点也非常好理解，因为它的属性不会被修改，所以就不用跟踪它的变化了。

并且对于求解属性值，若是对象则以依旧递归的将其变为 `readonly`。
## Ref API
我们知道 `reactive API` 对传入的 `target` 类型有限制，必须是对象或者数组类型，而对于一些基础类型（比如 `String`、`Number`、`Boolean`）是不支持的。

但是有时候从需求上来说，可能我只希望把一个字符串变成响应式，却不得不封装成一个对象，这样使用上多少有一些不方便，于是 `Vue 3.0` 设计并实现了 `ref API`。

我们来看一下 `ref` 的实现：
```ts {23,33}
// packages/reactivity/src/ref.ts

export function ref(value?: unknown) {
  return createRef(value)
}

// 如果是对象或者数组类型，则转换一个 reactive 对象。
const convert = <T extends unknown>(val: T): T =>
  isObject(val) ? reactive(val) : val

class RefImpl<T> {
  private _value: T

  public readonly __v_isRef = true

  constructor(private _rawValue: T, private readonly _shallow = false) {
    // 如果 _shallow 为 true，表示浅引用，若为false，则使用 convert 统一处理
    this._value = _shallow ? _rawValue : convert(_rawValue)
  }

  get value() {
    // 收集该 ref 的依赖
    track(toRaw(this), TrackOpTypes.GET, 'value')
    return this._value
  }

  set value(newVal) {
    // 比较值是否修改
    if (hasChanged(toRaw(newVal), this._rawValue)) {
      this._rawValue = newVal
      this._value = this._shallow ? newVal : convert(newVal)
      // 触发修改 value 的通知
      trigger(toRaw(this), TriggerOpTypes.SET, 'value', newVal)
    }
  }
}

function createRef(rawValue: unknown, shallow = false) {
  if (isRef(rawValue)) {
    // 如果传入的就是一个 ref，那么返回自身即可，处理嵌套 ref 的情况。
    return rawValue
  }
  return new RefImpl(rawValue, shallow)
}
```
这几段代码一共做了如下：
* `createRef` 函数首先处理了嵌套 `ref` 的情况，如果传入的 `rawValue` 也是 `ref`，那么直接返回。
* 接着调用 `new RefImpl()`，生成一个 `ref` 实例，在构造函数中对 `rawValue` 做了一层转换，如果 `rawValue` 是对象或者数组类型，那么把它转换成一个 `reactive` 对象。当然这其中还有浅引用的判断。
* 最后就是这个类中定义的 `setter` 和 `getter` 方法，根据之前 `reactive API` 的分析我们知道，`getter` 方法是负责收集依赖，`setter` 方法是派发通知。

最后我们通过一张图来看一下 `Vue 3.0` 整个响应式 `API` 实现和组件更新的关系：
![vue3-reactivity](~@assets/posts/vue3-source-reactivity/vue3-reactivity.png)
## Computed API
计算属性是 `Vue` 开发中一个非常实用的 `API` ，它允许用户定义一个计算方法，然后根据一些依赖的响应式数据计算出新值并返回。

**当依赖发生变化时，计算属性可以自动重新计算获取新值**，所以使用起来非常方便。

到了 `Vue 3.0` ，虽然也可以在组件中沿用 `Vue 2.x` 的使用方式，但是我们也可以单独使用计算属性 `API`。

`Vue 3.0` 提供了一个 `computed` 函数作为计算属性 `API`，我们先来看看它是如何使用的。
```ts
import { computed, ref } from "@vue/reactivity"

const count = ref(1) 
const plusOne = computed(() => count.value + 1) 
console.log(plusOne.value) // 2 
plusOne.value++ // error 
count.value++ 
console.log(plusOne.value) // 3
```
从代码中可以看到，我们先使用 `ref API` 创建了一个响应式对象 `count`，然后使用 `computed API` 创建了另一个响应式对象 `plusOne`，它的值是 `count.value + 1`。

当我们修改 `count.value` 的时候， `plusOne.value` 就会自动发生变化。

注意，这里我们直接修改 `plusOne.value` 会报一个错误，这是因为如果我们传递给 `computed` 的是一个函数，那么这就是一个 `getter` 函数，我们只能获取它的值，而不能直接修改它。

当然，有时候我们也希望能够直接修改 `computed` 的返回值，那么我们可以给 `computed` 传入一个对象：
```ts
import { computed, ref } from "@vue/reactivity"

const count = ref(1) 
const plusOne = computed({ 
  get: () => count.value + 1, 
  set: val => { 
    count.value = val - 1 
  } 
}) 
plusOne.value = 1 
console.log(count.value) // 0
```
我们给 `computed` 函数传入了一个拥有 `getter` 函数和 `setter` 函数的对象，`getter` 函数和之前一样，还是返回 `count.value + 1`。

而 `setter` 函数，请注意，这里我们修改 `plusOne.value` 的值就会触发 `setter` 函数。

那么我们来看一下 `computed API` 的实现：
```ts {44-49,61}
// packages/reactivity/src/computed.ts

export function computed<T>(
  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>
) {
  let getter: ComputedGetter<T>
  let setter: ComputedSetter<T>
  // 根据传入参数类型获取 setter 和 getter
  if (isFunction(getterOrOptions)) {
    getter = getterOrOptions
    setter = NOOP
  } else {
    getter = getterOrOptions.get
    setter = getterOrOptions.set
  }
  // 传入 setter 和 getter 创建 ComputedRefImpl 实例
  return new ComputedRefImpl(
    getter,
    setter,
    isFunction(getterOrOptions) || !getterOrOptions.set
  ) as any
}

class ComputedRefImpl<T> {
  private _value!: T
  // 标记是否更新
  private _dirty = true
  // 副作用函数
  public readonly effect: ReactiveEffect<T>
  // ref 标记
  public readonly __v_isRef = true;
  // readonly 标记
  public readonly [ReactiveFlags.IS_READONLY]: boolean
  constructor(
    getter: ComputedGetter<T>,
    private readonly _setter: ComputedSetter<T>,
    isReadonly: boolean
  ) {
    // 创建副作用函数
    this.effect = effect(getter, {
      // 声明 lazy
      lazy: true,
      // 定义 scheduler 函数
      scheduler: () => {
        if (!this._dirty) {
          this._dirty = true
          trigger(toRaw(this), TriggerOpTypes.SET, 'value')
        }
      }
    })
    // 标记是否为只读
    this[ReactiveFlags.IS_READONLY] = isReadonly
  }
  get value() {
    // 判断是否更新 value
    if (this._dirty) {
      this._value = this.effect()
      this._dirty = false
    }
    // 收集依赖
    track(toRaw(this), TrackOpTypes.GET, 'value')
    return this._value
  }
  set value(newValue: T) {
    this._setter(newValue)
  }
}
```
从代码中可以看到，主要有以下步骤：
* 标准化参数
* 创建 `ComputedRefImpl` 实例，构造函数中创建 `effect` 副作用函数
* 在 `getter` 方法中更新 `value` 和收集依赖

其中我们需要注意的是，在创建 `effect` 副作用函数是，传递的参数有 `lazy` 和 `scheduler`。

`lazy` 参数的作用是在使用 `createReactiveEffect` 函数创建 `effect` 后，不立即调用 `effect` ，而是在 `getter` 时才调用 `effect` 获取值。

而 `scheduler` 函数的作用则是在派发通知时，若存在 `scheduler` ，则调用 `scheduler` 函数更新状态，并且通知计算属性的相关依赖。也是起到一个延时获取值的效果。
### 计算属性的运行机制
`computed` 函数的逻辑会有一点绕，其核心点在于内部两个重要的变量：
* 第一个 `dirty` 表示一个计算属性的值是否是“脏的”，用来判断需不需要重新计算
* 第二个 `value` 表示计算属性每次计算后的结果。

这里我们结合一个例子来看一下流程：
```vue
<template> 
  <div> 
    {{ plusOne }} 
  </div> 
  <button @click="handlePlus">Plus</button> 
</template> 
<script> 
  import { ref, computed } from 'vue' 
  export default { 
    setup() { 
      const count = ref(0) 
      const plusOne = computed(() => { 
        return count.value + 1 
      }) 
      function handlePlus() { 
        count.value++ 
      } 
      return { 
        plusOne, 
        plus 
      } 
    } 
  } 
</script>
```
1. 首先组件渲染阶段会访问 `plusOne` ，也就触发了 `plusOne` 对象的 `getter` 函数：
```ts
  get value() {
    // 判断是否更新 value
    if (this._dirty) {
      this._value = this.effect()
      this._dirty = false
    }
    // 收集依赖
    track(toRaw(this), TrackOpTypes.GET, 'value')
    return this._value
  }
```
由于默认 `dirty` 是 `true` ，所以这个时候会执行 `this.effect` 方法，并进一步执行 `computed getter` ，也就是 `count.value + 1`。

因为访问了 `count` 的值，并且由于 `count` 也是一个响应式对象，所以就会触发 `count` 对象的依赖收集过程。

请注意，由于是在 `this.effect` 执行的时候访问 `count` ，所以这个时候的 `activeEffect` 是计算属性内部 `this.effect` 方法。

`this.effect` 方法执行完毕，会把 `dirty` 设置为 `false` ，并进一步执行 `track(toRaw(this), TrackOpTypes.GET, 'value')` 函数做依赖收集，这个时候 `activeEffect` 是组件副作用渲染函数。

所以你要特别注意这是两个依赖收集过程：
* 对于 `plusOne` 来说，它收集的依赖是组件副作用渲染函数
* 对于 `count` 来说，它收集的依赖是 `plusOne` 内部的 `this.effect` 方法。

2. 其次在我们点击按钮的时候，会执行 `handlePlus` 函数，函数内部通过 `count.value++` 修改 `count` 的值，并派发通知。

请注意，这里不是直接调用 `this.effect` 方法，而是把 `this.effect` 作为参数去执行 `scheduler` 函数。我们来回顾一下 `trigger` 函数内部对于 `effect` 函数的执行方式:
```ts {2}
  if (effect.options.scheduler) {
    effect.options.scheduler(effect)
  } else {
    effect()
  }
```
`computed API` 内部创建副作用函数时，已经配置了 `scheduler` 函数，如下：
```ts {5-10}
  this.effect = effect(getter, {
    // 声明 lazy
    lazy: true,
    // 定义 scheduler 函数
    scheduler: () => {
      if (!this._dirty) {
        this._dirty = true
        trigger(toRaw(this), TriggerOpTypes.SET, 'value')
      }
    }
  })
```
它并没有对计算属性求新值，而仅仅是把 `dirty` 设置为 `true`，再执行 `trigger(toRaw(this), TriggerOpTypes.SET, 'value')`，去通知执行 `plusOne` 依赖的组件渲染副作用函数，即触发组件的重新渲染。

具体的流程我们可以看下面这张图：
![computed-api](~@assets/posts/vue3-source-reactivity/computed-api.png)

通过以上分析，我们可以看出 `computed` 计算属性有两个特点：
* **延时计算**，只有当我们访问计算属性的时候，它才会真正运行 `computed getter` 函数计算
* **缓存**，它的内部会缓存上次的计算结果 `value`，而且只有 `dirty` 为 `true` 时才会重新计算。

由此我们可以知道，和单纯使用普通函数相比，计算属性的优势是：只要依赖不变化，就可以使用缓存的 `value` 而不用每次在渲染组件的时候都执行函数去计算，这是典型的空间换时间的优化思想。
### 嵌套计算属性
得益于 `Vue` 的依赖收集机制，使得在 `computed` 嵌套的情况下也能正确的触发，返回正确的值。

下面我们看一个例子：
```ts
import { ref, computed } from "@vue/reactivity"

const count = ref(0) 
const plusOne = computed(() => {
  console.log("plusOne")
  return count.value + 1 
}) 
const plusTwo = computed(() => { 
  console.log("plusTwo")
  return plusOne.value + 2
}) 
console.log(plusTwo.value) // 3
```
我们看到有两个 `computed` 对象，其中 `plusOne` 嵌套在 `plusTwo` 中，我们首先分析各自收集的依赖：
* `plusTwo` 是我们手动调用的，并没有收集依赖。
* `plusOne` 是在 `plusTwo` 中调用的，所以他收集的依赖则是 `plusTwo` 内部的 `this.effect` 。
* `count` 是在 `plusOne` 中调用的，所以他收集的依赖则是 `plusOne` 内部的 `this.effect` 。

所以当我们修改 `count` 的 `value` 时，他的通知顺序如下:
* `count` 派发通知给相关依赖
* `plusOne` 收到通知，先运行内部的 `scheduler` 函数，把 `this.dirty` 变为 `true` ，然后执行 `trigger` 函数给其相关依赖派发通知
* `plusTwo` 收到通知，先运行内部的 `scheduler` 函数，把 `this.dirty` 设置为 `true` 。然后执行 `trigger` 函数给其相关依赖派发通知，由于 `plusTwo` 没有相关依赖，所以通知到此结束。

可以看到通知后，并没有使 `computed` 中的 `value` 发生变化，只是将 `this.dirty` 置为 `true` 。当实际上访问 `computed` 时，才会更新 `value` 。
## Watch API
在 `Vue 2.x` 中，你可以通过 `watch` 选项去初始化一个侦听器，称作 `watcher` ：
```ts
export default { 
  watch: { 
    a(newVal, oldVal) { 
      console.log('new: %s, old: %s', newVal, oldVal) 
    } 
  } 
} 
```
在 `Vue 3.0` 中，虽然你仍可以使用 `watch` 选项，但针对 `Composition API` ，`Vue 3.0` 提供了 `watch API` 来实现侦听器的效果。
```ts
```
### watch API 使用
在 `Vue 3.0` 中， `watch API` 有以下几种用法：
* `watch API` 可以侦听一个 `getter` 函数，但是它必须返回一个响应式对象
* `watch API` 也可以直接侦听一个响应式对象
* `watch API` 还可以直接侦听多个响应式对象或 `getter` 函数
### watch API 原理
我们首先看一下 `watch` 的声明：
```ts
// packages/runtime-core/src/apiWatch.ts

export function watch<T = any>(
  source: WatchSource<T> | WatchSource<T>[],
  cb: WatchCallback<T>,
  options?: WatchOptions
): WatchStopHandle {
  if (__DEV__ && !isFunction(cb)) {
    warn(
      `\`watch(fn, options?)\` signature has been moved to a separate API. ` +
        `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` +
        `supports \`watch(source, cb, options?) signature.`
    )
  }
  return doWatch(source, cb, options)
}
```
从代码中可以看到，`watch` 函数内部调用了 `doWatch` 函数，调用前会在非生产环境下判断第二个参数 `cb` 是不是一个函数，并对此签名的用法进行警告。

关于 `doWatch` 函数，由于其定义有点长，我们拆成如下几个步骤来分析：
```ts
// packages/runtime-core/src/apiWatch.ts

function doWatch(
  source: WatchSource | WatchSource[] | WatchEffect,
  cb: WatchCallback | null,
  { immediate, deep, flush, onTrack, onTrigger }: WatchOptions = EMPTY_OBJ,
  instance = currentInstance
): WatchStopHandle {
  // 标准化 source
  // 创建 SchedulerJob
  // 创建 scheduler
  // 创建 effect
  // 返回销毁函数
}
```
### 标准化 source
我们先来看 `watch` 函数的第一个参数 `source` 。

通过之前的说明知道 `source` 可以是 `getter` 函数，也可以是响应式对象甚至是两者的数组，所以我们需要标准化 `source` ，这是**标准化 source**的流程：
```ts
// packages/runtime-core/src/apiWatch.ts -> function doWatch

let getter: () => any
// 判断 source 是否是 ref 对象
const isRefSource = isRef(source)
if (isRefSource) {
  // 如果是，则构建成 getter 函数
  getter = () => (source as Ref).value
} else if (isReactive(source)) {
  // 若 source 是响应式对象，则构建 getter 函数，并将 deep 置为 true
  getter = () => source
  deep = true
} else if (isArray(source)) {
  // 若 source 是数组，则依次遍历 source 构建返回数组
  getter = () =>
    source.map(s => {
      if (isRef(s)) {
        // 是否是 ref 对象
        return s.value
      } else if (isReactive(s)) {
        // 是否是响应式对象，若是，则调用 traverse 函数递归访问每一个属性，收集依赖
        return traverse(s)
      } else if (isFunction(s)) {
        // 是否为函数，若是则使用 callWithErrorHandling 函数包裹执行
        return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER)
      } else {
        // ...
      }
    })
} else if (isFunction(source)) {
  // 若 source 是函数，并 cb 参数存在
  if (cb) {
    // 使用 callWithErrorHandling 函数包裹执行
    getter = () =>
      callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER)
  } else {
    //  cb 参数不存在，watchEffect 处理逻辑
  }
} else {
  // 不符合上述所有情况，则 getter 为 NOOP
  getter = NOOP
}
// 如果 cb存在并且 deep 为 true，则将 getter 返回的结果用 traverse 函数递归访问每一个属性
// 目的也是收集依赖
if (cb && deep) {
  const baseGetter = getter
  getter = () => traverse(baseGetter())
}
```
由上面代码的注释可知， `source` 标准化主要是根据 `source` 的类型，将其变成 `getter` 函数。具体来说：
* 如果 `source` 是 `ref` 对象，则创建一个访问 `source.value` 的 `getter` 函数
* 如果 `source` 是 `reactive` 对象，则创建一个函数，函数内使用 `traverse` 递归访问每一个属性
* 如果 `source` 是数组，则创建一个函数，函数内使用 map 函数遍历 `source` ，并分别判断 `source` 数组中的元素类型，分别处理
* 如果 `source` 是一个函数，则判断 `cb` 存在，若存在则创建一个对 `source` 函数封装的函数。

可能注意到一个问题，为什么使用 `traverse` 函数递归遍历 `reactive` 对象的每一个属性呢？

根本原因是，当我们执行 `watch` 函数的时候，我们知道如果侦听的是一个 `reactive` 对象，那么内部会设置 `deep` 为 `true` ，然后执行 `traverse` 去递归访问对象深层子属性。

这个时候就会访问 `reactive` 对象深层次的属性触发依赖收集，这里收集的依赖是 `watcher` 内部创建的 `effect runner`。

因此，当我们再去修改 `reactive` 对象深层次的属性的时候，就会通知这个 `effect` ，所以最终会执行 `watcher` 的回调函数。
### 创建 SchedulerJob
处理完 `watch` 函数的第一个参数 `source` 后，我们看一下对于 `cb` 参数的处理。

我们首先先看一下这部分代码：
```ts
// packages/runtime-core/src/apiWatch.ts -> function doWatch

let cleanup: () => void
// 注册无效回调函数 
const onInvalidate: InvalidateCbRegistrator = (fn: () => void) => {
  cleanup = runner.options.onStop = () => {
    callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP)
  }
}
// 初始化 oldValue
let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE
const job: SchedulerJob = () => {
  // 如果 runner effect 不在激活状态直接返回
  if (!runner.active) {
    return
  }
  // 如果 cb 有值
  if (cb) {
    // 调用 runner effect 获取最新值
    const newValue = runner()
    if (deep || isRefSource || hasChanged(newValue, oldValue)) {
      // 执行清理函数 
      if (cleanup) {
        cleanup()
      }
      callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [
        newValue,
        // 第一次更改时传递旧值为 undefined 
        oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
        onInvalidate
      ])
      // 更新旧值 
      oldValue = newValue
    }
  } else {
    // watchEffect 处理逻辑
    runner()
  }
}
job.allowRecurse = !!cb
```
**onInvalidate 函数用来注册无效回调函数 ，我们暂时不需要关注它。**

这里的逻辑主要有三部分：
* 首先判断当前 `runner effect` 是否激活，若不是激活状态，则直接返回
* 执行 `runner` 求得新值，这里实际上就是执行前面创建的 `getter` 函数求新值。
* 最后进行判断，如果是 `deep` 的情况或者 `source` 是 `ref` 对象或者新旧值发生了变化，则执行回调函数 `cb` ，传入参数 `newValue` 和 `oldValue` 。

注意，第一次执行的时候旧值的初始值是空数组或者 `undefined` 。执行完回调函数 `cb` 后，把旧值 `oldValue` 再更新为 `newValue` ，这是为了下一次的比对。
### 创建 scheduler
`scheduler` 的作用是根据某种调度的方式去执行某种函数，在 `watch API` 中，主要影响到的是回调函数的执行方式。我们来看一下它的实现逻辑：
```ts
// packages/runtime-core/src/apiWatch.ts -> function doWatch

let scheduler: (job: () => any) => void
if (flush === 'sync') {
  // 同步 
  scheduler = job
} else if (flush === 'post') {
  // 进入异步队列，组件更新后执行 
  scheduler = () => queuePostRenderEffect(job, instance && instance.suspense)
} else {
  // 默认是 pre
  scheduler = () => {
    if (!instance || instance.isMounted) {
      // 进入异步队列，组件更新前执行 
      queuePreFlushCb(job)
    } else {
      // 如果组件还没挂载，则同步执行确保在组件挂载前 
      job()
    }
  }
}
```
`Watch API` 的参数除了 `source` 和 `cb` ，还支持第三个参数 `options` ，不同的配置决定了 `watcher` 的不同行为。

前面我们也分析了 `deep` 为 `true` 的情况，除了 `source` 为 `reactive` 对象时会默认把 `deep` 设置为 `true` ，你也可以主动传入第三个参数，把 `deep` 设置为 `true` 。

这里， `scheduler` 的创建逻辑受到了第三个参数 `Options` 中的 `flush` 属性值的影响，**不同的 flush 决定了 watcher 的执行时机**：
* 当 `flush` 为 `sync` 的时候，表示它是一个同步 `watcher` ，即当数据变化时同步执行回调函数。
* 当 `flush` 为 `pre` 的时候，回调函数通过 `queueJob` 的方式在组件更新之前执行，如果组件还没挂载，则同步执行确保回调函数在组件挂载之前执行。
* 如果没设置 `flush` ，那么回调函数通过 `queuePostRenderEffect` 的方式在组件更新之后执行。
### 创建 effect
前面的分析我们提到了 `runner` ，它其实就是 `watcher` 内部创建的 `effect` 函数，接下来，我们来分析它逻辑：
```ts
// packages/runtime-core/src/apiWatch.ts -> function doWatch

const runner = effect(getter, {
  lazy: true,
  onTrack,
  onTrigger,
  scheduler
})

recordInstanceBoundEffect(runner)

// initial run
if (cb) {
  if (immediate) {
    job()
  } else {
    oldValue = runner()
  }
} else if (flush === 'post') {
  queuePostRenderEffect(runner, instance && instance.suspense)
} else {
  runner()
}
```
这块代码逻辑是整个 `watcher` 实现的核心部分，即通过 `effect API` 创建一个副作用函数 `runner` ，我们需要关注以下几点。
* **runner 执行的方式**。 `runner` 是 `lazy` 的，它不会在创建后立刻执行。第一次手动执行 `runner` 会执行前面的 `getter` 函数，访问响应式数据并做依赖收集。
* **runner 的返回结果**。手动执行 `runner` 就相当于执行了前面标准化的 `getter` 函数， `getter` 函数的返回值就是 `watcher` 计算出的值，所以我们第一次执行 `runner` 求得的值可以作为 oldValue。
* **配置了 immediate 的情况**。当我们配置了 `immediate` ，创建完 `watcher` 会立刻执行 `job` 函数，此时 `oldValue` 还是初始值，在 `job` 执行时也会执行 `runner` 进而执行前面的 `getter` 函数做依赖收集，求得新值。
### 返回销毁函数
最后，会返回侦听器销毁函数，也就是 `watch API` 执行后返回的函数。我们可以通过调用它来停止 `watcher` 对数据的侦听。
```ts
// packages/runtime-core/src/apiWatch.ts -> function doWatch

return () => {
  stop(runner)
  if (instance) {
    remove(instance.effects!, runner)
  }
}
// packages/reactivity/src/effect.ts

export function stop(effect: ReactiveEffect) {
  if (effect.active) {
    // 从相关依赖队列中清除该 effect
    cleanup(effect)
    if (effect.options.onStop) {
      // 调用 onStop 方法
      effect.options.onStop()
    }
    // 将 effect 状态改为未激活状态
    effect.active = false
  }
}
```
销毁函数内部会执行 `stop` 方法让 `runner` 失活，并清理 `runner` 的相关依赖，这样就可以停止对数据的侦听。

并且，如果是在组件中注册的 `watcher` ，也会移除组件 `effects` 对这个 `runner` 的引用。
### 异步任务队列
我们看一个例子：
```ts
import { reactive, watch } from "vue"

const state = reactive({ count: 0 }) 
watch(() => state.count, (count, prevCount) => { 
  console.log(count) 
}) 
state.count++ 
state.count++ 
state.count++ 
```
这里，我们修改了三次 `state.count` ，那么 `watcher` 的回调函数会执行三次吗？

答案是不会，实际上只输出了一次 `count` 的值，也就是最终计算的值 `3` 。

这在大多数场景下都是符合预期的，因为在一个 `Tick` （宏任务执行的生命周期）内，即使多次修改侦听的值，它的回调函数也只执行一次。
::: tip
组件的更新过程是异步的，我们知道修改模板中引用的响应式对象的值时，会触发组件的重新渲染。

但是在一个 `Tick` 内，即使你多次修改多个响应式对象的值，组件的重新渲染也只执行一次。

这是因为如果每次更新数据都触发组件重新渲染，那么重新渲染的次数和代价都太高了。
:::

通过前面的分析我们知道，在创建一个 `watcher` 时，如果配置 `flush` 不配置为 `sync` ，那么 `watcher` 的回调函数就会异步执行。

此时分别是通过 `queuePreFlushCb` 和 `queuePostRenderEffect` 把回调函数推入异步队列中的。

在不涉及 `suspense` 的情况下， `queuePostRenderEffect` 相当于 `queuePostFlushCb` ，我们来看它们的实现：
```ts {25,28,30,34,38}
// packages/runtime-core/src/scheduler.ts

const pendingPreFlushCbs: SchedulerCb[] = []
let activePreFlushCbs: SchedulerCb[] | null = null
let preFlushIndex = 0

const pendingPostFlushCbs: SchedulerCb[] = []
let activePostFlushCbs: SchedulerCb[] | null = null
let postFlushIndex = 0

function queueCb(
  cb: SchedulerCbs,
  activeQueue: SchedulerCb[] | null,
  pendingQueue: SchedulerCb[],
  index: number
) {
  // 判断 cb 不为 array
  if (!isArray(cb)) {
    // 如果不存在 activeQueue 或者 activeQueue中不存在 cb
    if (
      !activeQueue ||
      !activeQueue.includes(
        cb,
        (cb as SchedulerJob).allowRecurse ? index + 1 : index
      )
    ) {
      // 将其放入 pendingQueue 中
      pendingQueue.push(cb)
    }
  } else {
    // 使用解构赋值语法将数组的元素放入 pendingQueue 中
    pendingQueue.push(...cb)
  }
  // 调用 queueFlush 尝试异步执行任务
  queueFlush()
}

export function queuePreFlushCb(cb: SchedulerCb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex)
}

export function queuePostFlushCb(cb: SchedulerCbs) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex)
}
```
`Vue 3.0` 内部维护了 `pendingPreFlushCbs/activePreFlushCbs` 及 `pendingPostFlushCbs/activePostFlushCbs` 2对数组和 `queue` 数组：
* `pendingPreFlushCbs/activePreFlushCbs` 这对数组用来维护 `pre` 回调函数
* `pendingPostFlushCbs/activePostFlushCbs` 这对数组用来维护 `post` 回调函数
* `queue` 数组用作异步 `Job` 队列，在 `queueJob` 函数中维护

我们看到无论 `queueJob` 和 `queueCb` 最后都会调用 `queueFlush` 函数，我们来看下 `queueFlush` 函数的定义：
```ts
// packages/runtime-core/src/scheduler.ts

function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true
    currentFlushPromise = resolvedPromise.then(flushJobs)
  }
}
```
由代码可知，只有当 `isFlushing` 和 `isFlushPending` 都为 `false` 时，才会调用 `Promise.resolve` 异步执行 `flushJobs` ，同时将 `isFlushPending` 置为 `true` 。

那我们看一下 `flushJobs` 函数的内容：
```ts
// packages/runtime-core/src/scheduler.ts

function flushJobs(seen?: CountMap) {
  // 不在pending状态
  isFlushPending = false
  // 执行任务状态中
  isFlushing = true
  // 执行后置任务回调
  flushPreFlushCbs(seen)
  // 执行前排序
  queue.sort((a, b) => getId(a!) - getId(b!))
  // 执行 queue 中的任务
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex]
      if (job) {
        callWithErrorHandling(job, null, ErrorCodes.SCHEDULER)
      }
    }
  } finally {
    // 重置 queue 相关变量
    flushIndex = 0
    queue.length = 0
    // 执行后置任务回调
    flushPostFlushCbs(seen)
    // 不在执行任务状态中
    isFlushing = false
    currentFlushPromise = null
    // 该阶段如果 queue 或者 pendingPostFlushCbs 中又加入任务，递归调用 flushJobs 执行
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen)
    }
  }
}
```
由代码可以看到，大致的逻辑分为三部分：
* 执行前置任务队列
* 对 `queue` 根据 `id` 排序，依次执行 `queue` 中的任务
* 执行后置任务队列

其中还穿插着一些状态的转换，善后处理等。

至于为什么遍历 `queue` 之前需要根据id排序，代码中给了解释：
* 1. 组件从父组件更新到子组件。(因为父元素总是在子元素之前创建，所以渲染效果的优先级更小)
* 2. 如果在父组件更新期间卸载了组件，则可以跳过它的更新。

由于 `queuePostRenderEffect` 和 `queuePreFlushCb` 都是调用 watch 函数中创建的 `scheduler` 函数中调用的，而 `scheduler` 函数则是在生成 `runner` 时传入的 `effect` 。

而至于 `queueJob` 函数，则是在组件调用 `setupRenderEffect` 函数，生成 `update` 方法时传入 `effect` 的，当做 `effect` 的 `scheduler` 。
```ts
// packages/runtime-core/src/renderer.ts

const prodEffectOptions = {
  scheduler: queueJob,
  allowRecurse: true
}
const setupRenderEffect: SetupRenderEffectFn = (
  instance,
  initialVNode,
  container,
  anchor,
  parentSuspense,
  isSVG,
  optimized
) => {
  // create reactive effect for rendering
  instance.update = effect(function componentEffect() {
    // ...
  }, prodEffectOptions)
}
```
而我们又知道 `scheduler` 函数是在 `trigger` 函数调用时调用的，所以异步执行的起点是在派发通知的时候。

到这里，异步队列的设计就介绍完毕了，你可能会对 `isFlushPending` 和 `isFlushing` 有些疑问，为什么需要两个变量来控制呢？

从语义上来看， `isFlushPending` 用于判断是否在等待 `Promise.resolve` 执行 `flushJobs` ，而 `isFlushing` 是判断是否正在执行任务队列。

从功能上来看，它们的作用是为了确保以下两点：
* 在一个 `Tick` 内可以多次添加任务到队列中，但是任务队列会在 `Promise.resolve` 后执行
* 在执行任务队列的过程中，也可以添加新的任务到队列中，并且在当前 `Tick` 去执行剩余的任务队列
## 总结
![vue3-reactivity-async](~@assets/posts/vue3-source-reactivity/vue3-reactivity-async.png)