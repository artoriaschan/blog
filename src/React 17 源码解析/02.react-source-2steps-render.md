---
title: âš› React æºç è§£è¯»(äºŒ) - é€šè¿‡é¦–æ¬¡æ¸²æŸ“çœ‹Reactä¸¤é˜¶æ®µæ¸²æŸ“
date: 2019-10-28 00:00:00
tags: 
  - React
permalink: /pages/3685c2/
sidebar: auto
categories: 
  - React 17 æºç è§£æ
---
## å‰è¨€
åœ¨ä¸Šä¸€ç« æˆ‘ä»¬çŸ¥é“ï¼ŒReact 16 é‡‡ç”¨ `Scheduler - Reconciler - Renderer` ä¸‰å±‚æ¶æ„ã€‚è¿™ç§è°ƒæ•´æ˜¯å› ä¸º React 15 çš„æ¶æ„ä¸è¶³ä»¥èŒç§°å¼‚æ­¥æ›´æ–°ã€‚

React 15 å¯¹ React 16 æå‡ºçš„éœ€æ±‚æ˜¯Diffæ›´æ–°åº”ä¸ºå¯ä¸­æ–­çš„ï¼Œé‚£ä¹ˆæ­¤æ—¶åˆå‡ºç°äº†ä¸¤ä¸ªæ–°çš„ä¸¤ä¸ªé—®é¢˜:ä¸­æ–­æ–¹å¼å’Œåˆ¤æ–­æ ‡å‡†;

Reactå›¢é˜Ÿé‡‡ç”¨çš„æ˜¯ `åˆä½œå¼è°ƒåº¦`ï¼Œå³ä¸»åŠ¨ä¸­æ–­å’Œæ§åˆ¶å™¨å‡ºè®©ã€‚åˆ¤æ–­æ ‡å‡†ä¸ºè¶…æ—¶æ£€æµ‹ã€‚åŒæ—¶è¿˜éœ€è¦ä¸€ç§æœºåˆ¶æ¥å‘ŠçŸ¥ä¸­æ–­çš„ä»»åŠ¡åœ¨ä½•æ—¶æ¢å¤/é‡æ–°æ‰§è¡Œã€‚ React å€Ÿé‰´äº†æµè§ˆå™¨çš„ `requestIdleCallback` æ¥å£ï¼Œå½“æµè§ˆå™¨æœ‰å‰©ä½™æ—¶é—´æ—¶é€šçŸ¥æ‰§è¡Œã€‚

å¹¶ä¸” React 16 å°†æ›´æ–°åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µï¼šrender é˜¶æ®µå’Œ commit é˜¶æ®µã€‚render é˜¶æ®µåˆ™æ˜¯ä¸º Fiber é˜¶æ®µæ‰“ä¸Šæ ‡è®°ï¼Œè€Œ commit é˜¶æ®µåˆ™æ˜¯æ ¹æ® render é˜¶æ®µçš„æ ‡è®°åŒæ­¥æ‰§è¡Œå¯¹åº”çš„æ¸²æŸ“æ“ä½œã€‚
### Concurrent Mode
Reactç›®å‰åªæœ‰ä¸€ç§è°ƒåº¦æ¨¡å¼ï¼šåŒæ­¥æ¨¡å¼ã€‚åªæœ‰ç­‰ Concurrent è°ƒåº¦æ¨¡å¼æ­£å¼å‘å¸ƒï¼Œæ‰èƒ½ä½¿ç”¨ç¬¬äºŒç§æ¨¡å¼ã€‚

æˆ‘ä»¬ç»“åˆä¸€ä¸‹æ¡ˆä¾‹æ¥æ¢è®¨ä¸‹è¿™ä¸¤ç§è°ƒåº¦æ¨¡å¼çš„åŒºåˆ«ã€‚
```jsx
// App.js
import {createRef, Component} from "react";
import './App.css';

class App extends Component{
  constructor(props) {
    super();
    this.state = {
      count: 0
    }
    this.buttonRef = createRef();
  }

  componentDidMount() {
    const buttonElm = this.buttonRef.current;
    setTimeout( () => {
      console.log("æ›´æ–°ä»»åŠ¡1");
      this.setState((prevState)=>({
        count: prevState.count + 1
      }) )
    }, 500 )

    setTimeout( () => {
      console.log("æ›´æ–°ä»»åŠ¡2");
      buttonElm.click()
    }, 500 )
  }

  handleButtonClick = () => {
    this.setState((prevState)=>({
      count: prevState.count + 1
    }) )
  }

  render() {
    return (
      <div className="App">
        Hello,
        <span>react</span>
        {Array.from(new Array(8000)).map( (v,index) =>
          <span key={index}>{this.state.count}</span>
        )}
        <button ref={this.buttonRef} onClick={this.handleButtonClick}>è®¡æ•°</button>
      </div>
    )
  }
}
export default App;

// index.js
// ...
ReactDOM.render(<App />, document.getElementById('root'));
```
è¿è¡Œæ¡ˆä¾‹åï¼ŒæŸ¥çœ‹Chromeæ€§èƒ½åˆ†æå›¾ï¼š
![react-sync-profile](~@/assets/posts/react-source-2steps-render/react-sync-profile.png)

ä»ç»“æœå¯çŸ¥ï¼Œå°½ç®¡ä¸¤ä¸ªä»»åŠ¡ç†åº”â€œåŒæ—¶â€è¿è¡Œï¼Œä½†reactä¼šå…ˆæŠŠç¬¬ä¸€ä¸ªä»»åŠ¡æ‰§è¡Œå®Œåå†æ‰§è¡Œç¬¬äºŒä¸ªä»»åŠ¡ï¼Œè¿™å°±æ˜¯reactåŒæ­¥æ¨¡å¼ï¼š
> å¤šä¸ªä»»åŠ¡æ—¶ï¼Œreactéƒ½ä¼šæŒ‰ç…§ä»»åŠ¡é¡ºåºä¸€ä¸ªä¸€ä¸ªæ‰§è¡Œï¼Œå®ƒæ— æ³•ä¿è¯åé¢çš„ä»»åŠ¡èƒ½åœ¨æœ¬åº”æ‰§è¡Œçš„æ—¶é—´æ‰§è¡Œã€‚ï¼ˆå…¶å®å°±æ˜¯JSæœ¬èº«ç‰¹æ€§EventLoopçš„å±•ç°ã€‚æ¯”å¦‚åªè¦ä¸€ä¸ªwhileå¾ªç¯è¶³å¤Ÿä¹…ï¼Œç†åº”åœ¨æŸä¸ªæ—¶åˆ»æ‰§è¡Œçš„æ–¹æ³•å°±ä¼šè¢«å»¶è¿Ÿåˆ°whileå¾ªç¯ç»“æŸåæ‰è¿è¡Œã€‚ï¼‰

è€Œ Concurrent è°ƒåº¦æ¨¡å¼æ˜¯ä¸€ç§æ”¯æŒ**åŒæ—¶æ‰§è¡Œå¤šä¸ªæ›´æ–°ä»»åŠ¡**çš„è°ƒåº¦æ¨¡å¼ã€‚

å…³äº Concurrent æ¨¡å¼çš„è§£é‡Šï¼Œå®˜ç½‘[ä½¿ç”¨ç‰ˆæœ¬æ§åˆ¶ä½œä¸ºæ¯”å–»](https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#blocking-vs-interruptible-rendering)çš„è§£é‡Šå°±å¾ˆå¥½çš„å±•ç¤ºäº† Concurrent å…·ä½“æ‰€åšçš„äº‹æƒ…:
::: tip ç‰ˆæœ¬æ§åˆ¶æ¯”å–»
å¦‚æœä½ åœ¨å›¢é˜Ÿä¸­å·¥ä½œï¼Œä½ å¯èƒ½ä½¿ç”¨äº†åƒ Git è¿™æ ·çš„ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿå¹¶åœ¨åˆ†æ”¯ä¸Šè¿›è¡Œå·¥ä½œã€‚å½“ä¸€ä¸ªåˆ†æ”¯å‡†å¤‡å°±ç»ªæ—¶ï¼Œä½ å¯ä»¥å°†ä½ çš„å·¥ä½œåˆå¹¶åˆ° master ä¸­ï¼Œä»¥ä¾¿ä»–äººæ‹‰å–ã€‚

åœ¨ç‰ˆæœ¬æ§åˆ¶å­˜åœ¨ä¹‹å‰ï¼Œå¼€å‘å·¥ä½œæµç¨‹æœ‰å¾ˆå¤§çš„ä¸åŒã€‚ä¸å­˜åœ¨åˆ†æ”¯çš„æ¦‚å¿µã€‚å¦‚æœä½ æƒ³ç¼–è¾‘æŸäº›æ–‡ä»¶ï¼Œä½ å¿…é¡»å‘Šè¯‰æ‰€æœ‰äººåœ¨ä½ å®Œæˆç¼–è¾‘å·¥ä½œä¹‹å‰ä¸è¦è§¦ç¢°è¿™äº›æ–‡ä»¶ã€‚ä½ ç”šè‡³ä¸èƒ½åŒæ—¶å’Œé‚£ä¸ªäººç ”ç©¶å®ƒä»¬ â€”â€” å®é™…ä¸Š, ä½ è¢«å®ƒä»¬ é˜»å¡ äº†ã€‚

è¿™è¯´æ˜äº†åŒ…æ‹¬ React åœ¨å†…çš„ UI åº“åœ¨ç›®å‰é€šå¸¸æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚ä¸€æ—¦å®ƒä»¬å¼€å§‹æ¸²æŸ“ä¸€æ¬¡æ›´æ–°ï¼Œå®ƒä»¬ä¸èƒ½ä¸­æ–­åŒ…æ‹¬åˆ›å»ºæ–°çš„ DOM èŠ‚ç‚¹å’Œè¿è¡Œç»„ä»¶ä¸­ä»£ç åœ¨å†…çš„å·¥ä½œã€‚æˆ‘ä»¬ç§°è¿™ç§æ–¹æ³•ä¸º â€œé˜»å¡æ¸²æŸ“â€ã€‚

åœ¨ Concurrent æ¨¡å¼ä¸­ï¼Œæ¸²æŸ“ä¸æ˜¯é˜»å¡çš„ã€‚å®ƒæ˜¯å¯ä¸­æ–­çš„ã€‚è¿™æ”¹å–„äº†ç”¨æˆ·ä½“éªŒã€‚å®ƒåŒæ—¶è§£é”äº†ä»¥å‰ä¸å¯èƒ½çš„æ–°åŠŸèƒ½ã€‚åœ¨æˆ‘ä»¬æŸ¥çœ‹ä¸‹ä¸€ä¸ª ç« èŠ‚çš„å…·ä½“ä¾‹å­ä¹‹å‰ï¼Œæˆ‘ä»¬å°†å¯¹æ–°åŠŸèƒ½åšä¸€ä¸ªé«˜çº§çš„æ¦‚è¿°ã€‚
:::
è¿™ä¸ªä¾‹å­å¾ˆå…·ä½“çš„ç‚¹å‡ºäº† Concurrent æ¨¡å¼æ‰€è¦è¾¾åˆ°çš„æ•ˆæœï¼Œé‚£å°±æ˜¯å¯ä¸­æ–­æ¸²æŸ“ã€‚

é‚£ä¹ˆæˆ‘ä»¬ä¿®æ”¹ä¸‹ä¸Šè¿°çš„ä¾‹å­ï¼Œè®©å…¶åˆ‡æ¢åˆ° Concurrent Modeã€‚å¯ä»¥æ ¹æ®å®˜ç½‘çš„[æ–‡æ¡£](https://zh-hans.reactjs.org/docs/concurrent-mode-adoption.html#enabling-concurrent-mode)è¿›è¡Œä½“éªŒå®éªŒæ€§åŠŸèƒ½ã€‚

ä¸»è¦å°±æ˜¯åˆ‡æ¢å…¥å£æ¸²æŸ“æ–¹æ³•ï¼š
```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
// ReactDOM.render(<App />, document.getElementById('root'));
ReactDOM.unstable_createRoot(document.getElementById('root')).render(<App />);
```

é‚£ä¹ˆå…³äºAppç»„ä»¶ä¸­ï¼Œä¿®æ”¹éƒ¨åˆ†ä»£ç ï¼š
```jsx
componentDidMount() {
  const buttonElm = this.buttonRef.current;
  setTimeout( () => {
    console.log("æ›´æ–°ä»»åŠ¡1");
    this.setState((prevState)=>({
      count: prevState.count + 1
    }) )
  }, 500 )

  setTimeout( () => {
    console.log("æ›´æ–°ä»»åŠ¡2");
    buttonElm.click()
  }, 600 )
}

handleButtonClick = () => {
  this.setState((prevState)=>({
    count: prevState.count + 2
  }) )
}
```
ä¸Šè¿°ä»£ç çš„ä¿®æ”¹ä¸»è¦æ˜¯å°†ä¸¤ä¸ªæ›´æ–°ä»»åŠ¡åŒºåˆ†å¼€æ¥ï¼Œæ–¹ä¾¿åœ¨æ€§èƒ½åˆ†æå›¾ä¸Šè¿›è¡Œåˆ†æï¼š
![react-concurrent-profile](~@/assets/posts/react-source-2steps-render/react-concurrent-profile.png)
é€šè¿‡ä¸Šé¢çš„æ€§èƒ½åˆ†æå›¾æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œåœ¨ Concurrent æ¨¡å¼ä¸‹ï¼Œå¯ä»¥ä¸­æ–­å·²ç»è¿›è¡Œçš„æ¸²æŸ“ï¼Œä¼˜å…ˆè¿›è¡Œé«˜ä¼˜å…ˆçº§çš„æ›´æ–°æ¸²æŸ“ã€‚é‚£ä¹ˆ Concurrent æ¨¡å¼æ˜¯å¦‚ä½•åšåˆ°ä¸­æ–­æ›´æ–°çš„å‘¢ï¼Ÿ

åœ¨å®ç°è™šæ‹Ÿ DOM çš„æƒ…å†µä¸‹ï¼Œä¸€æ•´ä¸ªæ¸²æŸ“æµç¨‹åŒ…å«â€œåŸºäºçŠ¶æ€æ›´æ–°è™šæ‹ŸèŠ‚ç‚¹â€ã€â€œå°†æ›´æ–°åçš„è™šæ‹ŸèŠ‚ç‚¹åº”ç”¨äºæ¸²æŸ“â€ä¸¤ä¸ªé˜¶æ®µã€‚React 16 å°†å‰è€…ç§°ä¸º render é˜¶æ®µï¼Œå³æ¸²æŸ“è™šæ‹ŸèŠ‚ç‚¹ï¼›åè€…ç§°ä¸º commit é˜¶æ®µï¼Œå³æäº¤è™šæ‹ŸèŠ‚ç‚¹ï¼Œå®Œæˆ dom æ ‘çš„æ¸²æŸ“ç­‰ã€‚ä¸ºäº†ä¿è¯è§†å›¾çš„ä¸€è‡´æ€§ï¼Œcommit é˜¶æ®µæ˜¯ä¸èƒ½è¢«æ‰“æ–­çš„ï¼›render é˜¶æ®µå´å¯ä»¥å¢é‡æ‰§è¡Œã€‚

è‡³äº Concurrent æ¨¡å¼è¯¦ç»†çš„å®ç°åŸç†ã€ä¼˜å…ˆçº§çš„å®ç°ç­‰ï¼Œæˆ‘ä»¬å…ˆæš‚æ—¶ä¸è°ˆã€‚æˆ‘ä»¬å…ˆæŠŠç›®å…‰èšç„¦åœ¨ä¸Šæ–‡æ‰€è¯´çš„æ¸²æŸ“æµç¨‹çš„ä¸¤ä¸ªé˜¶æ®µä¸Šã€‚
### Reactçš„å…¶ä»–å…¥å£å‡½æ•°
å½“å‰Reactå…±æœ‰ä¸‰ç§æ¨¡å¼ï¼š
* `legacy` ï¼Œè¿™æ˜¯ `å½“å‰React` ä½¿ç”¨çš„æ–¹å¼ã€‚å½“å‰æ²¡æœ‰è®¡åˆ’åˆ é™¤æœ¬æ¨¡å¼ï¼Œä½†æ˜¯è¿™ä¸ªæ¨¡å¼å¯èƒ½ä¸æ”¯æŒä¸€äº›æ–°åŠŸèƒ½ã€‚
* `blocking` ï¼Œå¼€å¯ `éƒ¨åˆ†concurrentæ¨¡å¼ç‰¹æ€§` çš„ `ä¸­é—´æ¨¡å¼` ã€‚ç›®å‰æ­£åœ¨ `å®éªŒä¸­` ã€‚ä½œä¸º `è¿ç§»` åˆ° `concurrentæ¨¡å¼` çš„ `ç¬¬ä¸€ä¸ªæ­¥éª¤` ã€‚
* `concurrent` ï¼Œ `é¢å‘æœªæ¥` çš„å¼€å‘æ¨¡å¼ã€‚æˆ‘ä»¬ä¹‹å‰è®²çš„ `ä»»åŠ¡ä¸­æ–­/ä»»åŠ¡ä¼˜å…ˆçº§` éƒ½æ˜¯é’ˆå¯¹ `concurrentæ¨¡å¼` ã€‚

ä½ å¯ä»¥ä»ä¸‹è¡¨çœ‹å‡ºå„ç§æ¨¡å¼å¯¹ç‰¹æ€§çš„æ”¯æŒï¼š

|   | legacy æ¨¡å¼  | blocking æ¨¡å¼  | concurrent æ¨¡å¼  |
|---  |---  |---  |---  |
|[String Refs](https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs)  |âœ…  |ğŸš«**  |ğŸš«**  |
|[Legacy Context](https://zh-hans.reactjs.org/docs/legacy-context.html) |âœ…  |ğŸš«**  |ğŸš«**  |
|[findDOMNode](https://zh-hans.reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage)  |âœ…  |ğŸš«**  |ğŸš«**  |
|[Suspense](https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html#what-is-suspense-exactly) |âœ…  |âœ…  |âœ…  |
|[SuspenseList](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#suspenselist) |ğŸš«  |âœ…  |âœ…  |
|Suspense SSR + Hydration |ğŸš«  |âœ…  |âœ…  |
|Progressive Hydration  |ğŸš«  |âœ…  |âœ…  |
|Selective Hydration  |ğŸš«  |ğŸš«  |âœ…  |
|Cooperative Multitasking |ğŸš«  |ğŸš«  |âœ…  |
|Automatic batching of multiple setStates     |ğŸš«* |âœ…  |âœ…  |
|[Priority-based Rendering](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#splitting-high-and-low-priority-state) |ğŸš«  |ğŸš«  |âœ…  |
|[Interruptible Prerendering](https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#interruptible-rendering) |ğŸš«  |ğŸš«  |âœ…  |
|[useTransition](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#transitions)  |ğŸš«  |ğŸš«  |âœ…  |
|[useDeferredValue](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#deferring-a-value) |ğŸš«  |ğŸš«  |âœ…  |
|[Suspense Reveal "Train"](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#suspense-reveal-train)  |ğŸš«  |ğŸš«  |âœ…  |
::: warning
è¯¥è¡¨æ ¼ä¸ºå®˜ç½‘åšæ–‡ ã€Šä½¿ç”¨ Concurrent æ¨¡å¼ï¼ˆå®éªŒæ€§ï¼‰ã€‹ä¸­ï¼Œ[ç‚¹æ­¤å¤„](https://zh-hans.reactjs.org/docs/concurrent-mode-adoption.html#why-so-many-modes) æŸ¥çœ‹åŸæ–‡
:::
*ï¼š`legacy`æ¨¡å¼åœ¨åˆæˆäº‹ä»¶ä¸­æœ‰è‡ªåŠ¨æ‰¹å¤„ç†çš„åŠŸèƒ½ï¼Œä½†ä»…é™äºä¸€ä¸ªæµè§ˆå™¨ä»»åŠ¡ã€‚é`React`äº‹ä»¶æƒ³ä½¿ç”¨è¿™ä¸ªåŠŸèƒ½å¿…é¡»ä½¿ç”¨ `unstable_batchedUpdates`ã€‚åœ¨`blocking`æ¨¡å¼å’Œ`concurrent`æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰çš„`setState`åœ¨é»˜è®¤æƒ…å†µä¸‹éƒ½æ˜¯æ‰¹å¤„ç†çš„ã€‚

**ï¼šä¼šåœ¨å¼€å‘ä¸­å‘å‡ºè­¦å‘Šã€‚

æ¨¡å¼çš„å˜åŒ–å½±å“æ•´ä¸ªåº”ç”¨çš„å·¥ä½œæ–¹å¼ï¼Œæ‰€ä»¥æ— æ³•åªé’ˆå¯¹æŸä¸ªç»„ä»¶å¼€å¯ä¸åŒæ¨¡å¼ã€‚

åŸºäºæ­¤åŸå› ï¼Œå¯ä»¥é€šè¿‡ä¸åŒçš„`å…¥å£å‡½æ•°`å¼€å¯ä¸åŒæ¨¡å¼ï¼š
- `legacy` -- `ReactDOM.render(<App />, rootNode)`
- `blocking` -- `ReactDOM.createBlockingRoot(rootNode).render(<App />)`
- `concurrent` -- `ReactDOM.createRoot(rootNode).render(<App />)`

> ä½ å¯ä»¥åœ¨[è¿™é‡Œ](https://zh-hans.reactjs.org/docs/concurrent-mode-adoption.html#why-so-many-modes)çœ‹åˆ°`React`å›¢é˜Ÿè§£é‡Šä¸ºä»€ä¹ˆä¼šæœ‰è¿™ä¹ˆå¤šæ¨¡å¼

è™½ç„¶ä¸åŒæ¨¡å¼çš„`å…¥å£å‡½æ•°`ä¸åŒï¼Œä½†æ˜¯ä»–ä»¬ä»…å¯¹`fiber.mode`å˜é‡äº§ç”Ÿå½±å“ï¼Œå¯¹æˆ‘ä»¬åœ¨[æµç¨‹æ¦‚è§ˆ](./reactdom.html#æµç¨‹æ¦‚è§ˆ)ä¸­æè¿°çš„æµç¨‹å¹¶æ— å½±å“ã€‚

## æ€»ä½“æµç¨‹
React 16 æ€»ä½“æµç¨‹å¤§è‡´å¦‚ä¸‹ï¼š
![render-commit-process](~@/assets/posts/react-source-2steps-render/render-commit-process.png)
é‚£ä¹ˆæˆ‘ä»¬æ ¹æ®ä¸€ä¸ªä¾‹å­æ¥æ¢³ç†é¦–æ¬¡æ¸²æŸ“çš„æµç¨‹ï¼š
```jsx
// App.js
import {useState} from "react";
import './App.css';

function App() {
  const [state, setState] = useState({
    count: 0
  });

  function handleButtonClick(){
    setState({
      ...state,
      count: state.count + 1
    })
  }

  return (
    <div className="App">
      Hello,
      <span>react</span>
      <p>{state.count}</p>
      <button onClick={handleButtonClick}>è®¡æ•°</button>
    </div>
  );
}

export default App;

// index.js
ReactDOM.render(<App />, document.getElementById('root'));
```
## Render é˜¶æ®µ
render é˜¶æ®µå¼€å§‹äº `performSyncWorkOnRoot` æˆ– `performConcurrentWorkOnRoot` æ–¹æ³•çš„è°ƒç”¨ã€‚è¿™å–å†³äºæœ¬æ¬¡æ›´æ–°æ˜¯åŒæ­¥æ›´æ–°è¿˜æ˜¯å¼‚æ­¥æ›´æ–°ã€‚
```javascript {19,28}
// packages/react-reconciler/src/ReactFiberWorkLoop.old.js

// This is the entry point for synchronous tasks that don't go
// through Scheduler
function performSyncWorkOnRoot(root) {
  // ...
  flushPassiveEffects();

  let lanes;
  let exitStatus;
  if (
    root === workInProgressRoot &&
    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)
  ) {
    // ...
  } else {
    // å¯¹äºé¦–æ¬¡æ¸²æŸ“ï¼ŒworkInProgressRoot ä¸º null
    // æœ€ç»ˆä¼šèµ°åˆ°è¿™ä¸ªåˆ†æ”¯æ‰§è¡Œ renderRootSync å‡½æ•°
    lanes = getNextLanes(root, NoLanes);
    exitStatus = renderRootSync(root, lanes);
  }

  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
    executionContext |= RetryAfterError;
    // ...
    lanes = getLanesToRetrySynchronouslyOnError(root);
    if (lanes !== NoLanes) {
      exitStatus = renderRootSync(root, lanes);
    }
  }

  if (exitStatus === RootFatalErrored) {
    const fatalError = workInProgressRootFatalError;
    prepareFreshStack(root, NoLanes);
    markRootSuspended(root, lanes);
    ensureRootIsScheduled(root, now());
    throw fatalError;
  }

  // We now have a consistent tree. Because this is a sync render, we
  // will commit it even if something suspended.
  const finishedWork: Fiber = (root.current.alternate: any);
  root.finishedWork = finishedWork;
  root.finishedLanes = lanes;
  commitRoot(root);

  // Before exiting, make sure there's a callback scheduled for the next
  // pending level.
  ensureRootIsScheduled(root, now());

  return null;
}
```
åœ¨ä¸Šè¿°ä»£ç çš„æ³¨é‡Šä¸­ï¼Œæˆ‘ä»¬è§£é‡Šäº†é¦–æ¬¡æ¸²æŸ“ä¼šæ‰§è¡Œåˆ° else åˆ†æ”¯ï¼Œå¹¶æ‰§è¡Œ renderRootSync å‡½æ•°ï¼Œé‚£ä¹ˆæˆ‘ä»¬çœ‹ä¸€ä¸‹è¯¥å‡½æ•°çš„å®šä¹‰ï¼š
```javascript {18-25}
// packages/react-reconciler/src/ReactFiberWorkLoop.old.js

function renderRootSync(root: FiberRoot, lanes: Lanes) {
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  const prevDispatcher = pushDispatcher();

  // If the root or lanes have changed, throw out the existing stack
  // and prepare a fresh one. Otherwise we'll continue where we left off.
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes);
    startWorkOnPendingInteractions(root, lanes);
  }

  const prevInteractions = pushInteractions(root);
  // ...

  do {
    try {
      workLoopSync();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);

  resetContextDependencies();
  if (enableSchedulerTracing) {
    popInteractions(((prevInteractions: any): Set<Interaction>));
  }

  executionContext = prevExecutionContext;
  popDispatcher(prevDispatcher);
  // ...

  // Set this to null to indicate there's no in-progress render.
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;

  return workInProgressRootExitStatus;
}
```
æˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨ `renderRootSync` å‡½æ•°ä¸­æœ€æ ¸å¿ƒçš„ä¸€å—ä»£ç åˆ™æ˜¯ä¸€å— `do...while();` å¾ªç¯ï¼š
```javascript
do {
  try {
    workLoopSync();
    break;
  } catch (thrownValue) {
    handleError(root, thrownValue);
  }
} while (true);
```
è€Œ `workLoopSync` å‡½æ•°çš„å®šä¹‰å¦‚ä¸‹ï¼Œé€šè¿‡ while å¾ªç¯åŒæ­¥æ‰§è¡Œ `performUnitOfWork` å‡½æ•°ï¼Œä¼ å…¥çš„å‚æ•°åˆ™æ˜¯ `workInProgress`ï¼š
```javascript {8}
// packages/react-reconciler/src/ReactFiberWorkLoop.old.js

// The work loop is an extremely hot path. Tell Closure not to inline it.
/** @noinline */
function workLoopSync() {
  // Already timed out, so perform work without checking if we need to yield.
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
```
é‚£ä¹ˆæˆ‘ä»¬æ¥ç€çœ‹ `performUnitOfWork` å‡½æ•°çš„æ‰§è¡Œé€»è¾‘æ˜¯ä»€ä¹ˆï¼š
```javascript {12,15}
// packages/react-reconciler/src/ReactFiberWorkLoop.old.js

function performUnitOfWork(unitOfWork: Fiber): void {
  // The current, flushed, state of this fiber is the alternate. Ideally
  // nothing should rely on this, but relying on it here means that we don't
  // need an additional field on the work in progress.
  const current = unitOfWork.alternate;
  // ...
  let next;
  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {
    startProfilerTimer(unitOfWork);
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
  } else {
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
  }
  // ...
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next === null) {
    // If this doesn't spawn new work, complete the current work.
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }

  ReactCurrentOwner.current = null;
}
```
`performUnitOfWork` å‡½æ•°çš„é€»è¾‘å¾ˆç®€å•ï¼Œå°½ç®¡æœ‰å‡ ä¸ªåˆ¤æ–­ï¼Œä½†å¤§è‡´é€»è¾‘å°±æ˜¯è°ƒç”¨ `beginWork` å‡½æ•°è·å¾— `next Fiber`ï¼Œè‹¥ `next Fiber` ä¸º `null` ï¼Œåˆ™è°ƒç”¨ `completeUnitOfWork` å‡½æ•°ç»“æŸå½“å‰ä»»åŠ¡ï¼›è‹¥ `next` ä¸ä¸ºç©ºï¼Œåˆ™å°† `next` èµ‹å€¼ç»™ `workInProgress` ï¼Œä»¥ä¾¿ä½¿ `workLoopSync` å‡½æ•°ä¸­å¾ªç¯çš„æ¡ä»¶ç»§ç»­æˆç«‹ã€‚

å…¶ä¸­çš„ `(unitOfWork.mode & ProfileMode) !== NoMode` åˆ¤æ–­æ¡ä»¶åˆ™æ˜¯éœ€è¦æˆ‘ä»¬æ¥ç†è§£ Fiber ä¸­çš„ mode è¿™ä¸ªæšä¸¾å±æ€§ä»£è¡¨ä»€ä¹ˆæ„æ€åŠæ‰€æœ‰çš„æšä¸¾å€¼æœ‰å“ªäº›ï¼š
```javascript
// packages/react-reconciler/src/ReactInternalTypes.js

// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.
export type Fiber = {|
  // ...
  // Bitfield that describes properties about the fiber and its subtree. E.g.
  // the ConcurrentMode flag indicates whether the subtree should be async-by-
  // default. When a fiber is created, it inherits the mode of its
  // parent. Additional flags can be set at creation time, but after that the
  // value should remain unchanged throughout the fiber's lifetime, particularly
  // before its child fibers are created.
  mode: TypeOfMode,
  // ...
|};

// packages/react-reconciler/src/ReactTypeOfMode.js

export type TypeOfMode = number;

export const NoMode = 0b00000;  // æ™®é€šæ¨¡å¼ï¼ŒåŒæ­¥æ¸²æŸ“
export const StrictMode = 0b00001;  // ä¸¥æ ¼æ¨¡å¼ï¼Œç”¨æ¥æ£€æµ‹æ˜¯å¦å­˜åœ¨åºŸå¼ƒAPI
// TODO: Remove BlockingMode and ConcurrentMode by reading from the root
// tag instead
export const BlockingMode = 0b00010;  // æ¸è¿›è¿ç§»æ¨¡å¼ï¼Œconcurrent æ¨¡å¼çš„â€œä¼˜é›…é™çº§â€ç‰ˆæœ¬
export const ConcurrentMode = 0b00100;  // å¹¶å‘æ¨¡å¼ï¼Œå¼‚æ­¥æ¸²æŸ“
export const ProfileMode = 0b01000; // æ€§èƒ½æµ‹è¯•æ¨¡å¼ï¼Œç”¨æ¥æ£€æµ‹å“ªé‡Œå­˜åœ¨æ€§èƒ½é—®é¢˜
export const DebugTracingMode = 0b10000;  // DEBUGæ¨¡å¼
```
ä»ä»£ç ä¸­çš„æ³¨é‡Šä¸­æˆ‘ä»¬å¯ä»¥äº†è§£åˆ°è¿™æ˜¯ä¸€ä¸ªä¸€ä¸ªç”¨æ¥æè¿°æ¸²æŸ“æ¨¡å¼çš„æ ‡å¿—ä½ï¼Œç»§æ‰¿è‡ª Fiber çš„çˆ¶èŠ‚ç‚¹ã€‚è€Œå…¶ä»–æšä¸¾å€¼çš„å«ä¹‰åˆ™åœ¨ä¸Šè¿°ä»£ç ä¸­æ ‡è®°å‡ºæ¥ã€‚

æ‰€ä»¥æˆ‘ä»¬å†æ¥çœ‹é‚£ä¸ªåˆ¤æ–­ `(unitOfWork.mode & ProfileMode) !== NoMode`ï¼Œè¿™è¯´æ˜åˆ¤æ–­å½“å‰çš„Fiber çš„æ¨¡å¼æ˜¯å¦ä¸º ProfileModeï¼Œè¯¥æ¨¡å¼ä¸€èˆ¬åœ¨å¼€å‘é˜¶æ®µè‡ªåŠ¨å¼€å¯ï¼Œç”¨æ¥åšæ€§èƒ½æ£€æµ‹ã€‚
```javascript
startProfilerTimer(unitOfWork);
stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
```
è¿™ä¸¤å¥ä»£ç åˆ™æ˜¯ä¿®æ”¹ Fiber ä¸­çš„å±æ€§å€¼ï¼Œç”¨æ¥åšæ—¶é—´ç»Ÿè®¡çš„ï¼š
```javascript

// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.
export type Fiber = {|
  // ...
  // Time spent rendering this Fiber and its descendants for the current update.
  // This tells us how well the tree makes use of sCU for memoization.
  // It is reset to 0 each time we render and only updated when we don't bailout.
  // This field is only set when the enableProfilerTimer flag is enabled.
  actualDuration?: number,

  // If the Fiber is currently active in the "render" phase,
  // This marks the time at which the work began.
  // This field is only set when the enableProfilerTimer flag is enabled.
  actualStartTime?: number,

  // Duration of the most recent render time for this Fiber.
  // This value is not updated when we bailout for memoization purposes.
  // This field is only set when the enableProfilerTimer flag is enabled.
  selfBaseDuration?: number,
  // ...
|};
```
æ‰€ä»¥ä»¥åé‡åˆ°ç›¸å…³çš„ä»£ç å¯ä»¥å…ˆå¿½ç•¥ï¼Œåªæ˜¯å’Œæ€§èƒ½åˆ†æç›¸å…³çš„ä»£ç ã€‚é‚£ä¹ˆæˆ‘ä»¬ç»§ç»­åˆ†æä¸»æµç¨‹ã€‚
### beginWork
é¦–å…ˆä» `rootFiber` å¼€å§‹å‘ä¸‹æ·±åº¦ä¼˜å…ˆéå†ã€‚ä¸ºéå†åˆ°çš„æ¯ä¸ª Fiber èŠ‚ç‚¹è°ƒç”¨ `beginWork` æ–¹æ³•ã€‚

è¯¥æ–¹æ³•ä¼šæ ¹æ®ä¼ å…¥çš„ `Fiber èŠ‚ç‚¹` åˆ›å»º `å­Fiber èŠ‚ç‚¹` ï¼Œå¹¶å°†è¿™ä¸¤ä¸ª `Fiber èŠ‚ç‚¹` è¿æ¥èµ·æ¥ã€‚

å®Œæ•´çš„ `beginWork` å‡½æ•°çš„ä»£ç æœ‰400å¤šè¡Œï¼Œè¿™é‡Œæˆ‘ä»¬åªè®²ä¸»å¹²éƒ¨åˆ†ã€‚é¦–å…ˆæˆ‘ä»¬çœ‹ä¸€ä¸‹ `beginWork` çš„å®šä¹‰ï¼š
```javascript
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  // ...
}
```
å…¶ä¸­ä¼ å‚ï¼š
* **current** ï¼šå½“å‰ç»„ä»¶å¯¹åº”çš„FiberèŠ‚ç‚¹åœ¨ä¸Šä¸€æ¬¡æ›´æ–°æ—¶çš„FiberèŠ‚ç‚¹ï¼Œå³ workInProgress.alternate
* **workInProgress** ï¼šå½“å‰ç»„ä»¶å¯¹åº”çš„FiberèŠ‚ç‚¹
* **renderLanes** ï¼šä¼˜å…ˆçº§ç›¸å…³ï¼Œåœ¨è®²è§£Scheduleræ—¶å†è®²è§£

ä»åŒç¼“å­˜æœºåˆ¶ä¸€èŠ‚æˆ‘ä»¬çŸ¥é“ï¼Œé™¤ `rootFiber` ä»¥å¤–ï¼Œ ç»„ä»¶ `mount` æ—¶ï¼Œç”±äºæ˜¯é¦–æ¬¡æ¸²æŸ“ï¼Œæ˜¯ä¸å­˜åœ¨å½“å‰ç»„ä»¶å¯¹åº”çš„ `Fiber` èŠ‚ç‚¹åœ¨ä¸Šä¸€æ¬¡æ›´æ–°æ—¶çš„ `Fiber` èŠ‚ç‚¹ï¼Œå³ mount æ—¶ `current === null`ã€‚

ç»„ä»¶ `update` æ—¶ï¼Œç”±äºä¹‹å‰å·²ç» `s` è¿‡ï¼Œæ‰€ä»¥ `current !== null`ã€‚

æ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡ `current === null` æ¥åŒºåˆ†ç»„ä»¶æ˜¯å¤„äº `mount` è¿˜æ˜¯ `update` ã€‚

åŸºäºæ­¤åŸå› ï¼Œ`beginWork` å‡½æ•°çš„å·¥ä½œå¯ä»¥åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š
* `update` æ—¶ï¼šå¦‚æœ `current` å­˜åœ¨ï¼Œåœ¨æ»¡è¶³ä¸€å®šæ¡ä»¶æ—¶å¯ä»¥å¤ç”¨ `current` èŠ‚ç‚¹ï¼Œè¿™æ ·å°±èƒ½å…‹éš† `current.child` ä½œä¸º `workInProgress.child` ï¼Œè€Œä¸éœ€è¦æ–°å»º `workInProgress.child`ã€‚
* `mount` æ—¶ï¼šé™¤ `fiberRootNode` ä»¥å¤–ï¼Œ`current === null`ã€‚ä¼šæ ¹æ® `fiber.tag` ä¸åŒï¼Œåˆ›å»ºä¸åŒç±»å‹çš„ `å­FiberèŠ‚ç‚¹`
```javascript
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  const updateLanes = workInProgress.lanes;
  // ...
  if (current !== null) {
    // ...
  } else {
    didReceiveUpdate = false;
  }

  // Before entering the begin phase, clear pending update priority.
  // TODO: This assumes that we're about to evaluate the component and process
  // the update queue. However, there's an exception: SimpleMemoComponent
  // sometimes bails out later in the begin phase. This indicates that we should
  // move this assignment out of the common path and into each branch.
  workInProgress.lanes = NoLanes;

  switch (workInProgress.tag) {
    case IndeterminateComponent: 
      // ...
    case LazyComponent: 
      // ...
    case FunctionComponent: 
      // ...
    case ClassComponent: 
      // ...
    case HostRoot:
      // ...
    case HostComponent:
      // ...
    case HostText:
      // ...
    case SuspenseComponent:
      // ...
    case HostPortal:
      // ...
    case ForwardRef: 
      // ...
    case Fragment:
      // ...
    case Mode:
      // ...
    case Profiler:
      // ...
    case ContextProvider:
      // ...
    case ContextConsumer:
      // ...
    case MemoComponent: 
      // ...
    case SimpleMemoComponent: 
      // ...
    case IncompleteClassComponent: 
      // ...
    case SuspenseListComponent: 
      // ...
    case FundamentalComponent: 
      // ...
    case ScopeComponent: 
      // ...
    case Block: 
      // ...
    case OffscreenComponent: 
      // ...
    case LegacyHiddenComponent: 
      // ...
  }
}
```
æˆ‘ä»¬è¿™é‡Œå…ˆåªçœ‹ `current === null` çš„æƒ…å†µï¼Œä¹‹ååˆ™æ˜¯æ ¹æ® `workInProgress.tag` åˆ›å»ºç›¸åº”çš„ `Fiber èŠ‚ç‚¹` ã€‚é¦–å…ˆæˆ‘ä»¬å…ˆäº†è§£ä¸€å…±æœ‰å“ªäº› `Fiber èŠ‚ç‚¹ç±»å‹` ã€‚
```javascript
// packages/react-reconciler/src/ReactWorkTags.js

export const FunctionComponent = 0;
export const ClassComponent = 1;
export const IndeterminateComponent = 2; // Before we know whether it is function or class
export const HostRoot = 3; // Root of a host tree. Could be nested inside another node.
export const HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
export const HostComponent = 5;
export const HostText = 6;
export const Fragment = 7;
export const Mode = 8;
export const ContextConsumer = 9;
export const ContextProvider = 10;
export const ForwardRef = 11;
export const Profiler = 12;
export const SuspenseComponent = 13;
export const MemoComponent = 14;
export const SimpleMemoComponent = 15;
export const LazyComponent = 16;
export const IncompleteClassComponent = 17;
export const DehydratedFragment = 18;
export const SuspenseListComponent = 19;
export const FundamentalComponent = 20;
export const ScopeComponent = 21;
export const Block = 22;
export const OffscreenComponent = 23;
export const LegacyHiddenComponent = 24;
```
å¯ä»¥çœ‹åˆ°ç›®å‰æœ‰ 25 ä¸ªæšä¸¾å€¼ã€‚é‚£ä¹ˆç»“åˆæˆ‘ä»¬çš„ä¾‹å­åˆ†æä¸€ä¸‹åˆ›å»ºçš„é¡ºåºã€‚
![beginwork-workinpregress-tag](~@/assets/posts/react-source-2steps-render/beginwork-workinpregress-tag.png)
æœ‰ä¸Šè¿°çš„logï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å„ä¸ªèŠ‚ç‚¹å¯¹åº”çš„ `Fiber èŠ‚ç‚¹` çš„ tag éƒ½æ˜¯å¤šå°‘ï¼Œé‚£ä¹ˆè¿™ tag å±æ€§æ˜¯æ€ä¹ˆæ ·èµ‹å€¼ä¸Šå»çš„å‘¢ï¼Ÿ

å…¶å®é¦–æ¬¡æ¸²æŸ“åœ¨æ‰§è¡Œåˆ° `renderRootSync` å‡½æ•°æ—¶æœ‰ä¸€ä¸ªåˆ¤æ–­ï¼š
```javascript
// packages/react-reconciler/src/ReactFiberWorkLoop.old.js

function renderRootSync(root: FiberRoot, lanes: Lanes) {
  // ...

  // If the root or lanes have changed, throw out the existing stack
  // and prepare a fresh one. Otherwise we'll continue where we left off.
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes);
    startWorkOnPendingInteractions(root, lanes);
  }
  // ...
}
```
æ­¤æ—¶ `workInProgressRoot` ä¸º nullï¼Œè‡ªç„¶é€»è¾‘å°±ä¼šèµ°åˆ° `prepareFreshStack` å‡½æ•°ä¸­ï¼š
```javascript
// packages/react-reconciler/src/ReactFiberWorkLoop.old.js

function prepareFreshStack(root: FiberRoot, lanes: Lanes) {
  // ...
  if (workInProgress !== null) {
    // ...
  }
  workInProgressRoot = root;
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
  workInProgressRootExitStatus = RootIncomplete;
  workInProgressRootFatalError = null;
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootUpdatedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;
  // ...
}
```
::: warning
åœ¨é¦–æ¬¡æ¸²æŸ“è¿›å…¥ `prepareFreshStack` å‡½æ•°æ—¶ï¼Œä¹ŸåŒæ—¶å°† `root` èµ‹å€¼ç»™ `workInProgressRoot` ã€‚
:::
æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œåœ¨é¦–æ¬¡æ¸²æŸ“è¿›å…¥ `render` é˜¶æ®µæ—¶ï¼Œé¦–ä¸ª `workInProgress Fiber` èŠ‚ç‚¹é€šè¿‡ `createWorkInProgress` å‡½æ•°åˆ›å»ºçš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç»§ç»­çœ‹ä¸€ä¸‹ `createWorkInProgress` å‡½æ•°çš„å£°æ˜ï¼š
```javascript
// packages/react-reconciler/src/ReactFiber.old.js

// This is used to create an alternate fiber to do work on.
export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber {
  let workInProgress = current.alternate;
  if (workInProgress === null) {
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    workInProgress = createFiber(
      current.tag,
      pendingProps,
      current.key,
      current.mode,
    );
    workInProgress.elementType = current.elementType;
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    // ...
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // ...
  }

  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;

  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;

  // Clone the dependencies object. This is mutated during the render phase, so
  // it cannot be shared with the current fiber.
  const currentDependencies = current.dependencies;
  workInProgress.dependencies =
    currentDependencies === null
      ? null
      : {
          lanes: currentDependencies.lanes,
          firstContext: currentDependencies.firstContext,
        };

  // These will be overridden during the parent's reconciliation
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
  // ...
  return workInProgress;
}
```
å› ä¸ºé¦–æ¬¡æ¸²æŸ“ï¼Œæ‰€ä»¥ `let workInProgress = current.alternate;` æˆ‘ä»¬å¯çŸ¥ï¼Œ `workInProgress` ä¸º `null` ï¼Œæ‰€ä»¥å°±ä¼šè¿›å…¥ `if` åˆ¤æ–­é€»è¾‘ï¼Œé€šè¿‡ `createFiber` å‡½æ•°åˆ›å»º `workInProgress Fiber`ï¼Œè€Œæ­¤æ—¶åˆ›å»ºçš„æ­£æ˜¯ `workInProgress Fiber` æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œå’Œ `rootFiber` èŠ‚ç‚¹é€šè¿‡ `alternate` å±æ€§ç›¸å…³è”ï¼Œè¿™ä¸€æ­¥åœ¨ä¸Šä¸€ç¯‡æ–‡ç« ä»‹ç»è¿‡ï¼š
```javascript
workInProgress.alternate = current;
current.alternate = workInProgress;
```
é‚£ä¹ˆåœ¨åˆ›å»ºå®Œ `workInProgress Fiber æ ‘` çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹åï¼Œåˆ™ä¼šé¡ºåˆ©çš„èµ°åˆ° `workLoopSync` å‡½æ•°çš„ while ä¸­ï¼Œä»è€Œå¼€å§‹å¾ªç¯æ‰§è¡Œ `beginWork`ï¼Œä¼ å…¥å½“å‰ `workInProgress Fiber èŠ‚ç‚¹` è¿›è€Œä¾æ¬¡åˆ›å»ºä¸‹ä¸€ä¸ª `workInProgress Fiber èŠ‚ç‚¹` ï¼Œå¹¶ä¸”å¹¶å°†è¿™ä¸¤ä¸ª `Fiber èŠ‚ç‚¹` è¿æ¥èµ·æ¥ã€‚

é‚£ä¹ˆç°åœ¨æˆ‘ä»¬æ ¹æ®ä¾‹å­çœ‹å‡ ä¸ªå¯¹åº” `Fiber èŠ‚ç‚¹` çš„æ„é€ æ–¹æ³•ã€‚
#### HostRoot
```javascript {26}
// packages/react-reconciler/src/ReactFiberBeginWork.old.js

function updateHostRoot(current, workInProgress, renderLanes) {
  pushHostRootContext(workInProgress);
  const updateQueue = workInProgress.updateQueue;
  // ...
  const nextProps = workInProgress.pendingProps;
  const prevState = workInProgress.memoizedState;
  const prevChildren = prevState !== null ? prevState.element : null;
  cloneUpdateQueue(current, workInProgress);
  processUpdateQueue(workInProgress, nextProps, null, renderLanes);
  const nextState = workInProgress.memoizedState;
  // Caution: React DevTools currently depends on this property
  // being called "element".
  const nextChildren = nextState.element;
  if (nextChildren === prevChildren) {
    resetHydrationState();
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }
  const root: FiberRoot = workInProgress.stateNode;
  if (root.hydrate && enterHydrationState(workInProgress)) {
    // ...
  } else {
    // Otherwise reset hydration state in case we aborted and resumed another
    // root.
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
    resetHydrationState();
  }
  return workInProgress.child;
}
```
#### IndeterminateComponent
```javascript {67}
// packages/react-reconciler/src/ReactFiberBeginWork.old.js

function mountIndeterminateComponent(
  _current,
  workInProgress,
  Component,
  renderLanes,
) {
  if (_current !== null) {
    // An indeterminate component only mounts if it suspended inside a non-
    // concurrent tree, in an inconsistent state. We want to treat it like
    // a new mount, even though an empty version of it already committed.
    // Disconnect the alternate pointers.
    _current.alternate = null;
    workInProgress.alternate = null;
    // Since this is conceptually a new fiber, schedule a Placement effect
    workInProgress.flags |= Placement;
  }

  const props = workInProgress.pendingProps;
  let context;
  if (!disableLegacyContext) {
    const unmaskedContext = getUnmaskedContext(
      workInProgress,
      Component,
      false,
    );
    context = getMaskedContext(workInProgress, unmaskedContext);
  }

  prepareToReadContext(workInProgress, renderLanes);
  let value;
  // ...
  value = renderWithHooks(
    null,
    workInProgress,
    Component,
    props,
    context,
    renderLanes,
  );
  // React DevTools reads this flag.
  workInProgress.flags |= PerformedWork;
  // ...
  if (
    // Run these checks in production only if the flag is off.
    // Eventually we'll delete this branch altogether.
    !disableModulePatternComponents &&
    typeof value === 'object' &&
    value !== null &&
    typeof value.render === 'function' &&
    value.$$typeof === undefined
  ) {
    // ...
    return finishClassComponent(
      null,
      workInProgress,
      Component,
      true,
      hasContext,
      renderLanes,
    );
  } else {
    // Proceed under the assumption that this is a function component
    workInProgress.tag = FunctionComponent;
    // ...
    reconcileChildren(null, workInProgress, value, renderLanes);
    // ...
    return workInProgress.child;
  }
}
```
```javascript {61}
function finishClassComponent(
  current: Fiber | null,
  workInProgress: Fiber,
  Component: any,
  shouldUpdate: boolean,
  hasContext: boolean,
  renderLanes: Lanes,
) {
  // Refs should update even if shouldComponentUpdate returns false
  markRef(current, workInProgress);

  const didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;

  if (!shouldUpdate && !didCaptureError) {
    // Context providers should defer to sCU for rendering
    if (hasContext) {
      invalidateContextProvider(workInProgress, Component, false);
    }

    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  const instance = workInProgress.stateNode;

  // Rerender
  ReactCurrentOwner.current = workInProgress;
  let nextChildren;
  if (
    didCaptureError &&
    typeof Component.getDerivedStateFromError !== 'function'
  ) {
    // If we captured an error, but getDerivedStateFromError is not defined,
    // unmount all the children. componentDidCatch will schedule an update to
    // re-render a fallback. This is temporary until we migrate everyone to
    // the new API.
    // TODO: Warn in a future release.
    nextChildren = null;

    if (enableProfilerTimer) {
      stopProfilerTimerIfRunning(workInProgress);
    }
  } else {
    // ...
    nextChildren = instance.render();
  }

  // React DevTools reads this flag.
  workInProgress.flags |= PerformedWork;
  if (current !== null && didCaptureError) {
    // If we're recovering from an error, reconcile without reusing any of
    // the existing children. Conceptually, the normal children and the children
    // that are shown on error are two different sets, so we shouldn't reuse
    // normal children even if their identities match.
    forceUnmountCurrentAndReconcile(
      current,
      workInProgress,
      nextChildren,
      renderLanes,
    );
  } else {
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  }

  // Memoize state using the values we just used to render.
  // TODO: Restructure so we never read values from the instance.
  workInProgress.memoizedState = instance.state;

  // The context might have changed so we need to recalculate it.
  if (hasContext) {
    invalidateContextProvider(workInProgress, Component, true);
  }

  return workInProgress.child;
}
```
#### HostComponent
```javascript {34}
// packages/react-reconciler/src/ReactFiberBeginWork.old.js

function updateHostComponent(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
) {
  pushHostContext(workInProgress);

  if (current === null) {
    tryToClaimNextHydratableInstance(workInProgress);
  }

  const type = workInProgress.type;
  const nextProps = workInProgress.pendingProps;
  const prevProps = current !== null ? current.memoizedProps : null;

  let nextChildren = nextProps.children;
  const isDirectTextChild = shouldSetTextContent(type, nextProps);

  if (isDirectTextChild) {
    // We special case a direct text child of a host node. This is a common
    // case. We won't handle it as a reified child. We will instead handle
    // this in the host environment that also has access to this prop. That
    // avoids allocating another HostText fiber and traversing it.
    nextChildren = null;
  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
    // If we're switching from a direct text child to a normal child, or to
    // empty, we need to schedule the text content to be reset.
    workInProgress.flags |= ContentReset;
  }

  markRef(current, workInProgress);
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateHostText(current, workInProgress) {
  if (current === null) {
    tryToClaimNextHydratableInstance(workInProgress);
  }
  // Nothing to do here. This is terminal. We'll do the completion step
  // immediately after.
  return null;
}
```
#### reconcileChildren
å¯¹äºæˆ‘ä»¬å¸¸è§çš„ç»„ä»¶ç±»å‹ï¼Œå¦‚ï¼ˆ`FunctionComponent` / `ClassComponent` / `HostComponent`ï¼‰ï¼Œæœ€ç»ˆä¼šè¿›å…¥reconcileChildrenæ–¹æ³•ã€‚

é‚£ä¹ˆæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ `reconcileChildren` çš„å®šä¹‰ï¼š
```javascript
// packages/react-reconciler/src/ReactFiberBeginWork.old.js

export function reconcileChildren(
  current: Fiber | null,
  workInProgress: Fiber,
  nextChildren: any,
  renderLanes: Lanes,
) {
  if (current === null) {
    // If this is a fresh new component that hasn't been rendered yet, we
    // won't update its child set by applying minimal side-effects. Instead,
    // we will add them all to the child before it gets rendered. That means
    // we can optimize this reconciliation pass by not tracking side-effects.
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes,
    );
  } else {
    // If the current child is the same as the work in progress, it means that
    // we haven't yet started any work on these children. Therefore, we use
    // the clone algorithm to create a copy of all the current children.

    // If we had any progressed work already, that is invalid at this point so
    // let's throw it out.
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderLanes,
    );
  }
}
```
ä»ä»£ç å¯ä»¥çœ‹å‡ºï¼Œå’Œ `beginWork` ä¸€æ ·ï¼Œä»–ä¹Ÿæ˜¯é€šè¿‡ `current === null` æ¥åŒºåˆ†mountä¸updateã€‚

å…¶å® `reconcilerChildren` çš„æ ¸å¿ƒé€»è¾‘å¾ˆç®€å•ï¼Œä¸»ä½“åªæœ‰ä¸€ä¸ªåˆ¤æ–­ï¼Œç”¨æ¥åŒºåˆ†æ˜¯é¦–æ¬¡æ¸²æŸ“è¿˜æ˜¯æ›´æ–°ï¼š
* å¯¹äº mount çš„ç»„ä»¶ï¼Œä»–ä¼šåˆ›å»ºæ–°çš„å­ Fiber èŠ‚ç‚¹
* å¯¹äº update çš„ç»„ä»¶ï¼Œä»–ä¼šå°†å½“å‰ç»„ä»¶ä¸è¯¥ç»„ä»¶åœ¨ä¸Šæ¬¡æ›´æ–°æ—¶å¯¹åº”çš„ Fiber èŠ‚ç‚¹æ¯”è¾ƒï¼ˆä¹Ÿå°±æ˜¯ä¿—ç§°çš„ Diff ç®—æ³•ï¼‰ï¼Œå°†æ¯”è¾ƒçš„ç»“æœç”Ÿæˆæ–° Fiber èŠ‚ç‚¹

ä¸è®ºèµ°å“ªä¸ªé€»è¾‘ï¼Œæœ€ç»ˆä»–ä¼šç”Ÿæˆæ–°çš„å­ Fiber èŠ‚ç‚¹å¹¶èµ‹å€¼ç»™ `workInProgress.child`ï¼Œä½œä¸ºæœ¬æ¬¡ `beginWork` å‡½æ•°çš„è¿”å›å€¼ï¼Œå¹¶ä½œä¸ºä¸‹æ¬¡ `performUnitOfWork` å‡½æ•°æ‰§è¡Œæ—¶ workInProgress çš„ä¼ å‚ã€‚
::: warning
å€¼å¾—ä¸€æçš„æ˜¯ï¼Œ`mountChildFibers` å‡½æ•°ä¸ `reconcileChildFibers` å‡½æ•°è¿™ä¸¤ä¸ªæ–¹æ³•çš„é€»è¾‘åŸºæœ¬ä¸€è‡´ã€‚å”¯ä¸€çš„åŒºåˆ«æ˜¯ï¼š`reconcileChildFibers` å‡½æ•°ä¼šç»´æŠ¤ workInProgress Fiber tree çš„çŠ¶æ€ï¼Œä¼šä¸ºç”Ÿæˆçš„ Fiber èŠ‚ç‚¹å¸¦ä¸Š flags å±æ€§ï¼›è€Œ`mountChildFibers` å‡½æ•°åˆ™ä¸ä¼šã€‚
:::
#### flags
æˆ‘ä»¬çŸ¥é“ï¼Œrender é˜¶æ®µçš„å·¥ä½œæ˜¯åœ¨å†…å­˜ä¸­è¿›è¡Œï¼Œå½“å·¥ä½œç»“æŸåä¼šé€šçŸ¥ Renderer éœ€è¦æ‰§è¡Œçš„ DOM æ“ä½œã€‚è¦æ‰§è¡Œ DOM æ“ä½œçš„å…·ä½“ç±»å‹å°±ä¿å­˜åœ¨ fiber.flags ä¸­ã€‚
```javascript
// packages/react-reconciler/src/ReactFiberFlags.js

// Don't change these two values. They're used by React Dev Tools.
export const NoFlags = /*                      */ 0b0000000000000000000;
export const PerformedWork = /*                */ 0b0000000000000000001;

// You can change the rest (and add more).
export const Placement = /*                    */ 0b0000000000000000010;
export const Update = /*                       */ 0b0000000000000000100;
export const PlacementAndUpdate = /*           */ 0b0000000000000000110;
export const Deletion = /*                     */ 0b0000000000000001000;
export const ContentReset = /*                 */ 0b0000000000000010000;
export const Callback = /*                     */ 0b0000000000000100000;
export const DidCapture = /*                   */ 0b0000000000001000000;
export const Ref = /*                          */ 0b0000000000010000000;
export const Snapshot = /*                     */ 0b0000000000100000000;
export const Passive = /*                      */ 0b0000000001000000000;
export const Hydrating = /*                    */ 0b0000000010000000000;
export const HydratingAndUpdate = /*           */ 0b0000000010000000100;
export const Visibility = /*                   */ 0b0000000100000000000;
// ...
```
::: warning
é€šè¿‡äºŒè¿›åˆ¶è¡¨ç¤º flagsï¼Œå¯ä»¥æ–¹ä¾¿çš„ä½¿ç”¨ä½æ“ä½œä¸º fiber.flags èµ‹å€¼å¤šä¸ª flagsã€‚
:::
é‚£ä¹ˆï¼Œå¦‚æœè¦é€šçŸ¥Rendererå°†FiberèŠ‚ç‚¹å¯¹åº”çš„DOMèŠ‚ç‚¹æ’å…¥é¡µé¢ä¸­ï¼Œéœ€è¦æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶ï¼š
* 1.fiber.stateNodeå­˜åœ¨ï¼Œå³FiberèŠ‚ç‚¹ä¸­ä¿å­˜äº†å¯¹åº”çš„DOMèŠ‚ç‚¹
* 2.`(fiber.flags & Placement) !== 0` ï¼Œå³ Fiber èŠ‚ç‚¹å­˜åœ¨ Placement flags

æˆ‘ä»¬çŸ¥é“ï¼Œé¦–æ¬¡æ¸²æŸ“æ—¶ï¼Œ`fiber.stateNode === null`ï¼Œä¸”åœ¨ `reconcileChildren` å‡½æ•°ä¸­è°ƒç”¨çš„ `mountChildFibers` å‡½æ•°ä¸ä¼šä¸º Fiber èŠ‚ç‚¹èµ‹å€¼ flagsã€‚é‚£ä¹ˆé¦–å±æ¸²æŸ“å¦‚ä½•å®Œæˆå‘¢ï¼Ÿ

é’ˆå¯¹ç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œfiber.stateNode ä¼šåœ¨ completeWork é˜¶æ®µä¸­åˆ›å»ºï¼Œæˆ‘ä»¬ä¼šåœ¨ä¸‹ä¸€èŠ‚ä»‹ç»ã€‚

ç¬¬äºŒä¸ªé—®é¢˜çš„ç­”æ¡ˆååˆ†å·§å¦™ï¼šå‡è®¾ `mountChildFibers` å‡½æ•°ä¹Ÿä¼šèµ‹å€¼ flagsï¼Œé‚£ä¹ˆå¯ä»¥é¢„è§é¦–æ¬¡æ¸²æŸ“æ—¶æ•´æ£µ Fiber æ ‘æ‰€æœ‰èŠ‚ç‚¹éƒ½ä¼šæœ‰ Placement flagã€‚é‚£ä¹ˆ commit é˜¶æ®µåœ¨æ‰§è¡Œ DOMæ“ä½œæ—¶æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼šæ‰§è¡Œä¸€æ¬¡æ’å…¥æ“ä½œï¼Œè¿™æ ·å¤§é‡çš„DOMæ“ä½œæ˜¯æä½æ•ˆçš„ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œåœ¨é¦–æ¬¡æ¸²æŸ“æ—¶åªæœ‰ rootFiber ä¼šèµ‹å€¼ Placement flagï¼Œåœ¨ commit é˜¶æ®µåªä¼šæ‰§è¡Œä¸€æ¬¡æ’å…¥æ“ä½œã€‚
### completeWork
æˆ‘ä»¬äº†è§£ç»„ä»¶åœ¨renderé˜¶æ®µä¼šç»å† `beginWork` ä¸ `completeWork` ã€‚

ä¸Šä¸€èŠ‚æˆ‘ä»¬è®²è§£äº†ç»„ä»¶æ‰§è¡Œ `beginWork` å‡½æ•°åä¼šåˆ›å»ºå­ Fiber èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹ä¸Šå¯èƒ½å­˜åœ¨ flagsã€‚

è¿™ä¸€èŠ‚è®©æˆ‘ä»¬çœ‹çœ‹ `completeWork` ä¼šåšä»€ä¹ˆå·¥ä½œã€‚
#### æµç¨‹æ¦‚è§ˆ
`completeWork` å‡½æ•°å®šä¹‰å¦‚ä¸‹ï¼š
```javascript
// packages/react-reconciler/src/ReactFiberCompleteWork.old.js

function completeWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  const newProps = workInProgress.pendingProps;

  switch (workInProgress.tag) {
    case IndeterminateComponent:
    case LazyComponent:
    case SimpleMemoComponent:
    case FunctionComponent:
    case ForwardRef:
    case Fragment:
    case Mode:
    case Profiler:
    case ContextConsumer:
    case MemoComponent:
      return null;
    case ClassComponent:
      // ...
    case HostRoot: 
      // ...
    case HostComponent: 
      // ...
    case HostText: 
      // ...
    case SuspenseComponent: 
      // ...
    case HostPortal:
      // ...
    case ContextProvider:
      // ...
    case IncompleteClassComponent: 
      // ...
    case SuspenseListComponent: 
      // ...
    case FundamentalComponent: 
      // ...
    case ScopeComponent: 
      // ...
    case Block:
      // ...
    case OffscreenComponent:
    case LegacyHiddenComponent:
      // ...
  }
  // ...
}
```
ç±»ä¼¼ `beginWork` å‡½æ•°ï¼Œ`completeWork` å‡½æ•°ä¹Ÿæ˜¯é’ˆå¯¹ä¸åŒ fiber.tag è°ƒç”¨ä¸åŒçš„å¤„ç†é€»è¾‘ã€‚

æˆ‘ä»¬é‡ç‚¹å…³æ³¨é¡µé¢æ¸²æŸ“æ‰€å¿…é¡»çš„ HostComponentï¼ˆå³åŸç”ŸDOMç»„ä»¶å¯¹åº”çš„FiberèŠ‚ç‚¹ï¼‰ï¼Œå…¶ä»–ç±»å‹Fiberçš„å¤„ç†ç•™åœ¨å…·ä½“åŠŸèƒ½å®ç°æ—¶è®²è§£ã€‚
#### å¤„ç†HostComponent
å’Œ `beginWork` å‡½æ•°ä¸€æ ·ï¼Œæˆ‘ä»¬æ ¹æ® `current === null` åˆ¤æ–­æ˜¯é¦–æ¬¡æ¸²æŸ“è¿˜æ˜¯æ›´æ–°æ¸²æŸ“ã€‚

åŒæ—¶é’ˆå¯¹ HostComponent ï¼Œåˆ¤æ–­æ›´æ–°æ¸²æŸ“æ—¶æˆ‘ä»¬è¿˜éœ€è¦è€ƒè™‘ `workInProgress.stateNode != null`ï¼ˆå³è¯¥FiberèŠ‚ç‚¹æ˜¯å¦å­˜åœ¨å¯¹åº”çš„DOMèŠ‚ç‚¹ï¼‰
```javascript {35,43}
// packages/react-reconciler/src/ReactFiberCompleteWork.old.js

function completeWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  const newProps = workInProgress.pendingProps;

  switch (workInProgress.tag) {
    // ...
    case HostComponent: {
      popHostContext(workInProgress);
      const rootContainerInstance = getRootHostContainer();
      const type = workInProgress.type;
      if (current !== null && workInProgress.stateNode != null) {
        // update ...
      } else {
        if (!newProps) {
          invariant(
            workInProgress.stateNode !== null,
            'We must have new props for new mounts. This error is likely ' +
              'caused by a bug in React. Please file an issue.',
          );
          // This can happen when we abort work.
          return null;
        }

        const currentHostContext = getHostContext();
        // ...
        if (wasHydrated) {
          // ...
        } else {
          // ä¸ºfiberåˆ›å»ºå¯¹åº”DOMèŠ‚ç‚¹
          const instance = createInstance(
            type,
            newProps,
            rootContainerInstance,
            currentHostContext,
            workInProgress,
          );
          // å°†å­å­™DOMèŠ‚ç‚¹æ’å…¥åˆšç”Ÿæˆçš„DOMèŠ‚ç‚¹ä¸­
          appendAllChildren(instance, workInProgress, false, false);
          // DOMèŠ‚ç‚¹èµ‹å€¼ç»™fiber.stateNode
          workInProgress.stateNode = instance;

          // Certain renderers require commit-time effects for initial mount.
          // (eg DOM renderer supports auto-focus for certain elements).
          // Make sure such renderers get scheduled for later work.
          // ä¸updateé€»è¾‘ä¸­çš„updateHostComponentç±»ä¼¼çš„å¤„ç†propsçš„è¿‡ç¨‹
          if (
            finalizeInitialChildren(
              instance,
              type,
              newProps,
              rootContainerInstance,
              currentHostContext,
            )
          ) {
            markUpdate(workInProgress);
          }
        }

        if (workInProgress.ref !== null) {
          // If there is a ref on a host node we need to schedule a callback
          markRef(workInProgress);
        }
      }
      return null;
    }
    // ...
  }
  // ...
}
```
å¯ä»¥çœ‹åˆ°ï¼Œé¦–æ¬¡æ¸²æŸ“æ—¶çš„ä¸»è¦é€»è¾‘åŒ…æ‹¬ä¸‰ä¸ªï¼š
* ä¸º Fiber èŠ‚ç‚¹ç”Ÿæˆå¯¹åº”çš„ DOM èŠ‚ç‚¹
* å°†å­å­™ DOM èŠ‚ç‚¹æ’å…¥åˆšç”Ÿæˆçš„DOMèŠ‚ç‚¹ä¸­
* ä¸ update é€»è¾‘ä¸­çš„ `updateHostComponent` å‡½æ•°ç±»ä¼¼çš„å¤„ç† props çš„è¿‡ç¨‹

è¿˜è®°å¾—ä¹‹å‰æˆ‘ä»¬è®²åˆ°ï¼šmount æ—¶åªä¼šåœ¨ rootFiber å­˜åœ¨ Placement flag ã€‚é‚£ä¹ˆ commit é˜¶æ®µæ˜¯å¦‚ä½•é€šè¿‡ä¸€æ¬¡æ’å…¥ DOM æ“ä½œï¼ˆå¯¹åº”ä¸€ä¸ªPlacement flagï¼‰å°†æ•´æ£µ DOM æ ‘æ’å…¥é¡µé¢çš„å‘¢ï¼Ÿ
åŸå› å°±åœ¨äº `completeWork` å‡½æ•°ä¸­çš„ `appendAllChildren` å‡½æ•°æ–¹æ³•ã€‚

ç”±äº `completeWork` å‡½æ•°å±äºâ€œå½’â€é˜¶æ®µè°ƒç”¨çš„å‡½æ•°ï¼Œæ¯æ¬¡è°ƒç”¨ `appendAllChildren` å‡½æ•°æ—¶éƒ½ä¼šå°†å·²ç”Ÿæˆçš„å­å­™ DOM èŠ‚ç‚¹æ’å…¥å½“å‰ç”Ÿæˆçš„ DOM èŠ‚ç‚¹ä¸‹ã€‚é‚£ä¹ˆå½“â€œå½’â€åˆ° rootFiber æ—¶ï¼Œæˆ‘ä»¬å·²ç»æœ‰ä¸€ä¸ªæ„å»ºå¥½çš„ç¦»å± DOM æ ‘ã€‚
#### effectList
è‡³æ­¤renderé˜¶æ®µçš„ç»å¤§éƒ¨åˆ†å·¥ä½œå°±å®Œæˆäº†ã€‚

è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼šä½œä¸º DOM æ“ä½œçš„ä¾æ®ï¼Œcommit é˜¶æ®µéœ€è¦æ‰¾åˆ°æ‰€æœ‰æœ‰ flags çš„ Fiber èŠ‚ç‚¹å¹¶ä¾æ¬¡æ‰§è¡Œ flags å¯¹åº”æ“ä½œã€‚éš¾é“éœ€è¦åœ¨ commit é˜¶æ®µå†éå†ä¸€æ¬¡ Fiber æ ‘å¯»æ‰¾ `flags !== null` çš„ Fiber èŠ‚ç‚¹ä¹ˆï¼Ÿ

è¿™æ˜¾ç„¶æ˜¯å¾ˆä½æ•ˆçš„ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œåœ¨ `completeWork` å‡½æ•°çš„ä¸Šå±‚å‡½æ•° `completeUnitOfWork` ä¸­ï¼Œæ¯ä¸ªæ‰§è¡Œå®Œ `completeWork` ä¸”å­˜åœ¨ flags çš„ Fiber èŠ‚ç‚¹ä¼šè¢«ä¿å­˜åœ¨ä¸€æ¡è¢«ç§°ä¸º effectList çš„å•å‘é“¾è¡¨ä¸­ã€‚

effectList ä¸­ç¬¬ä¸€ä¸ª Fiber èŠ‚ç‚¹ä¿å­˜åœ¨ fiber.firstEffect ï¼Œæœ€åä¸€ä¸ªå…ƒç´ ä¿å­˜åœ¨ fiber.lastEffect ã€‚

ç±»ä¼¼ `appendAllChildren` å‡½æ•°ï¼Œåœ¨â€œå½’â€é˜¶æ®µï¼Œæ‰€æœ‰æœ‰ flags çš„ Fiber èŠ‚ç‚¹éƒ½ä¼šè¢«è¿½åŠ åœ¨ `effectList` ä¸­ï¼Œæœ€ç»ˆå½¢æˆä¸€æ¡ä»¥ `rootFiber.firstEffect` ä¸ºèµ·ç‚¹çš„å•å‘é“¾è¡¨ã€‚
```
                       nextEffect         nextEffect
rootFiber.firstEffect -----------> fiber -----------> fiber
```
è¿™æ ·ï¼Œåœ¨commité˜¶æ®µåªéœ€è¦éå†effectListå°±èƒ½æ‰§è¡Œæ‰€æœ‰effectäº†ã€‚
```javascript
// packages/react-reconciler/src/ReactFiberWorkLoop.old.js -> completeUnitOfWork function

if (
  returnFiber !== null &&
  // Do not append effects to parents if a sibling failed to complete
  (returnFiber.flags & Incomplete) === NoFlags
) {
  // Append all the effects of the subtree and this fiber onto the effect
  // list of the parent. The completion order of the children affects the
  // side-effect order.
  if (returnFiber.firstEffect === null) {
    returnFiber.firstEffect = completedWork.firstEffect;
  }
  if (completedWork.lastEffect !== null) {
    if (returnFiber.lastEffect !== null) {
      returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
    }
    returnFiber.lastEffect = completedWork.lastEffect;
  }

  // If this fiber had side-effects, we append it AFTER the children's
  // side-effects. We can perform certain side-effects earlier if needed,
  // by doing multiple passes over the effect list. We don't want to
  // schedule our own side-effect on our own list because if end up
  // reusing children we'll schedule this effect onto itself since we're
  // at the end.
  const flags = completedWork.flags;

  // Skip both NoWork and PerformedWork tags when creating the effect
  // list. PerformedWork effect is read by React DevTools but shouldn't be
  // committed.
  if (flags > PerformedWork) {
    if (returnFiber.lastEffect !== null) {
      returnFiber.lastEffect.nextEffect = completedWork;
    } else {
      returnFiber.firstEffect = completedWork;
    }
    returnFiber.lastEffect = completedWork;
  }
}
} else {
  // ...
}
```
å€Ÿç”¨Reactå›¢é˜Ÿæˆå‘˜Dan Abramovçš„è¯ï¼šeffectListç›¸è¾ƒäºFiberæ ‘ï¼Œå°±åƒåœ£è¯æ ‘ä¸ŠæŒ‚çš„é‚£ä¸€ä¸²å½©ç¯ã€‚
#### æµç¨‹ç»“æŸ
è‡³æ­¤ï¼Œrender é˜¶æ®µå…¨éƒ¨å·¥ä½œå®Œæˆã€‚åœ¨ `performSyncWorkOnRoot` å‡½æ•°ä¸­ fiberRootNode è¢«ä¼ é€’ç»™ `commitRoot` å‡½æ•°ï¼Œå¼€å¯ commit é˜¶æ®µå·¥ä½œæµç¨‹ã€‚
```javascript {66}
// packages/react-reconciler/src/ReactFiberWorkLoop.old.js

// This is the entry point for synchronous tasks that don't go
// through Scheduler
function performSyncWorkOnRoot(root) {
  // ...
  flushPassiveEffects();

  let lanes;
  let exitStatus;
  if (
    root === workInProgressRoot &&
    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)
  ) {
    // There's a partial tree, and at least one of its lanes has expired. Finish
    // rendering it before rendering the rest of the expired work.
    lanes = workInProgressRootRenderLanes;
    exitStatus = renderRootSync(root, lanes);
    if (
      includesSomeLane(
        workInProgressRootIncludedLanes,
        workInProgressRootUpdatedLanes,
      )
    ) {
      // The render included lanes that were updated during the render phase.
      // For example, when unhiding a hidden tree, we include all the lanes
      // that were previously skipped when the tree was hidden. That set of
      // lanes is a superset of the lanes we started rendering with.
      //
      // Note that this only happens when part of the tree is rendered
      // concurrently. If the whole tree is rendered synchronously, then there
      // are no interleaved events.
      lanes = getNextLanes(root, lanes);
      exitStatus = renderRootSync(root, lanes);
    }
  } else {
    lanes = getNextLanes(root, NoLanes);
    exitStatus = renderRootSync(root, lanes);
  }

  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
    executionContext |= RetryAfterError;

    // If an error occurred during hydration,
    // discard server response and fall back to client side render.
    if (root.hydrate) {
      root.hydrate = false;
      clearContainer(root.containerInfo);
    }

    // If something threw an error, try rendering one more time. We'll render
    // synchronously to block concurrent data mutations, and we'll includes
    // all pending updates are included. If it still fails after the second
    // attempt, we'll give up and commit the resulting tree.
    lanes = getLanesToRetrySynchronouslyOnError(root);
    if (lanes !== NoLanes) {
      exitStatus = renderRootSync(root, lanes);
    }
  }
  // ...
  // We now have a consistent tree. Because this is a sync render, we
  // will commit it even if something suspended.
  const finishedWork: Fiber = (root.current.alternate: any);
  root.finishedWork = finishedWork;
  root.finishedLanes = lanes;
  commitRoot(root);

  // Before exiting, make sure there's a callback scheduled for the next
  // pending level.
  ensureRootIsScheduled(root, now());

  return null;
}
```
## Commit é˜¶æ®µ
### æµç¨‹æ¦‚è§ˆ
`commitRoot` å‡½æ•°æ˜¯ commit é˜¶æ®µå·¥ä½œçš„èµ·ç‚¹ã€‚fiberRootNode ä¼šä½œä¸ºä¼ å‚ã€‚

åœ¨ rootFiber.firstEffect ä¸Šä¿å­˜äº†ä¸€æ¡éœ€è¦æ‰§è¡Œå‰¯ä½œç”¨çš„ Fiber èŠ‚ç‚¹çš„å•å‘é“¾è¡¨ effectListï¼Œè¿™äº› Fiber èŠ‚ç‚¹çš„ updateQueue ä¸­ä¿å­˜äº†å˜åŒ–çš„ propsã€‚

è¿™äº›å‰¯ä½œç”¨å¯¹åº”çš„ DOM æ“ä½œåœ¨ commit é˜¶æ®µæ‰§è¡Œã€‚
::: warning
Commit é˜¶æ®µçš„å®Œæ•´ä»£ç å®šä¹‰åœ¨ `packages/react-reconciler/src/ReactFiberWorkLoop.old.js` çš„ `commitRootImpl` å‡½æ•°ã€‚
::: 
é™¤æ­¤ä¹‹å¤–ï¼Œä¸€äº›ç”Ÿå‘½å‘¨æœŸé’©å­ï¼ˆæ¯”å¦‚componentDidXXXï¼‰ã€hookï¼ˆæ¯”å¦‚useEffectï¼‰éœ€è¦åœ¨ commit é˜¶æ®µæ‰§è¡Œã€‚

commit é˜¶æ®µçš„ä¸»è¦å·¥ä½œï¼ˆå³ Renderer çš„å·¥ä½œæµç¨‹ï¼‰åˆ†ä¸ºä¸‰éƒ¨åˆ†ï¼š
* Before Mutation é˜¶æ®µï¼ˆæ‰§è¡ŒDOMæ“ä½œå‰ï¼‰
* Mutation é˜¶æ®µï¼ˆæ‰§è¡ŒDOMæ“ä½œï¼‰
* Layout é˜¶æ®µï¼ˆæ‰§è¡ŒDOMæ“ä½œåï¼‰

åœ¨ Before Mutation é˜¶æ®µä¹‹å‰å’Œ Layout é˜¶æ®µä¹‹åè¿˜æœ‰ä¸€äº›é¢å¤–å·¥ä½œï¼Œæ¶‰åŠåˆ°æ¯”å¦‚ useEffect çš„è§¦å‘ã€ä¼˜å…ˆçº§ç›¸å…³çš„é‡ç½®ã€ref çš„ç»‘å®š/è§£ç»‘ã€‚

è¿™äº›å¯¹æˆ‘ä»¬å½“å‰å±äºè¶…çº²å†…å®¹ï¼Œä¸ºäº†å†…å®¹å®Œæ•´æ€§ï¼Œåœ¨è¿™èŠ‚ç®€å•ä»‹ç»ã€‚
#### Before Mutation é˜¶æ®µä¹‹å‰
```javascript
  // packages/react-reconciler/src/ReactFiberWorkLoop.old.js -> commitRootImpl function

  do {
    // è§¦å‘useEffectå›è°ƒä¸å…¶ä»–åŒæ­¥ä»»åŠ¡ã€‚ç”±äºè¿™äº›ä»»åŠ¡å¯èƒ½è§¦å‘æ–°çš„æ¸²æŸ“ï¼Œæ‰€ä»¥è¿™é‡Œè¦ä¸€ç›´éå†æ‰§è¡Œç›´åˆ°æ²¡æœ‰ä»»åŠ¡
    flushPassiveEffects();
  } while (rootWithPendingPassiveEffects !== null);
  // ...
  // rootæŒ‡ fiberRootNode
  // root.finishedWorkæŒ‡å½“å‰åº”ç”¨çš„rootFiber
  const finishedWork = root.finishedWork;
  // å‡¡æ˜¯å˜é‡åå¸¦laneçš„éƒ½æ˜¯ä¼˜å…ˆçº§ç›¸å…³
  const lanes = root.finishedLanes;
  // ...
  if (finishedWork === null) {
    // ...
    return null;
  }
  root.finishedWork = null;
  root.finishedLanes = NoLanes;
  // ...
  // é‡ç½®Schedulerç»‘å®šçš„å›è°ƒå‡½æ•°
  root.callbackNode = null;

  // æ›´æ–°è¿™ä¸ª root fiber çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªæŒ‚èµ·æ—¶é—´ã€‚æ–°çš„ç¬¬ä¸€ä¸ªæŒ‚èµ·æ—¶é—´æ˜¯ root fiber ä¸Šå‰©ä½™çš„æ—¶é—´ã€‚
  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
  markRootFinished(root, remainingLanes);

  // æ¸…é™¤å·²å®Œæˆçš„discrete updatesï¼Œä¾‹å¦‚ï¼šç”¨æˆ·é¼ æ ‡ç‚¹å‡»è§¦å‘çš„æ›´æ–°ã€‚
  if (rootsWithPendingDiscreteUpdates !== null) {
    if (
      !hasDiscreteLanes(remainingLanes) &&
      rootsWithPendingDiscreteUpdates.has(root)
    ) {
      rootsWithPendingDiscreteUpdates.delete(root);
    }
  }
  // é‡ç½®å…¨å±€å˜é‡
  if (root === workInProgressRoot) {
    // We can reset these now that they are finished.
    workInProgressRoot = null;
    workInProgress = null;
    workInProgressRootRenderLanes = NoLanes;
  } else {
    // This indicates that the last root we worked on is not the same one that
    // we're committing now. This most commonly happens when a suspended root
    // times out.
  }

  // å°† effectList èµ‹å€¼ç»™ firstEffect
  // ç”±äºæ¯ä¸ª fiber çš„ effectList åªåŒ…å«ä»–çš„å­å­™èŠ‚ç‚¹
  // æ‰€ä»¥æ ¹èŠ‚ç‚¹å¦‚æœæœ‰ flags åˆ™ä¸ä¼šè¢«åŒ…å«è¿›æ¥
  // æ‰€ä»¥è¿™é‡Œå°†æœ‰ flags çš„æ ¹èŠ‚ç‚¹æ’å…¥åˆ° effectList å°¾éƒ¨
  // è¿™æ ·æ‰èƒ½ä¿è¯æœ‰ effect çš„ fiber éƒ½åœ¨ effectList ä¸­
  let firstEffect;
  if (finishedWork.flags > PerformedWork) {
    if (finishedWork.lastEffect !== null) {
      finishedWork.lastEffect.nextEffect = finishedWork;
      firstEffect = finishedWork.firstEffect;
    } else {
      firstEffect = finishedWork;
    }
  } else {
    // æ ¹èŠ‚ç‚¹æ²¡æœ‰ effect
    firstEffect = finishedWork.firstEffect;
  }
```
å¯ä»¥çœ‹åˆ°ï¼ŒBefore Mutation ä¹‹å‰ä¸»è¦åšä¸€äº›å˜é‡èµ‹å€¼ï¼ŒçŠ¶æ€é‡ç½®çš„å·¥ä½œã€‚

è¿™ä¸€é•¿ä¸²ä»£ç æˆ‘ä»¬åªéœ€è¦å…³æ³¨æœ€åèµ‹å€¼çš„ firstEffect ï¼Œåœ¨ Commit çš„ä¸‰ä¸ªå­é˜¶æ®µéƒ½ä¼šç”¨åˆ°ä»–ã€‚
#### Layout é˜¶æ®µä¹‹å
```javascript
  // packages/react-reconciler/src/ReactFiberWorkLoop.old.js -> commitRootImpl function

  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
  // useEffectç›¸å…³
  if (rootDoesHavePassiveEffects) {
    // æ­¤æäº¤å…·æœ‰è¢«åŠ¨æ•ˆæœã€‚éšè—å¯¹å®ƒä»¬çš„å¼•ç”¨ã€‚ä½†æ˜¯åœ¨åˆ·æ–°å¸ƒå±€å·¥ä½œä¹‹åå†å®‰æ’å›è°ƒã€‚
    rootDoesHavePassiveEffects = false;
    rootWithPendingPassiveEffects = root;
    pendingPassiveEffectsLanes = lanes;
    pendingPassiveEffectsRenderPriority = renderPriorityLevel;
  } else {
    // æ¸…é™¤ nextEffect ååŠ© GCã€‚å¦‚æœè¿˜æœ‰ passive effectsï¼Œåˆ™ä½¿ç”¨ `flushPassiveEffects` æ¸…é™¤ã€‚
    nextEffect = firstEffect;
    while (nextEffect !== null) {
      const nextNextEffect = nextEffect.nextEffect;
      nextEffect.nextEffect = null;
      if (nextEffect.flags & Deletion) {
        detachFiberAfterEffects(nextEffect);
      }
      nextEffect = nextNextEffect;
    }
  }

  // Read this again, since an effect might have updated it
  remainingLanes = root.pendingLanes;

  // æ€§èƒ½ä¼˜åŒ–ç›¸å…³
  if (remainingLanes !== NoLanes) {
    if (enableSchedulerTracing) {
      if (spawnedWorkDuringRender !== null) {
        // ...
      }
      // ...
    }
  } else {
      // ...
  }
  // æ€§èƒ½ä¼˜åŒ–ç›¸å…³
  if (enableSchedulerTracing) {
    if (!rootDidHavePassiveEffects) {
      // ...
    }
  }
  // æ£€æµ‹æ— é™å¾ªç¯çš„åŒæ­¥ä»»åŠ¡
  if (remainingLanes === SyncLane) {
    if (root === rootWithNestedUpdates) {
      nestedUpdateCount++;
    } else {
      nestedUpdateCount = 0;
      rootWithNestedUpdates = root;
    }
  } else {
    nestedUpdateCount = 0;
  }
  // ...
  // åœ¨ç¦»å¼€commitRootå‡½æ•°å‰è°ƒç”¨ï¼Œè§¦å‘ä¸€æ¬¡æ–°çš„è°ƒåº¦ï¼Œç¡®ä¿ä»»ä½•é™„åŠ çš„ä»»åŠ¡è¢«è°ƒåº¦
  ensureRootIsScheduled(root, now());
  // å¤„ç†æœªæ•è·é”™è¯¯
  if (hasUncaughtError) {
    hasUncaughtError = false;
    const error = firstUncaughtError;
    firstUncaughtError = null;
    throw error;
  }
  // ...
  // æ‰§è¡ŒåŒæ­¥ä»»åŠ¡ï¼Œè¿™æ ·åŒæ­¥ä»»åŠ¡ä¸éœ€è¦ç­‰åˆ°ä¸‹æ¬¡äº‹ä»¶å¾ªç¯å†æ‰§è¡Œ
  // æ¯”å¦‚åœ¨ componentDidMount ä¸­æ‰§è¡Œ setState åˆ›å»ºçš„æ›´æ–°ä¼šåœ¨è¿™é‡Œè¢«åŒæ­¥æ‰§è¡Œ
  // æˆ–useLayoutEffect
  flushSyncCallbackQueue();
  // ...
  return null;
```
ä¸»è¦åŒ…æ‹¬ä¸‰ç‚¹å†…å®¹ï¼š
* 1. useEffectç›¸å…³çš„å¤„ç†ã€‚
  * æˆ‘ä»¬ä¼šåœ¨è®²è§£layouté˜¶æ®µæ—¶è®²è§£ã€‚
* 2. æ€§èƒ½è¿½è¸ªç›¸å…³ã€‚
  * æºç é‡Œæœ‰å¾ˆå¤šå’Œ interaction ç›¸å…³çš„å˜é‡ã€‚ä»–ä»¬éƒ½å’Œè¿½è¸ª React æ¸²æŸ“æ—¶é—´ã€æ€§èƒ½ç›¸å…³ï¼Œåœ¨ Profiler API å’Œ DevTools ä¸­ä½¿ç”¨ã€‚
::: warning
ä½ å¯ä»¥åœ¨è¿™é‡Œçœ‹åˆ° [interactionçš„å®šä¹‰](https://gist.github.com/bvaughn/8de925562903afd2e7a12554adcdda16) ã€‚
:::
* 3. åœ¨commité˜¶æ®µä¼šè§¦å‘ä¸€äº›ç”Ÿå‘½å‘¨æœŸé’©å­ï¼ˆå¦‚ componentDidXXXï¼‰å’Œhookï¼ˆå¦‚useLayoutEffectã€useEffectï¼‰ã€‚
  * åœ¨è¿™äº›å›è°ƒæ–¹æ³•ä¸­å¯èƒ½è§¦å‘æ–°çš„æ›´æ–°ï¼Œæ–°çš„æ›´æ–°ä¼šå¼€å¯æ–°çš„render-commitæµç¨‹ã€‚
### Before Mutation é˜¶æ®µ
Before Mutation é˜¶æ®µçš„ä»£ç å¾ˆçŸ­ï¼Œæ•´ä¸ªè¿‡ç¨‹å°±æ˜¯éå† effectList å¹¶è°ƒç”¨ `commitBeforeMutationEffects` å‡½æ•°å¤„ç†ã€‚
```javascript {33}
  // packages/react-reconciler/src/ReactFiberWorkLoop.old.js -> commitRootImpl function

  if (firstEffect !== null) {
    let previousLanePriority;
    if (decoupleUpdatePriorityFromScheduler) {
      previousLanePriority = getCurrentUpdateLanePriority();
      setCurrentUpdateLanePriority(SyncLanePriority);
    }

    const prevExecutionContext = executionContext;
    executionContext |= CommitContext;
    const prevInteractions = pushInteractions(root);

    // Reset this to null before calling lifecycles
    ReactCurrentOwner.current = null;

    // The commit phase is broken into several sub-phases. We do a separate pass
    // of the effect list for each phase: all mutation effects come before all
    // layout effects, and so on.

    // The first phase a "before mutation" phase. We use this phase to read the
    // state of the host tree right before we mutate it. This is where
    // getSnapshotBeforeUpdate is called.
    focusedInstanceHandle = prepareForCommit(root.containerInfo);
    shouldFireAfterActiveInstanceBlur = false;

    nextEffect = firstEffect;
    do {
      if (__DEV__) {
        // ...
      } else {
        try {
          commitBeforeMutationEffects();
        } catch (error) {
          invariant(nextEffect !== null, 'Should be working on an effect.');
          captureCommitPhaseError(nextEffect, error);
          nextEffect = nextEffect.nextEffect;
        }
      }
    } while (nextEffect !== null);
    // We no longer need to track the active instance fiber
    focusedInstanceHandle = null;
    // ...
  }
```
æˆ‘ä»¬é‡ç‚¹å…³æ³¨ Before Mutation é˜¶æ®µçš„ä¸»å‡½æ•° `commitBeforeMutationEffects` åšäº†ä»€ä¹ˆã€‚

#### commitBeforeMutationEffects
`commitBeforeMutationEffects` å‡½æ•°çš„å®šä¹‰å¦‚ä¸‹ï¼š
```javascript {7,16,25-28}
// packages/react-reconciler/src/ReactFiberWorkLoop.old.js

function commitBeforeMutationEffects() {
  while (nextEffect !== null) {
    const current = nextEffect.alternate;

    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
      // focus blurç›¸å…³ ...
    }

    const flags = nextEffect.flags;
    
    // è°ƒç”¨getSnapshotBeforeUpdate
    if ((flags & Snapshot) !== NoFlags) {
      // ...
      commitBeforeMutationEffectOnFiber(current, nextEffect);
      // ...
    }
    // è°ƒåº¦useEffect
    if ((flags & Passive) !== NoFlags) {
      // If there are passive effects, schedule a callback to flush at
      // the earliest opportunity.
      if (!rootDoesHavePassiveEffects) {
        rootDoesHavePassiveEffects = true;
        scheduleCallback(NormalSchedulerPriority, () => {
          flushPassiveEffects();
          return null;
        });
      }
    }
    nextEffect = nextEffect.nextEffect;
  }
}
```
æ•´ä½“å¯ä»¥åˆ†ä¸ºä¸‰éƒ¨åˆ†ï¼š
* 1. å¤„ç† DOM èŠ‚ç‚¹æ¸²æŸ“/åˆ é™¤åçš„ autoFocusã€blur é€»è¾‘
* 2. é€šè¿‡è°ƒç”¨ `commitBeforeMutationLifeCycles` å‡½æ•°è°ƒç”¨ ClassComponent å®ä¾‹çš„ `getSnapshotBeforeUpdate` ç”Ÿå‘½å‘¨æœŸé’©å­
* 3. è°ƒåº¦ useEffect
#### getSnapshotBeforeUpdate å£°æ˜å‘¨æœŸ
`commitBeforeMutationEffectOnFiber` å‡½æ•°æ˜¯ `commitBeforeMutationLifeCycles` å‡½æ•°çš„åˆ«åã€‚

åœ¨è¯¥æ–¹æ³•å†…ä¼šè°ƒç”¨ClassComponentå®ä¾‹çš„ `getSnapshotBeforeUpdate` æ–¹æ³•ã€‚
```javascript {21-26}
// packages/react-reconciler/src/ReactFiberCommitWork.old.js

function commitBeforeMutationLifeCycles(
  current: Fiber | null,
  finishedWork: Fiber,
): void {
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block: {
      return;
    }
    case ClassComponent: {
      if (finishedWork.flags & Snapshot) {
        if (current !== null) {
          const prevProps = current.memoizedProps;
          const prevState = current.memoizedState;
          const instance = finishedWork.stateNode;
          // ...
          const snapshot = instance.getSnapshotBeforeUpdate(
            finishedWork.elementType === finishedWork.type
              ? prevProps
              : resolveDefaultProps(finishedWork.type, prevProps),
            prevState,
          );
          // ...
          instance.__reactInternalSnapshotBeforeUpdate = snapshot;
        }
      }
      return;
    }
    // ...
  }
}
```
ä» React 16 å¼€å§‹ï¼Œ`componentWillXXX` é’©å­å‰å¢åŠ äº† `UNSAFE_` å‰ç¼€ã€‚

ç©¶å…¶åŸå› ï¼Œæ˜¯å› ä¸º `Stack Reconciler` é‡æ„ä¸º `Fiber Reconciler` åï¼Œrender é˜¶æ®µçš„ä»»åŠ¡å¯èƒ½ä¸­æ–­/é‡æ–°å¼€å§‹ï¼Œå¯¹åº”çš„ç»„ä»¶åœ¨ render é˜¶æ®µçš„ç”Ÿå‘½å‘¨æœŸé’©å­ï¼ˆå³ `componentWillXXX`ï¼‰å¯èƒ½è§¦å‘å¤šæ¬¡ã€‚

è¿™ç§è¡Œä¸ºå’Œ React 15 ä¸ä¸€è‡´ï¼Œæ‰€ä»¥æ ‡è®°ä¸º `UNSAFE_`ã€‚
::: warning
æ›´è¯¦ç»†çš„è§£é‡Šå‚ç…§[è¿™é‡Œ](https://zh-hans.reactjs.org/docs/react-component.html#the-component-lifecycle)ã€‚
:::
ä¸ºæ­¤ï¼ŒReactæä¾›äº†æ›¿ä»£çš„ç”Ÿå‘½å‘¨æœŸé’©å­getSnapshotBeforeUpdateã€‚

æˆ‘ä»¬å¯ä»¥çœ‹è§ï¼Œ`getSnapshotBeforeUpdate` é’©å­æ˜¯åœ¨ Commit é˜¶æ®µå†…çš„ Before Mutation é˜¶æ®µè°ƒç”¨çš„ï¼Œç”±äº Commit é˜¶æ®µæ˜¯åŒæ­¥çš„ï¼Œæ‰€ä»¥ä¸ä¼šé‡åˆ°å¤šæ¬¡è°ƒç”¨çš„é—®é¢˜ã€‚
#### useEffect è°ƒç”¨
åœ¨è¿™å‡ è¡Œä»£ç å†…ï¼Œ`scheduleCallback` å‡½æ•°ç”± Scheduler æ¨¡å—æä¾›ï¼Œç”¨äºä»¥æŸä¸ªä¼˜å…ˆçº§å¼‚æ­¥è°ƒåº¦ä¸€ä¸ªå›è°ƒå‡½æ•°ã€‚
```javascript
// è°ƒåº¦ useEffect
if ((flags & Passive) !== NoFlags) {
  // If there are passive effects, schedule a callback to flush at
  // the earliest opportunity.
  if (!rootDoesHavePassiveEffects) {
    rootDoesHavePassiveEffects = true;
    scheduleCallback(NormalSchedulerPriority, () => {
      // è§¦å‘ useEffect
      flushPassiveEffects();
      return null;
    });
  }
}
```
åœ¨æ­¤å¤„ï¼Œè¢«å¼‚æ­¥è°ƒåº¦çš„å›è°ƒå‡½æ•°å°±æ˜¯è§¦å‘ useEffect çš„å‡½æ•° `flushPassiveEffects`ã€‚

æˆ‘ä»¬æ¥ä¸‹æ¥è®¨è®º useEffect å¦‚ä½•è¢«å¼‚æ­¥è°ƒåº¦ï¼Œä»¥åŠä¸ºä»€ä¹ˆè¦å¼‚æ­¥ï¼ˆè€Œä¸æ˜¯åŒæ­¥ï¼‰è°ƒåº¦ã€‚
##### å¦‚ä½•å¼‚æ­¥è°ƒåº¦
åœ¨ `flushPassiveEffects` å‡½æ•°å†…éƒ¨è°ƒç”¨ `flushPassiveEffectsImpl` å‡½æ•°ï¼Œè€Œå…¶åˆä¼šä»å…¨å±€å˜é‡ `rootWithPendingPassiveEffects` è·å– `effectList` ã€‚

åœ¨ completeWork ä¸€èŠ‚æˆ‘ä»¬è®²åˆ°ï¼ŒeffectList ä¸­ä¿å­˜äº†éœ€è¦æ‰§è¡Œå‰¯ä½œç”¨çš„ Fiber èŠ‚ç‚¹ã€‚å…¶ä¸­å‰¯ä½œç”¨åŒ…æ‹¬ï¼š
* æ’å…¥ DOM èŠ‚ç‚¹ï¼ˆPlacementï¼‰
* æ›´æ–° DOM èŠ‚ç‚¹ï¼ˆUpdateï¼‰
* åˆ é™¤ DOM èŠ‚ç‚¹ï¼ˆDeletionï¼‰

é™¤æ­¤å¤–ï¼Œå½“ä¸€ä¸ª FunctionComponent å«æœ‰ useEffect æˆ– useLayoutEffect ï¼Œä»–å¯¹åº”çš„ Fiber èŠ‚ç‚¹ä¹Ÿä¼šè¢«èµ‹å€¼ flagsã€‚
::: warning
ä½ å¯ä»¥ä» `packages/react-reconciler/src/ReactHookEffectTags.js` çœ‹åˆ° hook ç›¸å…³çš„ HookFlags
:::
åœ¨ flushPassiveEffects æ–¹æ³•å†…éƒ¨ä¼šéå† rootWithPendingPassiveEffectsï¼ˆå³effectListï¼‰æ‰§è¡Œ effect å›è°ƒå‡½æ•°ã€‚
```javascript
  // packages/react-reconciler/src/ReactFiberWorkLoop.old.js -> flushPassiveEffectsImpl function

  // Note: This currently assumes there are no passive effects on the root fiber
  // because the root is not part of its own effect list.
  // This could change in the future.
  let effect = root.current.firstEffect;
  while (effect !== null) {
    const nextNextEffect = effect.nextEffect;
    // Remove nextEffect pointer to assist GC
    effect.nextEffect = null;
    if (effect.flags & Deletion) {
      detachFiberAfterEffects(effect);
    }
    effect = nextNextEffect;
  }
```
å¦‚æœåœ¨æ­¤æ—¶ç›´æ¥æ‰§è¡Œï¼Œ`rootWithPendingPassiveEffects === null`ã€‚é‚£ä¹ˆ `rootWithPendingPassiveEffects` ä¼šåœ¨ä½•æ—¶èµ‹å€¼å‘¢ï¼Ÿ

åœ¨ä¸Šä¸€èŠ‚ Layout ä¹‹åçš„ä»£ç ç‰‡æ®µä¸­ä¼šæ ¹æ® `rootDoesHavePassiveEffects === true` å†³å®šæ˜¯å¦èµ‹å€¼ srootWithPendingPassiveEffectsã€‚
```javascript
const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
if (rootDoesHavePassiveEffects) {
  rootDoesHavePassiveEffects = false;
  rootWithPendingPassiveEffects = root;
  pendingPassiveEffectsLanes = lanes;
  pendingPassiveEffectsRenderPriority = renderPriorityLevel;
}
```
æ‰€ä»¥æ•´ä¸ªuseEffectå¼‚æ­¥è°ƒç”¨åˆ†ä¸ºä¸‰æ­¥ï¼š
* 1. Before Mutation é˜¶æ®µåœ¨ `scheduleCallback` ä¸­è°ƒåº¦ `flushPassiveEffects` å‡½æ•°
* 2. Layout é˜¶æ®µä¹‹åå°† effectList èµ‹å€¼ç»™ rootWithPendingPassiveEffects
* 3. `scheduleCallback` è§¦å‘ `flushPassiveEffects`ï¼Œ`flushPassiveEffects` å†…éƒ¨éå† rootWithPendingPassiveEffects
##### ä¸ºä»€ä¹ˆéœ€è¦å¼‚æ­¥è°ƒç”¨
æ‘˜å½•è‡ªReactæ–‡æ¡£ [effect çš„æ‰§è¡Œæ—¶æœº](https://zh-hans.reactjs.org/docs/hooks-reference.html#timing-of-effects) ï¼š

> ä¸ componentDidMountã€componentDidUpdate ä¸åŒçš„æ˜¯ï¼Œåœ¨æµè§ˆå™¨å®Œæˆå¸ƒå±€ä¸ç»˜åˆ¶ä¹‹åï¼Œä¼ ç»™ useEffect çš„å‡½æ•°ä¼šå»¶è¿Ÿè°ƒç”¨ã€‚è¿™ä½¿å¾—å®ƒé€‚ç”¨äºè®¸å¤šå¸¸è§çš„å‰¯ä½œç”¨åœºæ™¯ï¼Œæ¯”å¦‚è®¾ç½®è®¢é˜…å’Œäº‹ä»¶å¤„ç†ç­‰æƒ…å†µï¼Œå› æ­¤ä¸åº”åœ¨å‡½æ•°ä¸­æ‰§è¡Œé˜»å¡æµè§ˆå™¨æ›´æ–°å±å¹•çš„æ“ä½œã€‚

å¯è§ï¼ŒuseEffectå¼‚æ­¥æ‰§è¡Œçš„åŸå› ä¸»è¦æ˜¯é˜²æ­¢åŒæ­¥æ‰§è¡Œæ—¶é˜»å¡æµè§ˆå™¨æ¸²æŸ“ã€‚
### Mutation é˜¶æ®µ
ç±»ä¼¼ Before Mutation é˜¶æ®µï¼ŒMutation é˜¶æ®µä¹Ÿæ˜¯éå† effectListï¼Œæ‰§è¡Œå‡½æ•°ã€‚è¿™é‡Œæ‰§è¡Œçš„æ˜¯ `commitMutationEffects` å‡½æ•°ã€‚
```javascript {12}
  // packages/react-reconciler/src/ReactFiberWorkLoop.old.js -> commitRootImpl function

  if (firstEffect !== null) {
    // ...
    // The next phase is the mutation phase, where we mutate the host tree.
    nextEffect = firstEffect;
    do {
      if (__DEV__) {
        // ...
      } else {
        try {
          commitMutationEffects(root, renderPriorityLevel);
        } catch (error) {
          invariant(nextEffect !== null, 'Should be working on an effect.');
          captureCommitPhaseError(nextEffect, error);
          nextEffect = nextEffect.nextEffect;
        }
      }
    } while (nextEffect !== null);
    // ...
  }
```
#### commitMutationEffects
commitMutationEffects å‡½æ•°çš„ä»£ç å®šä¹‰å¦‚ä¸‹ï¼š
```javascript {38,48,75,81}
// packages/react-reconciler/src/ReactFiberWorkLoop.old.js

function commitMutationEffects(
  root: FiberRoot,
  renderPriorityLevel: ReactPriorityLevel,
) {
  // TODO: Should probably move the bulk of this function to commitWork.
  while (nextEffect !== null) {
    setCurrentDebugFiberInDEV(nextEffect);

    const flags = nextEffect.flags;
    // æ ¹æ® ContentReset flagsé‡ç½®æ–‡å­—èŠ‚ç‚¹
    if (flags & ContentReset) {
      commitResetTextContent(nextEffect);
    }
    // æ›´æ–°ref
    if (flags & Ref) {
      const current = nextEffect.alternate;
      if (current !== null) {
        commitDetachRef(current);
      }
      if (enableScopeAPI) {
        // TODO: This is a temporary solution that allowed us to transition away
        // from React Flare on www.
        if (nextEffect.tag === ScopeComponent) {
          commitAttachRef(nextEffect);
        }
      }
    }

    // The following switch statement is only concerned about placement,
    // updates, and deletions. To avoid needing to add a case for every possible
    // bitmap value, we remove the secondary effects from the effect tag and
    // switch on that value.
    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);
    switch (primaryFlags) {
      // æ’å…¥DOM
      case Placement: {
        commitPlacement(nextEffect);
        // Clear the "placement" from effect tag so that we know that this is
        // inserted, before any life-cycles like componentDidMount gets called.
        // TODO: findDOMNode doesn't rely on this any more but isMounted does
        // and isMounted is deprecated anyway so we should be able to kill this.
        nextEffect.flags &= ~Placement;
        break;
      }
      // æ’å…¥DOM å¹¶ æ›´æ–°DOM
      case PlacementAndUpdate: {
        // æ’å…¥
        commitPlacement(nextEffect);
        // Clear the "placement" from effect tag so that we know that this is
        // inserted, before any life-cycles like componentDidMount gets called.
        nextEffect.flags &= ~Placement;

        // æ›´æ–°
        const current = nextEffect.alternate;
        commitWork(current, nextEffect);
        break;
      }
      // SSRç›¸å…³
      case Hydrating: {
        nextEffect.flags &= ~Hydrating;
        break;
      }
      // SSRç›¸å…³
      case HydratingAndUpdate: {
        nextEffect.flags &= ~Hydrating;

        // Update
        const current = nextEffect.alternate;
        commitWork(current, nextEffect);
        break;
      }
      // æ›´æ–°DOM
      case Update: {
        const current = nextEffect.alternate;
        commitWork(current, nextEffect);
        break;
      }
      // åˆ é™¤DOM
      case Deletion: {
        commitDeletion(root, nextEffect, renderPriorityLevel);
        break;
      }
    }
    // ...
    nextEffect = nextEffect.nextEffect;
  }
}
```
`commitMutationEffects` å‡½æ•°ä¼šéå† effectListï¼Œå¯¹æ¯ä¸ª Fiber èŠ‚ç‚¹æ‰§è¡Œå¦‚ä¸‹ä¸‰ä¸ªæ“ä½œï¼š
* æ ¹æ® ContentReset flags é‡ç½®æ–‡å­—èŠ‚ç‚¹
* æ›´æ–° ref
* æ ¹æ® flags åˆ†åˆ«å¤„ç†ï¼Œå…¶ä¸­ flags åŒ…æ‹¬(Placement | Update | Deletion | Hydrating)

æˆ‘ä»¬å…³æ³¨æ­¥éª¤ä¸‰ä¸­çš„Placement | Update | Deletionã€‚Hydratingä½œä¸ºæœåŠ¡ç«¯æ¸²æŸ“ç›¸å…³ï¼Œæˆ‘ä»¬å…ˆä¸å…³æ³¨ã€‚

#### Placement Effect
å½“ Fiber èŠ‚ç‚¹å«æœ‰ Placement flags ï¼Œæ„å‘³ç€è¯¥ Fiber èŠ‚ç‚¹å¯¹åº”çš„ DOM èŠ‚ç‚¹éœ€è¦æ’å…¥åˆ°é¡µé¢ä¸­ã€‚

è°ƒç”¨çš„æ–¹æ³•ä¸º `commitPlacement` å‡½æ•°ï¼Œå…¶å®šä¹‰å¦‚ä¸‹ï¼š
```javascript {9,14,42,45-49}
// packages/react-reconciler/src/ReactFiberCommitWork.old.js

function commitPlacement(finishedWork: Fiber): void {
  if (!supportsMutation) {
    return;
  }

  // Recursively insert all host nodes into the parent.
  const parentFiber = getHostParentFiber(finishedWork);

  // Note: these two variables *must* always be updated together.
  let parent;
  let isContainer;
  const parentStateNode = parentFiber.stateNode;
  switch (parentFiber.tag) {
    case HostComponent:
      parent = parentStateNode;
      isContainer = false;
      break;
    case HostRoot:
      parent = parentStateNode.containerInfo;
      isContainer = true;
      break;
    case HostPortal:
      parent = parentStateNode.containerInfo;
      isContainer = true;
      break;
    case FundamentalComponent:
      if (enableFundamentalAPI) {
        parent = parentStateNode.instance;
        isContainer = false;
      }
    // ...
  }
  if (parentFiber.flags & ContentReset) {
    // Reset the text content of the parent before doing any insertions
    resetTextContent(parent);
    // Clear ContentReset from the effect tag
    parentFiber.flags &= ~ContentReset;
  }

  const before = getHostSibling(finishedWork);
  // We only have the top Fiber that was inserted but we need to recurse down its
  // children to find all the terminal nodes.
  if (isContainer) {
    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
  } else {
    insertOrAppendPlacementNode(finishedWork, before, parent);
  }
}
```
è¯¥æ–¹æ³•æ‰€åšçš„å·¥ä½œåˆ†ä¸ºä¸‰æ­¥ï¼š

1. è·å–çˆ¶çº§ DOM èŠ‚ç‚¹ã€‚å…¶ä¸­ finishedWork ä¸ºä¼ å…¥çš„ Fiber èŠ‚ç‚¹ã€‚
```javascript
  const parentFiber = getHostParentFiber(finishedWork);
  // çˆ¶çº§DOMèŠ‚ç‚¹
  const parentStateNode = parentFiber.stateNode;
```
2. è·å– Fiber èŠ‚ç‚¹çš„ DOM å…„å¼ŸèŠ‚ç‚¹
```javascript
  const before = getHostSibling(finishedWork);
```
3. æ ¹æ® DOM å…„å¼ŸèŠ‚ç‚¹æ˜¯å¦å­˜åœ¨å†³å®šè°ƒç”¨ parentNode.insertBefore æˆ– parentNode.appendChild æ‰§è¡Œ DOM æ’å…¥æ“ä½œã€‚
```javascript
// parentStateNode æ˜¯å¦æ˜¯ rootFiber
  if (isContainer) {
    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
  } else {
    insertOrAppendPlacementNode(finishedWork, before, parent);
  }
```
å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œ`getHostSibling` å‡½æ•°ï¼ˆè·å–å…„å¼ŸDOMèŠ‚ç‚¹ï¼‰çš„æ‰§è¡Œå¾ˆè€—æ—¶ï¼Œå½“åœ¨åŒä¸€ä¸ªçˆ¶ Fiber èŠ‚ç‚¹ä¸‹ä¾æ¬¡æ‰§è¡Œå¤šä¸ªæ’å…¥æ“ä½œï¼Œ`getHostSibling` å‡½æ•°ç®—æ³•çš„å¤æ‚åº¦ä¸ºæŒ‡æ•°çº§ã€‚

è¿™æ˜¯ç”±äº Fiber èŠ‚ç‚¹ä¸åªåŒ…æ‹¬ HostComponent ï¼Œæ‰€ä»¥ Fiber æ ‘å’Œæ¸²æŸ“çš„ DOM æ ‘èŠ‚ç‚¹å¹¶ä¸æ˜¯ä¸€ä¸€å¯¹åº”çš„ã€‚è¦ä» Fiber èŠ‚ç‚¹æ‰¾åˆ° DOM èŠ‚ç‚¹å¾ˆå¯èƒ½è·¨å±‚çº§éå†ã€‚

é‚£ä¹ˆæˆ‘ä»¬è€ƒè™‘å¦‚ä¸‹çš„ä¾‹å­æ¢³ç†ä»–çš„ Fiber æ ‘å’Œ DOM æ ‘ç»“æ„ï¼š
```jsx
function Item() {
  return <li><li>;
}

function App() {
  return (
    <div>
      <Item/>
    </div>
  )
}

ReactDOM.render(<App/>, document.getElementById('root'));
```
å¯¹åº”çš„ Fiber æ ‘å’Œ DOM æ ‘ç»“æ„ä¸ºï¼š
![fiber-tree-dom-tree-1](~@/assets/posts/react-source-2steps-render/fiber-tree-dom-tree-1.png)
å½“åœ¨ div çš„å­èŠ‚ç‚¹ Item å‰æ’å…¥ä¸€ä¸ªæ–°èŠ‚ç‚¹ pï¼Œå³ Appå˜ä¸ºï¼š
```javascript
function App() {
  return (
    <div>
      <p></p>
      <Item/>
    </div>
  )
}
```
å¯¹åº”çš„ Fiber æ ‘å’Œ DOM æ ‘ç»“æ„ä¸ºï¼š
![fiber-tree-dom-tree-2](~@/assets/posts/react-source-2steps-render/fiber-tree-dom-tree-2.png)
æ­¤æ—¶ DOM èŠ‚ç‚¹ p çš„å…„å¼ŸèŠ‚ç‚¹ä¸º liï¼Œè€Œ Fiber èŠ‚ç‚¹ p å¯¹åº”çš„å…„å¼Ÿ DOM èŠ‚ç‚¹ä¸ºï¼š`fiberP.sibling.child` 
å³ `fiber p` çš„å…„å¼Ÿ `fiber Item` çš„å­ `fiber li`
#### Update Effect
å½“ Fiber èŠ‚ç‚¹å«æœ‰ Update flagsï¼Œæ„å‘³ç€è¯¥ Fiber èŠ‚ç‚¹éœ€è¦æ›´æ–°ã€‚è°ƒç”¨çš„å‡½æ•°ä¸º `commitWork` ï¼Œä»–ä¼šæ ¹æ® `Fiber.tag` åˆ†åˆ«å¤„ç†ã€‚

`commitWork` å‡½æ•°çš„å®šä¹‰å¦‚ä¸‹ï¼š
```javascript {6,29-54}
// packages/react-reconciler/src/ReactFiberCommitWork.old.js

function commitWork(current: Fiber | null, finishedWork: Fiber): void {
  // ...
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent:
    case Block: {
      // Layout effects are destroyed during the mutation phase so that all
      // destroy functions for all fibers are called before any create functions.
      // This prevents sibling component effects from interfering with each other,
      // e.g. a destroy function in one component should never override a ref set
      // by a create function in another component during the same commit.
      if (
        enableProfilerTimer &&
        enableProfilerCommitHooks &&
        finishedWork.mode & ProfileMode
      ) {
        // ...
      } else {
        commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork);
      }
      return;
    }
    case ClassComponent: 
      // ...
    case HostComponent: {
      const instance: Instance = finishedWork.stateNode;
      if (instance != null) {
        // Commit the work prepared earlier.
        const newProps = finishedWork.memoizedProps;
        // For hydration we reuse the update path but we treat the oldProps
        // as the newProps. The updatePayload will contain the real change in
        // this case.
        const oldProps = current !== null ? current.memoizedProps : newProps;
        const type = finishedWork.type;
        // TODO: Type the updateQueue to be specific to host components.
        const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any);
        finishedWork.updateQueue = null;
        if (updatePayload !== null) {
          commitUpdate(
            instance,
            updatePayload,
            type,
            oldProps,
            newProps,
            finishedWork,
          );
        }
      }
      return;
    }
    case HostText: 
      // ...
    case HostRoot: 
      // ...
    case Profiler: 
      // ...
    case SuspenseComponent: 
      // ...
    case SuspenseListComponent: 
      // ...
    case IncompleteClassComponent: 
      // ...
    case FundamentalComponent: 
      // ...
    case ScopeComponent: 
      // ...
    case OffscreenComponent:
    case LegacyHiddenComponent: 
      // ...
  }
  // ...
}
```
è¿™é‡Œæˆ‘ä»¬ä¸»è¦å…³æ³¨ `FunctionComponent tag` å’Œ `HostComponent tag` ã€‚
##### FunctionComponent Mutation
å½“ fiber.tag ä¸º FunctionComponent ï¼Œä¼šè°ƒç”¨ `commitHookEffectListUnmount` å‡½æ•°ã€‚è¯¥æ–¹æ³•ä¼šéå† effectListï¼Œæ‰§è¡Œæ‰€æœ‰ `useLayoutEffect hook` çš„é”€æ¯å‡½æ•°ã€‚
```javascript
function commitHookEffectListUnmount(tag: number, finishedWork: Fiber) {
  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      if ((effect.tag & tag) === tag) {
        // Unmount
        const destroy = effect.destroy;
        effect.destroy = undefined;
        if (destroy !== undefined) {
          destroy();
        }
      }
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}
```
æ‰€è°“â€œé”€æ¯å‡½æ•°â€ï¼Œè§å¦‚ä¸‹ä¾‹å­ï¼š
```javascript
useLayoutEffect(() => {
  // ...ä¸€äº›å‰¯ä½œç”¨é€»è¾‘

  return () => {
    // ...è¿™å°±æ˜¯é”€æ¯å‡½æ•°
  }
})
```
ä½ ä¸éœ€è¦å¾ˆäº†è§£ `useLayoutEffect` ï¼Œä¹‹åä¼šè¯¦ç»†ä»‹ç»ã€‚ä½ åªéœ€è¦çŸ¥é“åœ¨ Mutation é˜¶æ®µä¼šæ‰§è¡Œ `useLayoutEffect` çš„é”€æ¯å‡½æ•°ã€‚
##### HostComponent Mutation
å½“ fiber.tag ä¸º HostComponent ï¼Œä¼šè°ƒç”¨ `commitUpdate` å‡½æ•°ã€‚
```javascript
// packages/react-dom/src/client/ReactDOMHostConfig.js ?

export function commitUpdate(
  domElement: Instance,
  updatePayload: Array<mixed>,
  type: string,
  oldProps: Props,
  newProps: Props,
  internalInstanceHandle: Object,
): void {
  // Update the props handle so that we know which props are the ones with
  // with current event handlers.
  updateFiberProps(domElement, newProps);
  // Apply the diff to the DOM node.
  updateProperties(domElement, updatePayload, type, oldProps, newProps);
}
```
æœ€ç»ˆä¼šåœ¨ `updateDOMProperties` å‡½æ•°ä¸­å°† renderé˜¶æ®µ completeWork ä¸­ä¸º Fiber èŠ‚ç‚¹èµ‹å€¼çš„ updateQueue å¯¹åº”çš„å†…å®¹æ¸²æŸ“åœ¨é¡µé¢ä¸Šã€‚
```javascript
function updateDOMProperties(
  domElement: Element,
  updatePayload: Array<any>,
  wasCustomComponentTag: boolean,
  isCustomComponentTag: boolean,
): void {
  // TODO: Handle wasCustomComponentTag
  for (let i = 0; i < updatePayload.length; i += 2) {
    const propKey = updatePayload[i];
    const propValue = updatePayload[i + 1];
    if (propKey === STYLE) {
      setValueForStyles(domElement, propValue);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      setInnerHTML(domElement, propValue);
    } else if (propKey === CHILDREN) {
      setTextContent(domElement, propValue);
    } else {
      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
    }
  }
}
```
#### Deletion Effect
å½“FiberèŠ‚ç‚¹å«æœ‰Deletion flags ï¼Œæ„å‘³ç€è¯¥FiberèŠ‚ç‚¹å¯¹åº”çš„DOMèŠ‚ç‚¹éœ€è¦ä»é¡µé¢ä¸­åˆ é™¤ã€‚è°ƒç”¨çš„æ–¹æ³•ä¸º commitDeletion ã€‚
```javascript
function commitDeletion(
  finishedRoot: FiberRoot,
  current: Fiber,
  renderPriorityLevel: ReactPriorityLevel,
): void {
  if (supportsMutation) {
    // Recursively delete all host nodes from the parent.
    // Detach refs and call componentWillUnmount() on the whole subtree.
    unmountHostComponents(finishedRoot, current, renderPriorityLevel);
  } else {
    // Detach refs and call componentWillUnmount() on the whole subtree.
    commitNestedUnmounts(finishedRoot, current, renderPriorityLevel);
  }
  const alternate = current.alternate;
  detachFiberMutation(current);
  if (alternate !== null) {
    detachFiberMutation(alternate);
  }
}
```
è¯¥æ–¹æ³•ä¼šæ‰§è¡Œå¦‚ä¸‹æ“ä½œï¼š
* é€’å½’è°ƒç”¨ Fiber èŠ‚ç‚¹åŠå…¶å­å­™ Fiber èŠ‚ç‚¹ä¸­ fiber.tag ä¸º ClassComponent çš„ `componentWillUnmount` ç”Ÿå‘½å‘¨æœŸé’©å­ï¼Œä»é¡µé¢ç§»é™¤ Fiber èŠ‚ç‚¹å¯¹åº” DOM èŠ‚ç‚¹
* è§£ç»‘ ref: `unmountHostComponents å‡½æ•° -> commitUnmount å‡½æ•°`
* è°ƒåº¦ useEffect çš„é”€æ¯å‡½æ•°
#### æ€»ç»“
ä»è¿™èŠ‚æˆ‘ä»¬å­¦åˆ°ï¼ŒMutation é˜¶æ®µä¼šéå† effectListï¼Œä¾æ¬¡æ‰§è¡Œ `commitMutationEffects` å‡½æ•°ã€‚è¯¥å‡½æ•°çš„ä¸»è¦å·¥ä½œä¸ºï¼š**æ ¹æ® flags è°ƒç”¨ä¸åŒçš„å¤„ç†å‡½æ•°å¤„ç† Fiber**ã€‚
### Layout é˜¶æ®µ
ä¸å‰ä¸¤ä¸ªé˜¶æ®µç±»ä¼¼ï¼ŒLayout é˜¶æ®µä¹Ÿæ˜¯éå† effectListï¼Œæ‰§è¡Œå‡½æ•°ã€‚
å…·ä½“æ‰§è¡Œçš„å‡½æ•°æ˜¯ `commitLayoutEffects` ã€‚
```javascript {14}
  // packages/react-reconciler/src/ReactFiberWorkLoop.old.js -> commitRootImpl function

  if (firstEffect !== null) {
    // ...
    // The next phase is the layout phase, where we call effects that read
    // the host tree after it's been mutated. The idiomatic use case for this is
    // layout, but class component lifecycles also fire here for legacy reasons.
    nextEffect = firstEffect;
    do {
      if (__DEV__) {
        // ...s
      } else {
        try {
          commitLayoutEffects(root, lanes);
        } catch (error) {
          invariant(nextEffect !== null, 'Should be working on an effect.');
          captureCommitPhaseError(nextEffect, error);
          nextEffect = nextEffect.nextEffect;
        }
      }
    } while (nextEffect !== null);

    nextEffect = null;
    // ...
  }
```
#### commitLayoutEffects
`commitLayoutEffects` å‡½æ•°çš„å®šä¹‰å¦‚ä¸‹ï¼š
```javascript {12,17}
// packages/react-reconciler/src/ReactFiberWorkLoop.old.js

function commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {
  // ...
  // TODO: Should probably move the bulk of this function to commitWork.
  while (nextEffect !== null) {
    // ...
    const flags = nextEffect.flags;
    // è°ƒç”¨ç”Ÿå‘½å‘¨æœŸé’©å­å’Œhook
    if (flags & (Update | Callback)) {
      const current = nextEffect.alternate;
      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);
    }
    // ...
    if (flags & Ref) {
      // èµ‹å€¼ref
      commitAttachRef(nextEffect);
    }
    // ...
    nextEffect = nextEffect.nextEffect;
  }
  // ...
}
```
`commitLayoutEffects` å‡½æ•°ä¸€å…±åšäº†ä¸¤ä»¶äº‹ï¼š
* `commitLayoutEffectOnFiber`ï¼ˆè°ƒç”¨ç”Ÿå‘½å‘¨æœŸé’©å­å’Œhookç›¸å…³æ“ä½œï¼‰
* `commitAttachRef`ï¼ˆèµ‹å€¼ refï¼‰
#### commitLayoutEffectOnFiber
`commitLayoutEffectOnFiber` å‡½æ•°ä¼šæ ¹æ® fiber.tag å¯¹ä¸åŒç±»å‹çš„èŠ‚ç‚¹åˆ†åˆ«å¤„ç†ã€‚
`commitLayoutEffectOnFiber` ä¸ºåˆ«åï¼Œæ–¹æ³•åŸåä¸º `commitLifeCycles`ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š
```javascript {10,25,59}
// packages/react-reconciler/src/ReactFiberCommitWork.old.js

function commitLifeCycles(
  finishedRoot: FiberRoot,
  current: Fiber | null,
  finishedWork: Fiber,
  committedLanes: Lanes,
): void {
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block: {
      // At this point layout effects have already been destroyed (during mutation phase).
      // This is done to prevent sibling component effects from interfering with each other,
      // e.g. a destroy function in one component should never override a ref set
      // by a create function in another component during the same commit.
      // ...
      // æ‰§è¡ŒuseLayoutEffectçš„å›è°ƒå‡½æ•°
      commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);
      // è°ƒåº¦useEffectçš„é”€æ¯å‡½æ•°ä¸å›è°ƒå‡½æ•°
      schedulePassiveEffects(finishedWork);
      return;
    }
    case ClassComponent: {
      const instance = finishedWork.stateNode;
      if (finishedWork.flags & Update) {
        if (current === null) {
          // ...
          instance.componentDidMount();
        } else {
          const prevProps =
            finishedWork.elementType === finishedWork.type
              ? current.memoizedProps
              : resolveDefaultProps(finishedWork.type, current.memoizedProps);
          const prevState = current.memoizedState;
          // ...
          instance.componentDidUpdate(
            prevProps,
            prevState,
            instance.__reactInternalSnapshotBeforeUpdate,
          );
        }
      }

      // TODO: I think this is now always non-null by the time it reaches the
      // commit phase. Consider removing the type check.
      const updateQueue: UpdateQueue<
        *,
      > | null = (finishedWork.updateQueue: any);
      if (updateQueue !== null) {
        // We could update instance props and state here,
        // but instead we rely on them being set during last render.
        // TODO: revisit this when we implement resuming.
        commitUpdateQueue(finishedWork, updateQueue, instance);
      }
      return;
    }
    case HostRoot: {
      // TODO: I think this is now always non-null by the time it reaches the
      // commit phase. Consider removing the type check.
      const updateQueue: UpdateQueue<
        *,
      > | null = (finishedWork.updateQueue: any);
      if (updateQueue !== null) {
        let instance = null;
        if (finishedWork.child !== null) {
          switch (finishedWork.child.tag) {
            case HostComponent:
              instance = getPublicInstance(finishedWork.child.stateNode);
              break;
            case ClassComponent:
              instance = finishedWork.child.stateNode;
              break;
          }
        }
        commitUpdateQueue(finishedWork, updateQueue, instance);
      }
      return;
    }
    case HostComponent: {
      const instance: Instance = finishedWork.stateNode;

      // Renderers may schedule work to be done after host components are mounted
      // (eg DOM renderer may schedule auto-focus for inputs and form controls).
      // These effects should only be committed when components are first mounted,
      // aka when there is no current/alternate.
      if (current === null && finishedWork.flags & Update) {
        const type = finishedWork.type;
        const props = finishedWork.memoizedProps;
        commitMount(instance, type, props, finishedWork);
      }

      return;
    }
    case HostText: 
      // ...
    case HostPortal: 
      // ...
    case Profiler: 
      // ...
    case SuspenseComponent: 
      // ...
    case SuspenseListComponent:
    case IncompleteClassComponent:
    case FundamentalComponent:
    case ScopeComponent:
    case OffscreenComponent:
    case LegacyHiddenComponent:
      return;
  }
  // ...
}
```
* å¯¹äº ClassComponentï¼Œä»–ä¼šé€šè¿‡ `current === null` åŒºåˆ†æ˜¯é¦–æ¬¡æ¸²æŸ“è¿˜æ˜¯æ›´æ–°æ¸²æŸ“ï¼Œè°ƒç”¨ `componentDidMount` æˆ– `componentDidUpdate` ã€‚

è§¦å‘çŠ¶æ€æ›´æ–°çš„ `this.setState` å¦‚æœèµ‹å€¼äº†ç¬¬äºŒä¸ªå‚æ•°å›è°ƒå‡½æ•°ï¼Œä¹Ÿä¼šåœ¨æ­¤æ—¶è°ƒç”¨ã€‚

* å¯¹äº FunctionComponent åŠç›¸å…³ç±»å‹ï¼Œä»–ä¼šè°ƒç”¨ `useLayoutEffect hook` çš„å›è°ƒå‡½æ•°ï¼Œè°ƒåº¦ useEffect çš„é”€æ¯ä¸å›è°ƒå‡½æ•°
::: warning
`ç›¸å…³ç±»å‹`æŒ‡ç‰¹æ®Šå¤„ç†åçš„ FunctionComponent ï¼Œæ¯”å¦‚ ForwardRef ã€ React.memo åŒ…è£¹çš„ FunctionComponent
:::
åœ¨ä¸Šä¸€èŠ‚ä»‹ç»Update effectæ—¶ä»‹ç»è¿‡ï¼ŒMutation é˜¶æ®µä¼šæ‰§è¡Œ `useLayoutEffect hook` çš„é”€æ¯å‡½æ•°ã€‚

ç»“åˆè¿™é‡Œæˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œ`useLayoutEffect hook` ä»ä¸Šä¸€æ¬¡æ›´æ–°çš„é”€æ¯å‡½æ•°è°ƒç”¨åˆ°æœ¬æ¬¡æ›´æ–°çš„å›è°ƒå‡½æ•°è°ƒç”¨æ˜¯åŒæ­¥æ‰§è¡Œçš„ã€‚

è€Œ useEffect åˆ™éœ€è¦å…ˆè°ƒåº¦ï¼Œåœ¨ Layout é˜¶æ®µå®Œæˆåå†å¼‚æ­¥æ‰§è¡Œã€‚

è¿™å°±æ˜¯ useLayoutEffect ä¸ useEffect çš„åŒºåˆ«ã€‚
* å¯¹äºHostRootï¼Œå³rootFiberï¼Œå¦‚æœèµ‹å€¼äº†ç¬¬ä¸‰ä¸ªå‚æ•°å›è°ƒå‡½æ•°ï¼Œä¹Ÿä¼šåœ¨æ­¤æ—¶è°ƒç”¨ã€‚

```jsx
ReactDOM.render(<App />, document.querySelector("#root"), function() {
  console.log("i am mount~");
});
```
#### commitAttachRef
`commitLayoutEffects` ä¼šåšçš„ç¬¬äºŒä»¶äº‹æ˜¯ `commitAttachRef`ã€‚

`commitAttachRef` å‡½æ•°çš„å®šä¹‰å¦‚ä¸‹ï¼š
```javascript
function commitAttachRef(finishedWork: Fiber) {
  const ref = finishedWork.ref;
  if (ref !== null) {
    const instance = finishedWork.stateNode;
    let instanceToUse;
    switch (finishedWork.tag) {
      case HostComponent:
        instanceToUse = getPublicInstance(instance);
        break;
      default:
        instanceToUse = instance;
    }
    // Moved outside to ensure DCE works with this flag
    if (enableScopeAPI && finishedWork.tag === ScopeComponent) {
      instanceToUse = instance;
    }
    if (typeof ref === 'function') {
      // ...
      ref(instanceToUse);
    } else {
      // ...
      ref.current = instanceToUse;
    }
  }
}
```
ä»£ç é€»è¾‘å¾ˆç®€å•ï¼šè·å–DOMå®ä¾‹ï¼Œæ›´æ–°refã€‚
#### current Fiberæ ‘åˆ‡æ¢
è‡³æ­¤ï¼Œæ•´ä¸ªlayouté˜¶æ®µå°±ç»“æŸäº†ã€‚

åœ¨ç»“æŸæœ¬èŠ‚çš„å­¦ä¹ å‰ï¼Œæˆ‘ä»¬å…³æ³¨ä¸‹è¿™è¡Œä»£ç ï¼š
```javascript {9}
  // packages/react-reconciler/src/ReactFiberWorkLoop.old.js -> commitRootImpl function

  if (firstEffect !== null) {
    // ...
    // The work-in-progress tree is now the current tree. This must come after
    // the mutation phase, so that the previous tree is still current during
    // componentWillUnmount, but before the layout phase, so that the finished
    // work is current during componentDidMount/Update.
    root.current = finishedWork;

    // The next phase is the layout phase, where we call effects that read
    // the host tree after it's been mutated. The idiomatic use case for this is
    // layout, but class component lifecycles also fire here for legacy reasons.
    nextEffect = firstEffect;
    do {
      if (__DEV__) {
        // ...s
      } else {
        try {
          commitLayoutEffects(root, lanes);
        } catch (error) {
          invariant(nextEffect !== null, 'Should be working on an effect.');
          captureCommitPhaseError(nextEffect, error);
          nextEffect = nextEffect.nextEffect;
        }
      }
    } while (nextEffect !== null);

    nextEffect = null;
    // ...
  }
```
åœ¨ä¹‹å‰æˆ‘ä»¬ ä»‹ç»React ä¸­çš„åŒç¼“å­˜æœºåˆ¶ï¼Œ`workInProgress Fiberæ ‘` åœ¨ Commit é˜¶æ®µå®Œæˆæ¸²æŸ“åä¼šå˜ä¸º `current Fiberæ ‘`ã€‚è¿™è¡Œä»£ç çš„ä½œç”¨å°±æ˜¯åˆ‡æ¢ fiberRootNode æŒ‡å‘çš„ `current Fiberæ ‘` ã€‚

é‚£ä¹ˆè¿™è¡Œä»£ç ä¸ºä»€ä¹ˆåœ¨è¿™é‡Œå‘¢ï¼Ÿï¼ˆåœ¨mutationé˜¶æ®µç»“æŸåï¼Œlayouté˜¶æ®µå¼€å§‹å‰ã€‚ï¼‰

æˆ‘ä»¬çŸ¥é“ `componentWillUnmount` ä¼šåœ¨ Mutation é˜¶æ®µæ‰§è¡Œã€‚æ­¤æ—¶ `current Fiberæ ‘` è¿˜æŒ‡å‘å‰ä¸€æ¬¡æ›´æ–°çš„Fiberæ ‘ï¼Œåœ¨ç”Ÿå‘½å‘¨æœŸé’©å­å†…è·å–çš„DOMè¿˜æ˜¯æ›´æ–°å‰çš„ã€‚

`componentDidMount` å’Œ `componentDidUpdate` ä¼šåœ¨ Layout é˜¶æ®µæ‰§è¡Œã€‚æ­¤æ—¶ `current Fiber` æ ‘å·²ç»æŒ‡å‘æ›´æ–°åçš„ Fiber æ ‘ï¼Œåœ¨ç”Ÿå‘½å‘¨æœŸé’©å­å†…è·å–çš„DOMå°±æ˜¯æ›´æ–°åçš„ã€‚
#### æ€»ç»“
ä»è¿™èŠ‚æˆ‘ä»¬å­¦åˆ°ï¼ŒLayout é˜¶æ®µä¼šéå† effectListï¼Œä¾æ¬¡æ‰§è¡Œ `commitLayoutEffects` ã€‚è¯¥æ–¹æ³•çš„ä¸»è¦å·¥ä½œä¸ºï¼š**æ ¹æ® flags è°ƒç”¨ä¸åŒçš„å¤„ç†å‡½æ•°å¤„ç† Fiber å¹¶æ›´æ–° rsef**ã€‚
## æµç¨‹å›¾è§£
![full-process](~@/assets/posts/react-source-2steps-render/full-process.png)
## æ•´ä½“æ€»ç»“
ğŸ‘»